<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emilie Devijver">
<meta name="author" content="Adeline Samson">
<meta name="dcterms.date" content="2024-12-08">
<meta name="keywords" content="functional data, repeated data, confidence band, Kac-Rice formulae, bias, dimension selection">

<title>Should we correct the bias in Confidence Bands for Repeated Functional Data?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="ConfBand_files/libs/clipboard/clipboard.min.js"></script>
<script src="ConfBand_files/libs/quarto-html/quarto.js"></script>
<script src="ConfBand_files/libs/quarto-html/popper.min.js"></script>
<script src="ConfBand_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ConfBand_files/libs/quarto-html/anchor.min.js"></script>
<link href="ConfBand_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ConfBand_files/libs/quarto-html/quarto-syntax-highlighting-0626ff4d7a71b55c8707dcae1d04a9b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ConfBand_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ConfBand_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ConfBand_files/libs/bootstrap/bootstrap-0ec49e081fc9fd0a69e64d62137d8a0c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="ConfBand_files/libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.js"></script>
<link href="ConfBand_files/libs/quarto-contrib/pseudocode-2.4.1/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>
<meta name="quarto:status" content="draft">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Should we correct the bias in Confidence Bands for Repeated Functional Data?</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://lig-aptikal.imag.fr/~devijvee/">Emilie Devijver</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  CNRS, Univ. Grenoble Alpes, Grenoble INP, LIG, 38000 Grenoble, France
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://adeline.e-samson.org">Adeline Samson</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  Univ. Grenoble Alpes, CNRS, Grenoble INP, LJK, 38000 Grenoble, France
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 8, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">December 8, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">functional data, repeated data, confidence band, Kac-Rice formulae, bias, dimension selection</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>While confidence intervals for finite quantities are well-established, constructing confidence bands for objects of infinite dimension, such as functions, poses challenges. In this paper, we explore the concept of parametric confidence bands for functional data with an orthonormal basis. Specifically, we revisit the method proposed by Sun and Loader, which yields confidence bands for the projection of the regression function in a fixed-dimensional space. This approach can introduce bias in the confidence bands when the dimension of the basis is misspecified. Leveraging this insight, we introduce a corrected, unbiased confidence band. Surprisingly, our corrected band tends to be wider than what a naive approach would suggest. To address this, we propose a model selection criterion that allows for data-driven estimation of the basis dimension. The bias is then automatically corrected after dimension selection. We illustrate these strategies using an extensive simulation study. We conclude with an application to real data.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-model" id="toc-sec-model" class="nav-link" data-scroll-target="#sec-model"><span class="header-section-number">2</span> Statistical Model</a>
  <ul class="collapse">
  <li><a href="#sec-functional_model" id="toc-sec-functional_model" class="nav-link" data-scroll-target="#sec-functional_model"><span class="header-section-number">2.1</span> Functional regression model</a></li>
  <li><a href="#sec-projection_model" id="toc-sec-projection_model" class="nav-link" data-scroll-target="#sec-projection_model"><span class="header-section-number">2.2</span> Approximation of the model on a finite family</a></li>
  <li><a href="#sec-estim" id="toc-sec-estim" class="nav-link" data-scroll-target="#sec-estim"><span class="header-section-number">2.3</span> Estimator</a>
  <ul class="collapse">
  <li><a href="#estimation-of-the-regression-function" id="toc-estimation-of-the-regression-function" class="nav-link" data-scroll-target="#estimation-of-the-regression-function"><span class="header-section-number">2.3.1</span> Estimation of the regression function</a></li>
  <li><a href="#statistics" id="toc-statistics" class="nav-link" data-scroll-target="#statistics"><span class="header-section-number">2.3.2</span> Statistics</a></li>
  <li><a href="#bias" id="toc-bias" class="nav-link" data-scroll-target="#bias"><span class="header-section-number">2.3.3</span> Bias</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-bandSun" id="toc-sec-bandSun" class="nav-link" data-scroll-target="#sec-bandSun"><span class="header-section-number">3</span> Confidence Bands of <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span> for a fixed <span class="math inline">L</span></a>
  <ul class="collapse">
  <li><a href="#sec-bandSun2" id="toc-sec-bandSun2" class="nav-link" data-scroll-target="#sec-bandSun2"><span class="header-section-number">3.1</span> Confidence band for <span class="math inline">\underline{f}^{L,L^*}</span></a></li>
  <li><a href="#sec-bandfLLstar" id="toc-sec-bandfLLstar" class="nav-link" data-scroll-target="#sec-bandfLLstar"><span class="header-section-number">3.2</span> Asymptotic confidence band for <span class="math inline">f^{L,L^*}</span></a></li>
  </ul></li>
  <li><a href="#sec-band2" id="toc-sec-band2" class="nav-link" data-scroll-target="#sec-band2"><span class="header-section-number">4</span> Confidence Band of <span class="math inline">f^{L^*}</span> by correcting the bias</a>
  <ul class="collapse">
  <li><a href="#sec-construction2" id="toc-sec-construction2" class="nav-link" data-scroll-target="#sec-construction2"><span class="header-section-number">4.1</span> Construction of the band of <span class="math inline">f^{L^*}</span> for a given <span class="math inline">L</span></a></li>
  <li><a href="#sec-SelectionL2" id="toc-sec-SelectionL2" class="nav-link" data-scroll-target="#sec-SelectionL2"><span class="header-section-number">4.2</span> Influence of <span class="math inline">L</span></a></li>
  </ul></li>
  <li><a href="#sec-modsel" id="toc-sec-modsel" class="nav-link" data-scroll-target="#sec-modsel"><span class="header-section-number">5</span> Selection of the best confidence band with a criteria taking into account the bias</a></li>
  <li><a href="#sec-simulation" id="toc-sec-simulation" class="nav-link" data-scroll-target="#sec-simulation"><span class="header-section-number">6</span> <span style="color: red;"> Simulation study</span></a>
  <ul class="collapse">
  <li><a href="#sec-dgp" id="toc-sec-dgp" class="nav-link" data-scroll-target="#sec-dgp"><span class="header-section-number">6.1</span> Generating data process</a></li>
  <li><a href="#sec-simu-band" id="toc-sec-simu-band" class="nav-link" data-scroll-target="#sec-simu-band"><span class="header-section-number">6.2</span> Confidence band for a fixed level</a></li>
  <li><a href="#sec-simudebias" id="toc-sec-simudebias" class="nav-link" data-scroll-target="#sec-simudebias"><span class="header-section-number">6.3</span> Confidence bands by correcting the bias</a></li>
  <li><a href="#sec-simumodsel" id="toc-sec-simumodsel" class="nav-link" data-scroll-target="#sec-simumodsel"><span class="header-section-number">6.4</span> Model selection criterion</a></li>
  <li><a href="#sec-gen" id="toc-sec-gen" class="nav-link" data-scroll-target="#sec-gen"><span class="header-section-number">6.5</span> Generalization out of the model</a></li>
  </ul></li>
  <li><a href="#sec-realdata" id="toc-sec-realdata" class="nav-link" data-scroll-target="#sec-realdata"><span class="header-section-number">7</span> Real data analysis</a></li>
  <li><a href="#sec-conc" id="toc-sec-conc" class="nav-link" data-scroll-target="#sec-conc"><span class="header-section-number">8</span> Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#appendix-proofs" id="toc-appendix-proofs" class="nav-link" data-scroll-target="#appendix-proofs"><span class="header-section-number">9</span> Appendix: proofs</a>
  <ul class="collapse">
  <li><a href="#proof-of-prp-error" id="toc-proof-of-prp-error" class="nav-link" data-scroll-target="#proof-of-prp-error"><span class="header-section-number">9.1</span> Proof of Proposition&nbsp;3</a></li>
  <li><a href="#proof-of-thm-cb_liebl_asymptotic" id="toc-proof-of-thm-cb_liebl_asymptotic" class="nav-link" data-scroll-target="#proof-of-thm-cb_liebl_asymptotic"><span class="header-section-number">9.2</span> Proof of Theorem&nbsp;2</a></li>
  <li><a href="#proof-of-prp-cbf" id="toc-proof-of-prp-cbf" class="nav-link" data-scroll-target="#proof-of-prp-cbf"><span class="header-section-number">9.3</span> Proof of Proposition&nbsp;5</a></li>
  </ul></li>
  <li><a href="#appendix-more-experiments" id="toc-appendix-more-experiments" class="nav-link" data-scroll-target="#appendix-more-experiments"><span class="header-section-number">10</span> Appendix: more experiments</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ConfBand.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>colorize <span class="ot">&lt;-</span> <span class="cf">function</span>(x, color) {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> (knitr<span class="sc">::</span><span class="fu">is_latex_output</span>()) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a> <span class="fu">sprintf</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">textcolor{%s}{%s}"</span>, color, x)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a> } <span class="cf">else</span> <span class="cf">if</span> (knitr<span class="sc">::</span><span class="fu">is_html_output</span>()) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a> <span class="fu">sprintf</span>(<span class="st">"&lt;span style='color: %s;'&gt;%s&lt;/span&gt;"</span>, color,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> x)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a> } <span class="cf">else</span> x</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Functional data analysis is widely used for handling complex data with smooth shapes, finding applications in diverse fields such as neuroscience (e.g., EEG data, <span class="citation" data-cites="Zhang2020">Zhang (<a href="#ref-Zhang2020" role="doc-biblioref">2020</a>)</span>), psychology (e.g., mouse-tracking data, <span class="citation" data-cites="Quinton-2017-escon">Quinton et al. (<a href="#ref-Quinton-2017-escon" role="doc-biblioref">2017</a>)</span>), and sensor data from daily-life activities (<span class="citation" data-cites="jacques2022">Jacques and Samardžić (<a href="#ref-jacques2022" role="doc-biblioref">2022</a>)</span>).</p>
<p>We consider <span style="color: red;">several</span> <!-- multiple --> independent observations of the same function, <span style="color: red;">i.e.</span> <!-- yielding--> noisy functional data. To analyze <span style="color: red;">this</span> <!-- such--> data, a <span style="color: red;">classic</span><!-- common --> approach <!-- , typically in the parametric setting,--> involves projecting the data onto a functional space defined by a family of functions (<span class="citation" data-cites="LI2022104806">Li, Qiu, and Xu (<a href="#ref-LI2022104806" role="doc-biblioref">2022</a>)</span>, <span class="citation" data-cites="kokoszka2017introduction">Kokoszka and Reimherr (<a href="#ref-kokoszka2017introduction" role="doc-biblioref">2017</a>)</span> Chapter 3). When the family <span style="color: red;">is</span> an orthonormal basis, e.g., <span style="color: red;">the</span> Legendre <span style="color: red;">basis</span> (with the standard scalar product) or Fourier (with another scalar product), the projection is <span style="color: red;">explicit and it is possible to obtain theoretical results.</span> <!-- clearly understood. !--> <span style="color: red;">However, some families, such as splines, are not orthonormal for the standard scalar product.</span> <!--But families such as splines are not orthonormal for the standard scalar product !--> <span style="color: red;">We will discuss the impact of the choice of this family on estimation. We explain why the use of a </span> <!-- leveraging an approximate !--> functional space offers a key advantage: it <span style="color: red;">reduces the problem of inference to the estimation of</span> <!--simplifies the inference problem to estimating!--> coefficients, for example <span style="color: red;">by</span> <!--through methods like!--> least squares or maximum likelihood estimation. <span style="color: red;">The function estimator is then simply an average after projection onto the functional base.</span> <!--Subsequently, the function is estimated as the mean of the functional data following projection onto the functional basis.!--> <span style="color: red;">It is important to accompany the function estimate with a measure of the uncertainty of that estimate, usually</span> <!-- Measuring the uncertainty of an estimator is usually done! --> using confidence intervals <span style="color: red;">or bands</span>. In this paper, <span style="color: red;">we focus on constructing</span> <!--our focus lies specifically on providing!--> a simultaneous confidence band for the <span style="color: red;">mean of the</span> function<!-- means !-->, rather than point-wise confidence intervals. This task presents several challenges: the confidence band must effectively control the simultaneous functional type-I error rate, as opposed to point-wise rates; it must strike a balance between being sufficiently conservative to maintain a confidence level while not being overly so as to render it meaningless; and the method used to construct this confidence band should be computationally feasible for practical application.</p>
<p>Several developments have already been proposed to answer these questions. First, <span style="color: red;">let us</span> consider the case <span style="color: red;">of a single</span> <!--with only one!--> individual (no repetition) but with many time points. Some methods study the asymptotic distribution of the infinity norm between the true function and its estimator. The asymptotics in the number of time points is studied in <span class="citation" data-cites="Hall1991">Hall (<a href="#ref-Hall1991" role="doc-biblioref">1991</a>)</span>, <span class="citation" data-cites="Claeskens2003">Claeskens and Van Keilegom (<a href="#ref-Claeskens2003" role="doc-biblioref">2003</a>)</span>. This approach only works for large datasets in time and is likely to be too conservative otherwise. For small samples, bootstrap methods have been developed to compute the confidence band (<span class="citation" data-cites="Neumann1998">Neumann and Polzehl (<a href="#ref-Neumann1998" role="doc-biblioref">1998</a>)</span>, <span class="citation" data-cites="Claeskens2003">Claeskens and Van Keilegom (<a href="#ref-Claeskens2003" role="doc-biblioref">2003</a>)</span>), but with a high computational cost. Another approach is to construct confidence bands based on the volume of the tube formula. <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> studied the tail probabilities of suprema of Gaussian random processes. This approach is based on an unbiased linear estimator of the regression function. <span class="citation" data-cites="Zhou1998">Zhou, Shen, and Wolfe (<a href="#ref-Zhou1998" role="doc-biblioref">1998</a>)</span> used the volume-of-tube formula for estimation by regression splines. <span class="citation" data-cites="Krivobokova2010">Krivobokova, Kneib, and Claeskens (<a href="#ref-Krivobokova2010" role="doc-biblioref">2010</a>)</span> used this method for the construction of confidence bands by penalized spline estimators. They proposed to mix Bayesian and frequentist approaches, <span style="color: red;">in order to obtain</span> <!--to get!--> the good properties <span style="color: red;">of</span> <!--from!--> the Bayesian world <span style="color: red;">while</span> <!--but!--> reducing the variability to be less conservative using the frequentist approach. The bias is <span style="color: red;">taken into account by</span> <!--considered through!--> spline modeling, assuming <span style="color: red;">that enough</span> <!--sufficient!--> knots are considered.</p>
<p>Some papers, like ours, rely on several observations of the same function. <span class="citation" data-cites="Liebl2019">Liebl and Reimherr (<a href="#ref-Liebl2019" role="doc-biblioref">2023</a>)</span> <!--have!--> proposed a method based <span style="color: red;">on the Kac-rice formula, </span> random field theory and the volume-of-tube formula. They provide a band with locally varying widths using an unbiased estimator. Their method does not require <!--the!--> estimation of the full covariance function of the estimator, but only its diagonal. This reduces the computational time. From a practical viewpoint, <span class="citation" data-cites="CB_survivalAnalysis2022">Sachs, Brand, and Gabriel (<a href="#ref-CB_survivalAnalysis2022" role="doc-biblioref">2022</a>)</span> introduced a package to popularize simultaneous confidence bands, in the context of survival analysis. <span class="citation" data-cites="bunea2011">Bunea, Ivanescu, and Wegkamp (<a href="#ref-bunea2011" role="doc-biblioref">2011</a>)</span> propose a threshold-type estimator and derive error bounds and simultaneous confidence bands, having an unbiased estimator. <span class="citation" data-cites="TELSCHOW202270">Telschow and Schwartzman (<a href="#ref-TELSCHOW202270" role="doc-biblioref">2022</a>)</span> propose a simultaneous confidence band based on the Gaussian kinematic formula. Again, it assumes access to an <span style="color: red;">asymptotically</span> unbiased estimator of the function of interest. <span style="color: red;">The coverage will thus be guaranteed in the asymptotic setting after removing the bias, by smoothing the data for example. Their paper considers the non-gaussian and non-stationary cases.</span> <span class="citation" data-cites="wang2022">Wang (<a href="#ref-wang2022" role="doc-biblioref">2022</a>)</span> proposed a simultaneous Kolmogorov-Smirnov confidence band by modeling the error distribution, thus avoiding the estimation of the covariance structure of the underlying stochastic process. They rely on B-splines for the estimation of the mean curve. Note that recent extensions have been proposed, <span style="color: red;">based on Lipschitz-Killing-Curvatures estimators</span> <!--to nonstationary random field !--> in <span class="citation" data-cites="Telschow2023">Telschow et al. (<a href="#ref-Telschow2023" role="doc-biblioref">2023</a>)</span>, based on conformal prediction in <span class="citation" data-cites="conformalPrediction2022">Diquigiovanni, Fontana, and Vantini (<a href="#ref-conformalPrediction2022" role="doc-biblioref">2022</a>)</span>, or having a prediction goal in mind in <span class="citation" data-cites="Jacques2023">Hernández, Cugliari, and Jacques (<a href="#ref-Jacques2023" role="doc-biblioref">2024</a>)</span> by considering functional time series data set. <!-- These extensions are out of the scope of this paper, focusing on the simple functional case. !--></p>
<p>One limitation of all those approaches is that they do not <!-- generally !--> <span style="color: red;">clearly</span> take into account the bias of the functional estimator. <span style="color: red;">Taking account of bias is particularly important when working in a non-asymptotic context.</span> <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> proposed a bias correction for a particular class of functions but left the smoothing parameter choice open, leading to an unusable estimator. In the nonparametric framework, the bias is approximated using the estimator of the second derivative of the underlying mean function (<span class="citation" data-cites="Xia1998">Xia (<a href="#ref-Xia1998" role="doc-biblioref">1998</a>)</span>). But in general, there is a lack of discussion on how to handle the bias of the functional estimator, even in the simple case of a functional space of finite dimension.</p>
<p><span style="color: red;">Another issue is the selection of the dimension of the basis. Hard-thresholding approaches, cross-validation methods</span> (<span class="citation" data-cites="LI2022104806">Li, Qiu, and Xu (<a href="#ref-LI2022104806" role="doc-biblioref">2022</a>)</span>) <span style="color: red;">or model selection framework could be used to select the best dimension.</span> <span style="color: red;">However, these approaches need to be adapted to the specific case of controlling the level of a confidence band. Few references exist on this subject. For example, while the model selection paradigm has been extensively studied in the literature, in multivariate statistics or functional data analysis (e.g.,</span> <span class="citation" data-cites="GoeppSubmitted">Goepp, Bouaziz, and Nuel (<a href="#ref-GoeppSubmitted" role="doc-biblioref">2025</a>)</span>, <span class="citation" data-cites="ANEIROS2022104871">Aneiros, Novo, and Vieu (<a href="#ref-ANEIROS2022104871" role="doc-biblioref">2022</a>)</span>, <span class="citation" data-cites="BASNA2022104868">Basna, Nassar, and Podgórski (<a href="#ref-BASNA2022104868" role="doc-biblioref">2022</a>)</span>), <span style="color: red;">it has not been explored in the context of confidence band construction.</span></p>
<p>The objective of this paper is to address the bias problem in confidence band construction for a general function, <span style="color: red;">in the non-asymptotic setting</span>, utilizing a finite functional orthonormal family <span style="color: red;">and to select the best band.</span> Our contributions are as follows:</p>
<ul>
<li>we disentangle the bias issue by explicitly defining the parameter of interest within the approach of <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span>;</li>
<li>we propose a bias correction method in a new confidence band for the function of interest. <span style="color: red;">This provides a collection of debiased confidence bands. We also propose a criteria to select the best band, by splitting the sample into two sub-samples</span></li>
<li><!-- Finally !-->
<span style="color: red;">to avoid the loss of precision due to sample splitting,</span> we propose a second heuristic method for selecting the dimension of the approximation space, treating it as a model selection problem, with a trade-off between conservatism and confidence level assurance; <span style="color: red;">this approach does not correct the bias of each band of the collection but selects a band with a negligible bias;</span></li>
<li>we illustrate <!-- this confidence band, concluding on the conservatism of the procedure !--> <span style="color: red;">the proposed strategies and compare them to cross-validation or threshold approaches</span>;</li>
<li><span style="color: red;">we also illustrate the impact of the choice of the functional family, including non-orthonormal families.</span></li>
</ul>
<p>The paper is organized as follows: <a href="#sec-model" class="quarto-xref">Section&nbsp;2</a> introduces the functional regression model, the considered functional family and the corresponding approximate regression models, as well as an estimator defined in the finite space, along with descriptions of the error terms. In <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>, we propose a confidence band for the approximate regression function in the space of finite dimension, where the dimension is fixed. <a href="#sec-band2" class="quarto-xref">Section&nbsp;4</a> proposes a strategy to construct a confidence band for the true function. This last confidence band being too conservative, <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a> introduces a model selection criterion to select the best confidence band, doing a trade-off between conservatism and confidence level assurance. <a href="#sec-simulation" class="quarto-xref">Section&nbsp;6</a> <span style="color: red;"> illustrates the different estimating procedures of the confidence band.</span> <a href="#sec-realdata" class="quarto-xref">Section&nbsp;7</a> <span style="color: red;"> proposes an application on real data.</span> <a href="#sec-conc" class="quarto-xref">Section&nbsp;8</a> ends the paper by a conclusion and discussion of perspectives. <!--The different estimation procedures are illustrated throughout the sections. !--></p>
</section>
<section id="sec-model" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Statistical Model</h1>
<p>In this paper, we consider time series as discrete measurements of functional curves. We first present the general functional regression model (<a href="#sec-functional_model" class="quarto-xref">Section&nbsp;2.1</a>) where the regression function belongs to a finite functional family of dimension <span class="math inline">L^*</span>. In practice, this dimension <span class="math inline">L^*</span> is unknown and we will work on functional space of dimension <span class="math inline">L</span>. The regression model on the finite family of functions is presented in <a href="#sec-projection_model" class="quarto-xref">Section&nbsp;2.2</a>, and an estimator is proposed in <a href="#sec-estim" class="quarto-xref">Section&nbsp;2.3</a>, with a description of the error terms.</p>
<p><span style="color: red;"> In the rest of the paper, we consider the space </span> <span class="math inline">L^2([0,1])</span> with its standard scalar product <span class="math inline">&lt;f_1,f_2&gt; = \int_0^1 |f_1(t)f_2(t)|dt</span>, for <span class="math inline">f_1,f_2 \in L^2([0,1])</span>. The notation <span class="math inline">Vect</span> denotes the linear span.</p>
<section id="sec-functional_model" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-functional_model"><span class="header-section-number">2.1</span> Functional regression model</h2>
<p>Let <span class="math inline">y_{ij}</span> be the measure at fixed time <span class="math inline">t_{j} \in [a,b]</span> for individual <span class="math inline">i=1, \ldots, N</span>, with <span class="math inline">j=1, \ldots, n</span>. <span style="color: red;">The case with time observations dependent of the individuals is a natural extension of this case, but introduces a bias through the interpolation that is not easy to take into account. </span> We restrict ourselves to <span class="math inline">[a,b] = [0,1]</span>, without loss of generality. We assume these observations are discrete-time measurements of individual curves, which are independent and noisy realisations of a common function <span class="math inline">f</span> that belongs to a functional space. Thus for each individual <span class="math inline">i</span>, we consider the following functional regression model <span class="math display">\begin{equation*}
y_{ij} = f(t_{j}) + \varepsilon_{ij},
\end{equation*}</span> where <span class="math inline">\varepsilon_{i.}=(\varepsilon_{i1}, \ldots, \varepsilon_{in})</span> is the <span style="color: red;">measurement</span> noise <!-- representing the individual functional variation around $f$.
We !-->assuming that the <span class="math inline">\varepsilon_{i}</span> are independent. <!-- Their distribution is detailed below. !--></p>
<p>For each individual <span class="math inline">i=1, \ldots, N</span>, we denote <span class="math inline">y_{i.}=(y_{i1}, \ldots, y_{in})</span> <!-- the $n\times 1$ vector of observations !-->, <span class="math inline">t_{.}=(t_{1}, \ldots, t_{n})</span> <!-- the $n \times 1$ vector of observation times !--> and <span class="math inline">f(t_{.})=(f(t_{1}), \ldots, f(t_{n}))</span> the <span class="math inline">n \times 1</span> vectors of the <span style="color: red;"> observations, times and </span> function <span class="math inline">f</span> evaluated in <span class="math inline">t_{.}</span>, respectively. We also denote <span class="math inline">\mathbf{y} = (y_{1.}, \ldots, y_{N.})</span> the whole matrix of observations.</p>
<p>Let us introduce the functional space <span class="math inline">\mathcal{S}^{L^*} = Vect((t \mapsto B_\ell^{L^*}(t))_{1\leq \ell \leq L^*})</span> with <span class="math inline">L^*</span> functions <span class="math inline">(B_\ell^{L^*})_{1\leq \ell \leq L^*}</span> assumed to be linearly independent. Then, for any <span class="math inline">f \in \mathcal{S}^{L^*}</span>, there exists a unique vector of coefficients <span class="math inline">(\mu_{\ell}^{L^*})_{1\leq \ell \leq L^*}</span> such that, for all <span class="math inline">t</span>, <span class="math inline">f(t) = \sum_{\ell =1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t)</span>. The regression function <span class="math inline">f</span> verifies the following assumption:</p>
<p><strong><em>Assumption 1.</em></strong> The function <span class="math inline">f</span> belongs to the space <span class="math inline">\mathcal{S}^{L^*}</span> of dimension <span class="math inline">L^*</span>. It is denoted <span class="math inline">{f}^{L^*}</span> and defined as: <span class="math display">f(t) = {f}^{L^*}(t) = \sum_{\ell = 1}^{L^*} \mu_\ell^{L^*} B^{L^*}_\ell(t). </span></p>
<p>Many functional spaces are available in the literature, as Splines, Fourier or Legendre families. We introduce the following assumption:</p>
<p><strong><em>Assumption 2.</em></strong> The functional family <span class="math inline">(t \mapsto B^{L^*}_\ell(t))_{1\leq \ell\leq L^*}</span> is orthonormal with respect to the standard scalar product <span class="math inline">&lt;.,.&gt;</span>.</p>
<p>Note that if Assumption 2 holds, one get <span class="math inline">\mu_\ell^{L^*} = &lt;{f}^{L^*},B^{L^*}_\ell&gt;</span> for <span class="math inline">\ell = 1,\ldots, L^*</span>. The Legendre family is orthonormal, the Fourier family is orthogonal for the standard scalar product (but not orthonormal), and the B-splines family is not orthogonal. <span style="color: red;"> We will illustrate the impact of using one family or the other.</span></p>
<p>We also consider a functional noise through the following assumption.</p>
<p><strong><em>Assumption 3.</em></strong> The sequence <span class="math inline">\varepsilon_{i}</span> is functional and <span style="color: red;"> allows Karhunen-Loève <span class="math inline">L^2</span> representation:</span> there exists a sequence of coefficients <span class="math inline">(c_{i\ell})_{1\leq \ell}</span> such that <span class="math display">\varepsilon_{ij} = \sum_{\ell \geq 1} c_{i\ell} \phi_\ell(t_{j}),</span> <span style="color: red;">where the functions</span> <span class="math inline">(\phi_\ell)_{1\leq L}</span> <span style="color: red;"> can be written through eigenvalues and eigenfunctions of the covariance matrix </span> <span class="math inline">cov(\varepsilon_{ij}, \varepsilon_{ij'})</span>. <span style="color: red;">Practically, we assume this sum to be finite, as done for example in </span> <span class="citation" data-cites="Chen2015">Chen and Song (<a href="#ref-Chen2015" role="doc-biblioref">2015</a>)</span>: there exists <span class="math inline">L^\varepsilon</span> such that <span class="math display">\varepsilon_{ij} = \sum_{1 \leq L \leq L^\varepsilon} c_{i\ell} \phi_\ell(t_{j}),</span></p>
<p>We also assume that the coefficients are Gaussian: for all <span class="math inline">i=1,\ldots, N</span> and <span class="math inline">\ell=1, \ldots, L^\varepsilon</span>, <span class="math display">c_{i \ell} \sim_{iid} \mathcal{N}(0,\sigma^2).</span></p>
<p>Assumption 1 and Assumption 3 imply that each curve <span class="math inline">y_i</span> belongs to a finite family: for <span class="math inline">j=1,\ldots,n</span>, <span class="math display"> y_{ij} = \sum_{\ell=1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t_{j}) + \sum_{\ell=1}^{L^\varepsilon} c_{i\ell} \phi_\ell(t_{j}). </span></p>
<p>As the observations are recorded at discrete time points <span class="math inline">(t_j)_{1\leq j \leq n}</span>, <!--we introduce the family of functions evaluated at the discrete times of observations. For!--> for <span class="math inline">L\in \mathbb{N}</span>, let us denote <span class="math inline">\mathbf{B}^L</span> the matrix of <span class="math inline">n\times L</span> with coefficient in row <span class="math inline">j</span> and column <span class="math inline">\ell</span> equal to <span class="math inline">B^L_\ell(t_{j})</span>, <span style="color: red;">and the basis for the noise</span> <span class="math inline">\Phi^{L^\varepsilon} = (\phi_\ell(t_j))_{1\leq \ell \leq L^\varepsilon, 1\leq j \leq n}</span>. Let us introduce <span class="math inline">c_{i.}=(c_{i1}, \ldots, c_{iL^\varepsilon})</span> the <span class="math inline">L^\varepsilon \times 1</span> vector. Then <span class="math inline">\varepsilon_{i.} = \Phi^{L^\varepsilon} c_{i.}</span>. The vectors <span class="math inline">y_{i.} \in \mathbb{R}^n</span> are thus independent and <span class="math inline">y_i\sim \mathcal{N}_n(f(t_{.}), \sigma^2 \Sigma^{L^\varepsilon})</span> with <span class="math inline">\Sigma^{L^\varepsilon} = \Phi^{L^\varepsilon} (\Phi^{L^\varepsilon})^T</span>.</p>
<p>The objective of this paper is to construct a tight confidence bound for <span class="math inline">f^{L^*}</span> using data <span class="math inline">(y_{ij})_{ij}</span>. The main challenge is that the true dimension <span class="math inline">L^*</span> is unknown. In the rest of the paper, we will work with a collection of models defined on a finite family of dimension <span class="math inline">L</span> with <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span>, <span class="math inline">L_{\max}</span> being chosen to be sufficiently large by the user, expecting that <span class="math inline">L^*\leq L_{\max}</span>. <span class="math inline">L_{\max}</span> <span style="color: red;">has to be large enough to do overfitting.</span> Then we will propose different strategies to choose the best bandwidth among the different collections.</p>
<p>First, in <a href="#sec-projection_model" class="quarto-xref">Section&nbsp;2.2</a> and <a href="#sec-estim" class="quarto-xref">Section&nbsp;2.3</a>, we define for a fixed <span class="math inline">L</span> the corresponding regression model and its estimator. Then <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>, <a href="#sec-band2" class="quarto-xref">Section&nbsp;4</a> and <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a> will introduce the different bandwidths.</p>
</section>
<section id="sec-projection_model" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-projection_model"><span class="header-section-number">2.2</span> Approximation of the model on a finite family</h2>
<p>Let <span class="math inline">f^{L^*} \in \mathcal{S}^{L^*}</span> with <span class="math inline">L^*</span> unknown, and consider the space <span class="math inline">\mathcal{S}^L</span> for <span class="math inline">L</span> fixed in <span class="math inline">\{L_{\min}, \ldots, L_{\max}\}</span>. As <span class="math inline">\mathcal{S}^L</span> is a family of linearly independent functions, there <span style="color: red;">is</span> always <!--exists!--> a unique vector <span class="math inline">\mu^{L,L^*}</span> of coefficients defining <span class="math inline">f^{L,L^*}(t) = \sum_{\ell_=1}^L \mu_\ell^{L,L^*} B_\ell^L(t)=B^L(t) \mu^{L,L^*}</span> such that <span class="math display">f^{L,L^*} = \arg\min_{f \in \mathcal{S}^L}\{\|f^{L^*} - f\|_2^2\}.</span> <!--and if !--> <span style="color: red;">If</span> the family is orthonormal<!--(Assumption 2)!-->, it corresponds to the projected coefficients <span class="math inline">\mu_{\ell}^{L,L^*}</span>: <span class="math display">\mu_{\ell}^{L,L^*} :=&lt;f^{L^*}, B_\ell^L&gt;.</span></p>
<p>We can prove the following property:</p>
<div id="prp-proj" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1</strong></span> Under Assumption 1, <span class="math display">f^{L^*,L^*} = f^{L^*}.</span> Moreover, if Assumption 2 also holds, the projection coefficients verify <span class="math display">\mu_{\ell}^{L,L^*} = \mu_\ell^{L^*} \quad{ for }\; \ell =1, \ldots, \min(L, L^{*}).</span></p>
</div>
<p>In practice, data are observed at discrete time, we consider the operator <span class="math inline">\mathbf{P}^L</span> defined as the matrix <span class="math inline">\mathbf{P}^L = ((\mathbf{B}^L)^T \mathbf{B}^L)^{-1} (\mathbf{B}^L)^T</span> of size <span class="math inline">L\times n</span>. <span style="color: red;">This coincides with the orthogonal projection when we deal with an orthonormal basis, but it is also consistent for non orthonormal family, coming back to the least square estimator on a specified family.</span> <!--(this operator is a bit more complex when the functional family is not orthonormal wrt the standard scalar product). !--> Then we define the coefficients <span class="math inline">\underline{\mu}^{L,L^*}</span> which are the coefficients of <span class="math inline">{\mu}^{L,L^*}</span> approximated on the vector space, denoted <span class="math inline">\mathbf{S}^L</span>, defined by the matrix <span class="math inline">\mathbf{B}^L</span>. <span class="math display">\underline{\mu}^{L,L^*} := \mathbf{P}^L \mathbf{B}^{L^*}\mu^{L^*}.</span></p>
<p>The corresponding finite approximated regression function is denoted <span class="math inline">\underline{f}^{L,L^*}</span> and is defined, for all <span class="math inline">t\in [0,1]</span>, as <span class="math display">\underline{f}^{L,L^*}(t) = B^L(t) \underline{\mu}^{L,L^*}.</span></p>
<p>We can prove the following properties linking <span class="math inline">L, L^*</span> and the number of timepoints <span class="math inline">n</span>:</p>
<div id="prp-proj2" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2</strong></span> Under Assumption 1 and Assumption 2, <span style="color: red;">the diagonal elements of </span> <span class="math inline">\mathbf{P}^L \mathbf{B}^{L^*}</span> <span style="color: red;">are such that for</span> <span class="math inline">\ell=1, \ldots, \min(L, L^*),</span> <span class="math display">[\mathbf{P}^L \mathbf{B}^{L^*}]_{\ell\ell}=1.</span></p>
<ul>
<li>When <span class="math inline">L\geq L^*</span>, <!--$\mathbf{P}^L \mathbf{B}^{L^*}$ has $L^*$ diagonal elements equal to 1 and other non-diagonal elements close to 0.!--> <span style="color: red;">when <span class="math inline">n&gt;L</span>, we have</span> for <span class="math inline">\ell=1, \ldots, L^*</span>,</li>
</ul>
<p><span class="math display"> \underline{\mu}^{L,L^*}_\ell = \mu^{L^*}_\ell.</span></p>
<!--The first $L^*$ elements of $\underline{\mu}^{L,L^*}$ are equal to $\mu^{L^*}$ when $n>L$.!-->
<ul>
<li>When <span class="math inline">L&lt;L^*</span>, <!--$\mathbf{P}^L\mathbf{B}^{L^*}$ has $L$ diagonal elements equal to 1.!--> <span style="color: red;">for</span> <span class="math inline">\ell =1, \ldots, L</span>, <span class="math display">\underline{\mu}^{L,L^*}_\ell \neq \mu^{L^*}_\ell.</span></li>
</ul>
<!-- The first $L$ elements of $\underline{\mu}^{L,L^*}$ are different to $\mu_\ell^{L^*}$.!-->
<ul>
<li>When <span class="math inline">n\rightarrow\infty</span>, <span style="color: red;">for</span> <span class="math inline">\ell = 1,\ldots, L</span> <span class="math display">\underline{\mu}_\ell^{L,L^*}\rightarrow \mu_\ell^{L^*}. </span></li>
<li>If <span class="math inline">n&gt;L^*</span>, then <span class="math inline">f^{L^*} = f^{L^*,L^*} = \underline{f}^{L^*,L^*}</span>.</li>
</ul>
</div>
</section>
<section id="sec-estim" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-estim"><span class="header-section-number">2.3</span> Estimator</h2>
<p>Let <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span>. This section presents the least square estimator of the regression function on the space of dimension <span class="math inline">L</span> defined by the family <span class="math inline">\mathbf{B}^L</span> and discusses its error.</p>
<section id="estimation-of-the-regression-function" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="estimation-of-the-regression-function"><span class="header-section-number">2.3.1</span> Estimation of the regression function</h3>
<p>When considering the estimation of the regression function <span class="math inline">f^{L^*}</span> on the space of dimension <span class="math inline">L</span> defined by the family <span class="math inline">\mathbf{B}^L</span>, we do not directly estimate <span class="math inline">f^{L^*}</span> but its projection on this finite space, which corresponds to the projected function <span class="math inline">\underline{f}^{L,L^*}(t)</span> and its associated coefficients <span class="math inline">(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}</span>.</p>
<div id="def-proj2" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1</strong></span> The vector of coefficients <span class="math inline">(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}</span> is estimated by the least square estimator <span class="math inline">\hat{\underline{\mu}}^{L, L^*}</span> defined as: <span class="math display">\begin{align*}
\hat{\underline{\mu}}^{L, L^*}:=\frac1N \sum_{i=1}^N
\mathbf{P}^L y_{i.}.
\end{align*}</span></p>
<p>For a fixed <span class="math inline">t \in [0,1]</span>, the estimator of the function <span class="math inline">\underline{f}^{L,L^*}(t)</span> is defined by:</p>
<p><span id="eq-fhatL"><span class="math display"> \underline{\hat{f}_{}}^{L,L^*}(t) = \sum_{\ell=1}^L \underline{\hat \mu}_\ell^{L,L^*} B^L_\ell(t)= B^L(t)\hat{\underline{\mu}}^{L,L^*}.
\tag{1}</span></span></p>
</div>
<p><a href="#eq-fhatL" class="quarto-xref">Equation&nbsp;1</a> directly implies that the estimator is thus the empirical mean of the functional approximation of each individual vector of observations. Because we work with least squares estimators, we can easily study the error of estimation of <span class="math inline">\hat{\underline{\mu}}^{L, L^*}</span> and <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span>.</p>
<div id="prp-error" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3</strong></span> Under Assumption 1 and Assumption 3, we have <span class="math display">\begin{align*}
\hat{\underline{\mu}}^{L, L^*}
&amp;\sim \mathcal{N}_L\left(\underline{\mu}^{L, L^*}, \frac{\sigma^2}N\Sigma_{B}^{L,L^\varepsilon}
\right),
\end{align*}</span> where the <span class="math inline">L\times L</span> covariance matrix <span class="math inline">\Sigma_{B}^{L,L^{\varepsilon}}</span> is defined as <span class="math inline">\Sigma_{B}^{L,L^\varepsilon}:=\mathbf{P}^L \Sigma^{L^\varepsilon} (\mathbf{P}^L)^T</span> with <span class="math inline">\Sigma^{L^\varepsilon}= \Phi^{L^\varepsilon} (\Phi^{L^\varepsilon})^T</span>.</p>
<p>Moreover, <span class="math inline">B^L()\mathbf{P}^L y_i</span> is a Gaussian process with mean <span class="math inline">\underline{f}^{L,L^*}()</span> and covariance function <span class="math inline">(s,t) \mapsto \sigma^2 B^L(s) \Sigma_{B}^{L,L^\varepsilon} (B^L(t))^T</span>, and <span class="math inline">(\underline{\hat{f}_{}}^{L,L^*}- \underline{f}^{L,L^*})()</span> is a centered Gaussian process with covariance function <span class="math inline">C^{L,L^*}: (s,t) \mapsto \frac{\sigma^2}N B^L(s) \Sigma_{B}^{L,L^\varepsilon} B^L(t)^T</span>.</p>
</div>
<p>The proof is given in Appendix.</p>
<p>Even if the estimator <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span> is defined on the functional space associated to <span class="math inline">\mathbf{S}^L</span>, it can also be seen as an estimator of the function <span class="math inline">f^{ L^*}</span> which lies in the space <span class="math inline">\mathcal{S}^{L^*}</span>. In that case, the error includes a functional approximation term due to the approximation of <span class="math inline">f^{ L^*}</span> on the space <span class="math inline">\mathcal{S}^L</span>, which will be nonzero if <span class="math inline">L\neq L^*</span>. It corresponds to the bias of the estimator <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span>, i.e.&nbsp;the difference between its expectation and the true <span class="math inline">f^{ L^*}</span>. Indeed, recalling that <span class="math inline">f^{L^*} = \underline{f}^{L^*,L^*}</span>, the error of estimation can be decomposed into <span id="eq-decomposition"><span class="math display">
\underline{\hat{f}}^{L, L^*}(t) -f^{L^*}(t)
= \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t) + \underline{f}^{L, L^*}(t) - \underline{f}^{L^*,L^*}(t) =: Stat_{L,L^*}(t) + Bias_{L,L^*}(t),
\tag{2}</span></span></p>
<p>The first term <span class="math inline">Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)</span> is the (unrescaled) statistics of the model. The second term <span class="math inline">Bias_{L,L^*}(t) = \mathbb{E}(\underline{\hat{f}}^{L, L^*}(t)) - \underline{f}^{L^*,L^*}(t)</span> is the bias of the estimator <span class="math inline">\underline{\hat{f}}^{L, L^*}(t)</span> when estimating the true function <span class="math inline">\underline{f}^{L^*,L^*}(t)</span>.</p>
<p>Let us remark that this bias is different than the bias of the estimator <span class="math inline">\underline{\hat{f}}^{L, L^*}(t)</span> when estimating the projected function <span class="math inline">\underline{f}^{L,L^*}=f^{ L^*}</span>, which is 0. The two terms defined in <a href="#eq-decomposition" class="quarto-xref">Equation&nbsp;2</a> are more detailed in the two next subsections.</p>
</section>
<section id="statistics" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="statistics"><span class="header-section-number">2.3.2</span> Statistics</h3>
<p>The statistics of the model, <span class="math inline">t\mapsto Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)</span>, is a random functional quantity which depends on the estimator <span class="math inline">\underline{\hat{f}}^{L, L^*}</span>. From <a href="#prp-error" class="quarto-xref">Proposition&nbsp;3</a>, for any <span class="math inline">t\in [0,1]</span>, we define the centered and rescaled statistics <span class="math inline">Z_L(t)</span>: <!--such that: !--> <span class="math display">Z_L(t):= \frac{Stat_{L,L^*}(t)}{\sqrt{\text{Var}(Stat_{L,L^*}(t))}}
= \frac{\underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)}{\sqrt{C^{L, L^*}(t,t)}}\sim \mathcal{N}(0,1). </span></p>
<p>The covariance function can be naturally estimated using the observations <span class="math inline">y_{i.}</span> as <span class="math display">\hat C^{L, L^*}(s,t) = \frac1{N-1}\sum_{i=1}^{N} (B^L(s)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(s))(B^L(t)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(t)).</span></p>
</section>
<section id="bias" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="bias"><span class="header-section-number">2.3.3</span> Bias</h3>
<p>The bias is due to the fact that the estimation is potentially performed in a different (finite) space than the space where the true function <span class="math inline">\underline{f}^{L^*,L^*}</span> lives. This is a functional bias, which is not random. It corresponds to the approximation of <span class="math inline">f^{L^*}</span> from <span class="math inline">\mathcal{S}^{L^*}</span> to the space <span class="math inline">\mathcal{S}^{L}</span>. It can be written as follows: <span class="math display">Bias_{L,L^*}(t) = B^L(t) \underline{\mu} ^{L,L^*} - B^{L^*}(t) \mu^{L^*}.</span> Thus, when <span class="math inline">L&lt;L^*</span> and the family is orthonormal, <span style="color: red;">the approximation is the orthogonal projection and we can deduce that</span> <!-- (Assumption 2 holds), !--> <span class="math display">Bias_{L,L^*}(t)= \sum_{\ell=1}^L B_\ell^L(t)\underline{\mu}_\ell^{L,L^*} - \sum_{\ell=1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*} = \sum_{\ell = L+1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*}.</span></p>
<p>From <a href="#prp-error" class="quarto-xref">Proposition&nbsp;3</a>, we can directly deduce the following proposition:</p>
<div id="prp-bias" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4</strong></span> Under Assumption 1 and Assumption 3, the bias is, for all <span class="math inline">t\in [0,1]</span>,</p>
<ul>
<li>for <span class="math inline">L&lt;L^*</span>, <span class="math inline">Bias_{L,L^*}(t)\neq 0</span>,</li>
<li>for <span class="math inline">L\geq L^*</span>, <span class="math inline">Bias_{L,L^*}(t) = 0</span>.</li>
</ul>
</div>
<p>In the next section, we explain how we use this property to derive confidence bands of <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span>.</p>
</section>
</section>
</section>
<section id="sec-bandSun" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Confidence Bands of <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span> for a fixed <span class="math inline">L</span></h1>
<p>The objective is to construct a confidence band for the two functions <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span>, based on the observations <span class="math inline">\mathbf{y}</span>, for a given value <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span>. The band for <span class="math inline">\underline{f}^{L, L^*}</span> enters the framework proposed by <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> which relies on an unbiased and linear estimator of the function<!--. This is the case for !--> <span style="color: red;">as</span> the estimator <span class="math inline">\underline{\hat f}^{L, L^*}</span> <!--which!--> is an unbiased estimator of <span class="math inline">\underline{f}^{L, L^*}</span>. We recall in <a href="#sec-bandSun2" class="quarto-xref">Section&nbsp;3.1</a> the construction of this confidence band which attains a given confidence level in a non-asymptotic setting, that is for a finite number of observations <span class="math inline">n</span> for each individual. Then in <a href="#sec-bandfLLstar" class="quarto-xref">Section&nbsp;3.2</a>, we prove that the confidence band proposed by <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> can be viewed as a confidence band for <span class="math inline">f^{L, L^*}</span> with an asymptotic confidence level, the asymptotic framework being considered when <span class="math inline">n\rightarrow\infty</span>.</p>
<section id="sec-bandSun2" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-bandSun2"><span class="header-section-number">3.1</span> Confidence band for <span class="math inline">\underline{f}^{L,L^*}</span></h2>
<!-- Let $L\in \{L_{\min}, \ldots, L_{\max}\}$. !-->
<p>Consider <span class="math inline">1-\alpha</span> <!--as!--> a fixed confidence level. The aim is to find a function <span class="math inline">d^L()</span> such that <span class="math display">\mathbb{P}\left( \forall t \in [0,1],\; \underline{\hat{f}_{}}^{L,L^*}(t) -d^L(t)\leq \underline{f}^{L,L^*}(t)\leq \underline{\hat{f}_{}}^{L,L^*}(t) +d^L(t)\right) = 1-\alpha.</span> Consider the normalized statistics <span class="math inline">Z_L(t)</span> which is a centered and reduced Gaussian process. We want to find the quantile <span class="math inline">q^L</span> satisfying</p>
<p><span id="eq-qL"><span class="math display">q^L =\arg\min_{q} \left\{ \mathbb{P}\left(\max_{t \in [0,1]} \left|Z_L(t)\right| \leq q \right) = 1 - \alpha\right\}. \tag{3}</span></span></p>
<p>Then we can take <span class="math inline">d^L(t) = q^L \sqrt{C^{L, L^*}(t,t)}</span>. The covariance function <span class="math inline">C^{L, L^*}(t,t)</span> can be replaced by its estimator <span class="math inline">\hat{C}^{L,L^*}(t,t)</span>, making the distribution a Student’s distribution with <span class="math inline">N-1</span> degrees of freedom. Thus, it only requires to be able to compute the critical value <span class="math inline">q^L</span>.</p>
<p>This can be done following <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> who propose a confidence band for a centered Gaussian process. Their procedure is based on an unbiased linear estimator of the function of interest, which is the case for <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span> when we consider a band for <span class="math inline">\underline{f}^{L,L^*}</span>. We recall their result in the following proposition, the computation of the value <span class="math inline">q^L</span> is detailed thereafter.</p>
<div id="thm-sunLoader" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (<span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span>)</strong></span> Set Assumption 1 and Assumption 3 and a probability <span class="math inline">\alpha\in [0,1]</span>. Then, we have <span class="math display">\mathbb{P}\left(\forall t \in [0,1], \left|\underline{\hat{f}}^{L, L^*}(t)-\underline{f}^{L,L^*}(t)\right| \leq \hat d^L(t)\right) = 1- \alpha</span> with <span class="math display">\begin{align*}
\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N}
\end{align*}</span> and <span class="math inline">\hat q^L</span> defined as the solution of the following equation, seen as a function of <span class="math inline">q^L</span>: <span id="eq-cL"><span class="math display">
\alpha = \mathbb{P}\left(|t_{N-1}|&gt;q^L\right) +\frac{\| \tau^L\|_1}{\pi}\left( 1+\frac{(q^L)^2}{N-1}\right)^{-(N-1)/2} ,
\tag{4}</span></span> with <span class="math inline">(\tau^L)^2(t)= \partial_{12} c(t,t) = Var(Z_L(t))'</span> where we denote <span class="math inline">\partial_{12}c(t,t)</span> the partial derivatives of a function <span class="math inline">c(t,s)</span> in the first and second coordinates and then evaluated at <span class="math inline">t=s</span>.</p>
</div>
<p>We can thus deduce a confidence band of level <span class="math inline">1-\alpha</span> for <span class="math inline">\underline{f}^{L,L^*}</span>: <span class="math display">\begin{align*}
CB_1(\underline{f}^{L,L^*})&amp; = \left\{ \forall t\in [0,1], \left [\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) \right ]\right\}.
\end{align*}</span></p>
<p>The value <span class="math inline">\hat q^L</span> is defined implicitly in <a href="#eq-cL" class="quarto-xref">Equation&nbsp;4</a> which involves the unknown and not explicit quantity <span class="math inline">t\mapsto \tau^L(t)</span>. <span class="citation" data-cites="Liebl2019">Liebl and Reimherr (<a href="#ref-Liebl2019" role="doc-biblioref">2023</a>)</span> propose to estimate <span class="math inline">\tau^L(t)</span>, for all <span class="math inline">t</span>, by <span class="math display">\begin{align*}
\hat \tau^L(t) &amp;= \left(\widehat{Var}(({U}^{L})'_{1}(t), \ldots, ({U}^{L})'_{N}(t)\right)^{1/2}\\
&amp;= \left(\frac{1}{N-1}\sum_{i=1}^N\left(({U}^{L})'_{i}(t)-\frac1N\sum_{j=1}^N({U}^{L})'_{j}(t)\right)^2\right)^{1/2},
\end{align*}</span> where <span class="math inline">{U}^L_{i}(t) = (P^L y_{i.}(t)-\underline{\hat{f}}^{L, L^*}(t))/(\hat C^{L,L^*}(t))^{1/2}</span> and <span class="math inline">({U}^{L})'_{i}</span> is a smooth version of the differentiated function <span class="math inline">{U}^L_{i}</span>. Then we take the <span class="math inline">L_1</span>-norm of <span class="math inline">\hat \tau^L</span>.</p>
<p>Let us describe the behavior of <span class="math inline">\hat d^L</span>:</p>
<ul>
<li><span class="math inline">\|\hat d^L\|_\infty</span> increases with <span class="math inline">L</span>.</li>
<li>When the functions <span class="math inline">(B_\ell^L)_{1\leq \ell \leq L}</span> <!--consists in!--> <span style="color: red;">form</span> an orthonormal family, <span class="math inline">\|\hat d^L\|_\infty</span> increases with <span class="math inline">L</span> until <span class="math inline">L=L^*</span> and then <span class="math inline">\|\hat d^L\|_\infty</span> is constant with <span class="math inline">L</span>.</li>
</ul>
<p><span style="color: red;"> Their behavior will be illustrated with different function families in</span> <a href="#sec-simulation" class="quarto-xref">Section&nbsp;6</a>.</p>
</section>
<section id="sec-bandfLLstar" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-bandfLLstar"><span class="header-section-number">3.2</span> Asymptotic confidence band for <span class="math inline">f^{L,L^*}</span></h2>
<p>Note that <!-- if one works !--> in the asymptotic framework <span class="math inline">n\rightarrow\infty</span>, the previous definition of <span class="math inline">\hat d^L</span> induces a natural asymptotic confidence band for the function <span class="math inline">f^{L,L^*}</span>. Indeed, we can prove that</p>
<div id="thm-CB_Liebl_asymptotic" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2</strong></span> Set Assumption 1 and Assumption 3 and a probability <span class="math inline">\alpha\in [0,1]</span>. Then, we have, <span class="math display">\lim_{n \rightarrow +\infty} \mathbb{P}\left(\forall t \in [0,1], |\underline{\hat{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)\right) = 1-\alpha,</span> with <span class="math inline">\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N}</span> and <span class="math inline">\hat q^L</span> is defined as the solution of <a href="#eq-cL" class="quarto-xref">Equation&nbsp;4</a>.</p>
</div>
<p>The proof is given in Appendix.</p>
<p>Then a confidence band for <span class="math inline">f^{L,L^*}</span> at the asymptotic confidence level <span class="math inline">1-\alpha</span> for a large number of observations <span class="math inline">n</span> is given by <span class="math display">\begin{align*}
CB(f^{L,L^*})&amp; = \left\{ \forall t\in [0,1], \left[\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) \right]\right\}.
\end{align*}</span></p>
<!-- We do not provide any illustration of this property, as it would be similar than the previous ones. Indeed, we notice that the asymptotic is achieved even when $n$ is small on our examples. !-->
</section>
</section>
<section id="sec-band2" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Confidence Band of <span class="math inline">f^{L^*}</span> by correcting the bias</h1>
<p>The function of interest is <span class="math inline">f^{L^*}=\underline{f}^{L^*, L^*}</span>, rather than <span class="math inline">\underline{f}^{L,L^*}</span>. Therefore, our objective is to construct a confidence <span style="color: red;">band</span> for <span class="math inline">f^{L^*}</span>. However, an unbiased estimator of <span class="math inline">f^{L^*}</span> is <span style="color: red;">not</span> <!--un!-->available by definition, since the true dimension <span class="math inline">L^*</span> is unknown. <!--Instead, we propose!--> <span style="color: red;">We propose instead</span> to work with the estimator <span class="math inline">\underline{\hat f}^{L,L^*}</span> and to debias the corresponding confidence band.</p>
<p>To <span style="color: red;">do</span> <!--achieve!--> this, we use the decomposition <!--outlined in @eq-decomposition!--> between the bias term and the statistical term, <span style="color: red;">outlined in</span> <a href="#eq-decomposition" class="quarto-xref">Equation&nbsp;2</a>. The idea is to bound the infinit<span style="color: red;">e</span> norm of these two terms. A first strategy <span style="color: red;">is to bound</span> <!--consists in bounding!--> each term separately, <!-- and!--> then <span style="color: red;">add</span> <!--summing!--> the two bounds to construct the confidence band. However, this approach tends to produce a band that is too large and <span style="color: red;">too</span> conservative. <span style="color: red;">This is because</span> <!--The reason is that!--> applying the infinite norm <span style="color: red;">to</span> <!--on!--> each term before bounding them does not take into account the functional nature of the two terms.</p>
<p>A second strategy <span style="color: red;">is to retain</span> <!--consists in keeping!--> the functional aspect by bounding the infinity norm of the sum of the <!--functional!--> two <span style="color: red;">functional</span> terms. This approach is detailed in this section. In <a href="#sec-construction2" class="quarto-xref">Section&nbsp;4.1</a>, we first rewrite the band as a band around <span class="math inline">\underline{f}^{L,L^*}(t)</span>. <span style="color: red;">We need to estimate the band bound and the bias. To do this, we divide the sample into two sub-samples. This choice is not ideal because it increases the variability of the estimators. But at least, it provides independence between the estimators of the two quantities, which makes it possible to establish the theoretical coverage of the final band. More precisely </span> we use a first subsample <span class="math inline">\mathbf{y}^1</span> to estimate the bound <!--as!--> defined in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>. A second subsample <span class="math inline">\mathbf{y}^2</span> is used to estimate the bias term (without the infinite norm). This <span style="color: red;">results in</span> <!--yields!--> a pointwise correction of the bias, and the final confidence band is centered around <span class="math inline">\underline{\hat{f}}^{L_{\max},L^*}</span>. This procedure provides a collection of confidence bands, for <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span> with <span style="color: red;">variable</span> <!--varying!--> width. Then, in <a href="#sec-SelectionL2" class="quarto-xref">Section&nbsp;4.2</a>, we propose a criterion to select the “best” band by minimizing its width. <span style="color: red;"> We discuss the band thus obtained at the end of the section and its limits. </span></p>
<section id="sec-construction2" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-construction2"><span class="header-section-number">4.1</span> Construction of the band of <span class="math inline">f^{L^*}</span> for a given <span class="math inline">L</span></h2>
<p>We introduce two independent sub-samples <span class="math inline">\mathbf{y}^1</span> and <span class="math inline">\mathbf{y}^2</span> of <span class="math inline">\mathbf{y}</span> of length <span class="math inline">N_1</span> and <span class="math inline">N_2</span> such that <span class="math inline">N_1+N_2=N</span>.</p>
<p>We use the first sub-sample <span class="math inline">\mathbf{y}^1</span> to calculate <span class="math inline">\underline{\hat{f}_1}^{L,L^*}(t)</span>, an estimator of <span class="math inline">\underline{f}^{L,L^*}(t)</span> and a functional bound denoted <span class="math inline">\hat d_1^L</span> that controls the bias term <span class="math inline">\underline{f}^{L,L^*}(t)-\underline{\hat{f}_1}^{L,L^*}(t)</span>. This bound is defined in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> applied on <span class="math inline">\mathbf{y}^1</span>, for a given level <span class="math inline">\alpha</span>, such that:</p>
<p><span id="eq-def-dL1"><span class="math display">
\mathbb{P}\left(\forall t\in[0,1], -\hat d_1^L(t) \leq \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t) \leq \hat d_1^L(t)\right) = 1-\alpha.
\tag{5}</span></span></p>
<p><span style="color: red;">Next,</span> <!--Then,!--> we need to control the bias <span class="math inline">Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t)-f^{L^*}(t)</span>. Recall tha<span style="color: red;">t</span> <!--n!--> when <span class="math inline">L_{\max}</span> is <span style="color: red;">sufficiently</span> large <!--enough!--> and <span class="math inline">n&gt; L_{\max}</span>, <span style="color: red;">we have</span> <span class="math inline">f^{L^*} = \underline{f}^{L_{\max},L^*}</span>. <span style="color: red;">We therefore need</span> <!--Therefore, we want!--> to control the <span class="math inline">Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}(t)</span>. It would be tempting to replace <span class="math inline">Bias_{L,L^*}(t)</span> by its estimation based on the second sample <span class="math inline">\mathbf{y}^2</span>. But this would introduce an estimation error that we also need to control, in the same spirit <span style="color: red;">as</span> <!--than!--> what is done in <span class="citation" data-cites="Pascal2017">Lacour, Massart, and Rivoirard (<a href="#ref-Pascal2017" role="doc-biblioref">2017</a>)</span>. We can <span style="color: red;">again</span> use <!--again!--> <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> to compute the function <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> on the sample <span class="math inline">\mathbf{y}^2</span>, and the functional estimators <span class="math inline">\underline{\hat{f}}_2^{L,L^*}(t)</span> and <span class="math inline">\underline{\hat f}_2^{L_{\max}, L^*}(t)</span> of <span class="math inline">\underline{f}^{L,L^*}(t)</span> and <span class="math inline">\underline{ f}^{L_{\max}, L^*}(t)</span>, respectively. This allows <span style="color: red;">us</span> to construct the following band for <span class="math inline">\underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}</span> for a confidence level <span class="math inline">1-\beta</span>,</p>
<p><span id="eq-def-dL2"><span class="math display">
\mathbb{P}\left(\forall t\in[0,1], - \hat d_2^{L,L_{\max}}(t) \leq \underline{ f}^{L_{\max}, L^*}(t)- \underline{ f}^{L, L^*}(t) - (\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t)) \leq \hat d_2^{L,L_{\max}}(t)\right) = 1-\beta.
\tag{6}</span></span></p>
<p>Combining <a href="#eq-def-dL1" class="quarto-xref">Equation&nbsp;5</a> and <a href="#eq-def-dL2" class="quarto-xref">Equation&nbsp;6</a>, we can provide a debiased confidence band of <span class="math inline">f^{L^*}(t)</span>.</p>
<div id="prp-CBf" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5</strong></span> Let us define <span class="math display">\begin{align*}
\hat\theta_1^L(t) &amp;:= -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t) \\
\hat\theta_2^L(t)&amp;:= \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t) - \underline{\hat f}_2^{L, L^*}(t),
\end{align*}</span> where <span class="math inline">\hat d_1^L(t)</span> is defined on sample <span class="math inline">\mathbf{y}^1</span> by <a href="#eq-def-dL1" class="quarto-xref">Equation&nbsp;5</a> for a level <span class="math inline">\alpha</span> and <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> is defined on sample <span class="math inline">\mathbf{y}^2</span> by <a href="#eq-def-dL2" class="quarto-xref">Equation&nbsp;6</a> for a level <span class="math inline">\beta</span>. Then we have <span class="math display">\begin{align*}
\mathbb{P}\left(\forall t \in [0,1], \quad \hat \theta_1^L(t) \leq f^{L^*}(t)- \underline{\hat f}_1^{L, L^*}(t)\leq \hat\theta_2^L(t)\right)\geq 1-\alpha\beta.
\end{align*}</span></p>
</div>
<p>The proof is given in Appendix.</p>
<p>This defines a confidence band which can be defined either around <span class="math inline">\underline{\hat{f}_{1}}^{L,L^*}</span>: <span class="math display">\begin{align*}
CB_2(\underline{f}^{L^*})=\left\{\forall t\in[0,1], \left[\underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_1^{ L}(t) \, ;\, \underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_2^{ L}(t) \right] \right\}
\end{align*}</span> or around <span class="math inline">\underline{\hat f}_2^{ L_{\max}, L^*}</span>: <span class="math display">\begin{align*}
CB_2(\underline{f}^{L^*})=\left\{\forall t\in[0,1], \left[\underline{\hat f_2}^{ L_{\max}, L^*}(t) + \bar \theta_1^L(t) \, ; \, \underline{\hat f_2}^{ L_{\max}, L^*}(t) +\bar \theta_2^L(t) \right]\right\}.
\end{align*}</span></p>
<p>with <span class="math inline">\bar \theta_1^L(t) = \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f_2}^{ L, L^*}(t) -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t)</span> and <span class="math inline">\bar \theta_2^L(t) = \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f_2}^{ L, L^*}(t) + \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)</span>.</p>
<div id="rem-dLLmax" class="proof remark">
<p><span class="proof-title"><em>Remark 1</em>. </span>The two functions <span class="math inline">\hat d_1^L(t)</span> and <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> are of the same order <span style="color: red;">because</span> <!--as!--> they are <span style="color: red;">constructed using</span> <!--built with!--> the same approach. They depend on the length of the samples. To obtain the thinnest band, the best strategy is to <span style="color: red;">divide</span> <!--split!--> the sample in two sub-samples of equal length <span style="color: red;"><span class="math inline">N_1=N_2=N/2</span>.</span> <!--$n_1=n_2= n/2$. !--></p>
</div>
<p>The behavior of <span class="math inline">\hat d_1^L</span> <span style="color: red;">was</span> <!--has been!--> described in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>. Let us describe the behavior of <span class="math inline">\hat d_2^{L,L_{\max}}</span>:</p>
<ul>
<li><span class="math inline">\|\hat d_2^{L,L_{\max}}\|_\infty</span> decreases with <span class="math inline">L</span>.</li>
<li>When <span class="math inline">L&gt;L^\varepsilon</span>, <span class="math inline">\|\hat d_2^{L,L_{\max}}\|_\infty</span> is constant with <span class="math inline">L</span> and the probability in <a href="#eq-def-dL2" class="quarto-xref">Equation&nbsp;6</a> is equal to <span class="math inline">1</span>.</li>
<li>When <span class="math inline">L^{*}&lt;L&lt;L^\varepsilon</span>, <span class="math inline">\|\hat d_2^{L,L_{\max}}\|_\infty</span> is constant with <span class="math inline">L</span> when the functions <span class="math inline">B_\ell^L</span> <span style="color: red;">form</span> <!--consists in!--> an orthonormal family. Otherwise, the behavior is erratic.</li>
</ul>
<!--It!-->
<p><span style="color: red;">This</span> means that when the band defined in <a href="#prp-CBf" class="quarto-xref">Proposition&nbsp;5</a> is calculated for <span class="math inline">L&gt;L^\varepsilon</span>, the confidence level is <span class="math inline">1-\alpha</span> instead of <span class="math inline">1-\alpha\beta</span>.</p>
<p>The advantage<!--s!--> of this approach is that the <span style="color: red;">band</span> bias <!--of the band!--> is corrected and the level for the true function <span class="math inline">f^{L^*}</span> is guaranteed when <span class="math inline">L^\varepsilon</span> is large. This was the main <span style="color: red;">aim</span> <!--objective!--> of the paper. <span style="color: red;">The main limit of this approach is that the band is constructed with samples with half sizes, leading to less precision. This will be illustrated in </span> <a href="#sec-simulation" class="quarto-xref">Section&nbsp;6</a>. <span style="color: red;">Nevertheless, this method gives finer confidence bands than cross-validation, and with the right level of confidence. </span></p>
<p><span style="color: red;">A natural question is then the choice of the dimension <span class="math inline">L</span>. This is the purpose of the next section. </span></p>
</section>
<section id="sec-SelectionL2" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-SelectionL2"><span class="header-section-number">4.2</span> Influence of <span class="math inline">L</span></h2>
<p>This approach <span style="color: red;">produces</span> <!--gives!--> a collection of <span style="color: red;">debiased</span> confidence bands for different values of <span class="math inline">L</span>. The confidence bands have different widths but a same confidence level <span class="math inline">1-\alpha\beta</span>. It is <span style="color: red;">therefore</span> <!--thus!--> natural to want to select one of them. This means <span style="color: red;">that</span> we want to select the best dimension <span class="math inline">L</span> among the collection <span class="math inline">\{L_{\min}, \ldots, L_{\max}\}</span>. We need to define what “best” means. It is quite intuitive to <span style="color: red;">want</span> <!--focus!--> on the <span style="color: red;">finest</span> band, <span style="color: red;">fine in the sense of a certain norm</span>. <!-- that is the thinnest. Thinnest could be thought in different norms.!--> Here we consider the infinite norm of the width of the confidence band. <span style="color: red;">This</span> <!--which!--> gives <!--a!--> preference to smooth bands. We <span style="color: red;">therefore</span> <!--thus!--> define the following criteria <span style="color: red;">of selection of <span class="math inline">L</span></span></p>
<p><span id="eq-def-Lhat"><span class="math display">
\hat L = \arg\min_L \left\{\sup_{t} |\hat\theta_2^L(t)-\hat\theta_1^L(t)|\right\} = \arg\min_L \left\{\sup_t | \hat d^L(t) + \hat d^{L,L_{\max}}(t)|\right\}.
\tag{7}</span></span></p>
<p><span style="color: red;">This global approach guarantees that each band of the collection is debiased and then the dimension is selected. It will be illustrated in </span> <a href="#sec-simulation" class="quarto-xref">Section&nbsp;6</a>.</p>
<p><span style="color: red;">In the next section, instead of debiasing each band, we employ another strategy focusing on the construction of a selection criteria that will guarantee that the bias is negligible.</span></p>
</section>
</section>
<section id="sec-modsel" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Selection of the best confidence band with a criteria taking into account the bias</h1>
<p>In this section, we want to use the collection of confidence bands defined in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> without correcting their bias, but <!--instead!--> by proposing a selection criterion that is a trade-off between this bias and the dimension of the basis. To do this, we propose a new heuristic criterion <span style="color: red;">linked</span> <!--going back!--> to the definition of the band itself, <span style="color: red;">considering the estimation of the band</span> <!--seen!--> as the estimation of a quantile of a certain empirical process. The criterion is inspired by model selection tools <span style="color: red;">for choosing</span> <!--to select!--> the best dimension <span class="math inline">L</span>. In the following, we assume that <span class="math inline">L_{\max}</span> is large enough such that <span class="math inline">\underline f^{L_{\max},L^*}=f^{L^*}</span>.</p>
<p>We work on the quantile <span class="math inline">q^L</span> introduced in <a href="#eq-qL" class="quarto-xref">Equation&nbsp;3</a>, its oracle version <span class="math inline">q^{L^*}</span> for <!--the!--> level <span class="math inline">L^*</span> and <span style="color: red;">its</span> <!--the!--> estimate <span class="math inline">\hat q^L</span>. All <span style="color: red;">are scalars, belonging to a collection indexed by</span> <!--of them are scalar, in a collection of scalars, with!--> <span class="math inline">L=L_{\min}, \ldots, L_{\max}</span>. A natural criterion <span style="color: red;">for choosing</span> <!--to choose!--> the best <span class="math inline">L</span> is <!--such!--> that the estimator <span class="math inline">\hat q^L</span> minimizes the quadratic error <span class="math inline">\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right)</span>. However, this quadratic error is unknown as <span class="math inline">q^{L^*}</span> is unknown. We can not <!--directly!--> use it <span style="color: red;">directly</span>.</p>
<p>Instead, we study <span class="math inline">\|\hat{q}^{L_{\max}}-\hat q^L\|^2</span>. While the theoretical quadratic error <span class="math inline">\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right)</span> decreases when <span class="math inline">L&lt;L^*</span> and increases when <span class="math inline">L&gt;L^*</span>, the <span class="math inline">\|\hat{q}^{L_{\max}}-\hat q^L\|^2</span> approximation to this error <span style="color: red;">always decreases</span> <!--is still decreasing!--> when <span class="math inline">L&gt;L^*</span>, as illustrated in <a href="#sec-simulation" class="quarto-xref">Section&nbsp;6</a>.</p>
<p>We <span style="color: red;">see</span> <!--recognize!--> a behavior similar to a bias, high when <span style="color: red;">the</span> dimension is small, and small when <span style="color: red;">the</span> dimension is large. Selecting a dimension using this criterion will always overfit the data. <span style="color: red;">We therefore</span> <!--Thus, we!--> propose to penalize this quantity by the dimension <span class="math inline">L</span> divided by the sample size <span class="math inline">N</span>, as usual in model selection criterion. <span style="color: red;">To do this</span> <!--For that,!--> we introduce a regularisation parameter <span class="math inline">\lambda&gt;0</span> which balances the two terms. A natural criteria to select the best <span class="math inline">L</span> is then <span class="math display">\widetilde{crit}(L) = \|\hat q^{L_{\max}}-\hat q^L\|^2 +\lambda \frac{L}{N}.</span></p>
<p>Then we define <span class="math display">\tilde L = \arg\min_L \widetilde{crit}(L),</span> and take the band centered around <span class="math inline">\underline{\hat{f}}^{\tilde L, L^*}</span>: <span class="math display">CB_3(\underline{f} ^{L^*}) = CB_1(\underline{f}^{\tilde L, L^*})</span></p>
<p><span style="color: red;"> This criterion is illustrated in</span> <a href="#sec-simumodsel" class="quarto-xref">Section&nbsp;6.4</a>. <span style="color: red;"> We also compare with two other standard approaches, heuristic as well, namely the cross-validation approach used to select the dimension <span class="math inline">L</span> which minimizes the reconstruction error, and a thresholding method which keeps the higher dimension <span class="math inline">L</span> with large enough coefficients. These two methods are less oriented to the objective of controling the level of the selected confidence band.</span></p>
</section>
<section id="sec-simulation" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> <span style="color: red;"> Simulation study</span></h1>
<p>In this section, we illustrate the different statements provided along the paper on generated data. First, in <a href="#sec-dgp" class="quarto-xref">Section&nbsp;6.1</a>, we describe the generating data process and illustrate the linear estimator considered in this paper. In <a href="#sec-simu-band" class="quarto-xref">Section&nbsp;6.2</a>, we illustrate the first confidence band, for a fixed level, as introduced in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>. Then, we illustrate the debiased confidence band in <a href="#sec-simudebias" class="quarto-xref">Section&nbsp;6.3</a>, and discuss the model selection criterion in <a href="#sec-simumodsel" class="quarto-xref">Section&nbsp;6.4</a>. We finally study the generalization of the method out of the class of models in <a href="#sec-gen" class="quarto-xref">Section&nbsp;6.5</a>.</p>
<section id="sec-dgp" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="sec-dgp"><span class="header-section-number">6.1</span> Generating data process</h2>
<p>To illustrate the model, we simulate a regression functional model with <span class="math inline">n=50</span> points per individual and <span class="math inline">N=40</span> individuals. In <a href="#fig-BasisModel" class="quarto-xref">Figure&nbsp;1</a>, the function <span class="math inline">f</span> (red curve) belongs to the Fourier (resp. Legendre and Spline) family with <span class="math inline">L^*=11</span> and the noisy observations <span class="math inline">y_{ij}</span> (black curves) have a functional noise in dimension <span class="math inline">L^{\varepsilon}=20</span>, also in the Fourier (resp. Legendre and Spline) family on the left plot (resp. middle and right).</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fda)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(orthopolynom)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(wavelets)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(basefun)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fields)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggpubr)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>func.basis <span class="ot">=</span> <span class="cf">function</span>(time, L, basis){</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Splines'</span>){</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">bsplineS</span>(time,<span class="at">breaks =</span> <span class="fu">seq</span>(<span class="fu">min</span>(time), <span class="fu">max</span>(time), <span class="at">length.out =</span> L<span class="dv">-1</span>), <span class="at">norder =</span> <span class="dv">3</span>, <span class="dv">0</span>) </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">fourier</span>(time,<span class="at">nbasis =</span> L) </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Legendre'</span>){</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">Legendre_basis</span>(<span class="fu">numeric_var</span>(<span class="st">"x"</span>, <span class="at">support =</span> <span class="fu">c</span>(<span class="fu">min</span>(time), <span class="fu">max</span>(time))), </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                       <span class="at">order =</span> L<span class="dv">-1</span>)(time)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(B)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>dgp <span class="ot">=</span> <span class="cf">function</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> <span class="st">'Fourier'</span>, <span class="at">f.true =</span> <span class="cn">NULL</span>){ </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  <span class="do">### n: number of timepoints</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  <span class="do">### N: number of individuals</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  <span class="do">### sd: noise level (standard deviation)</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L.eps: number of functional basis for the noise</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha.mu: vector of coefficients</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Legendre', 'Fourier', 'Splines'</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  <span class="do">### f.true: if one wants to fix the true function</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out =</span> n)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L.star<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L.star <span class="ot">=</span> L.star<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L.eps<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L.eps <span class="ot">=</span> L.eps<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(f.true)){</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="do">### Create the functional basis </span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L.star, basis)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="do">### Generate randomly coefficients, if needed</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(alpha.mu)){</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>      alpha.mu <span class="ot">=</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">5</span><span class="sc">:-</span><span class="dv">2</span>, <span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>),<span class="at">size=</span>L.star,<span class="at">replace=</span><span class="cn">TRUE</span>)} </span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>      alpha.mu <span class="ot">=</span> alpha.mu <span class="sc">/</span> <span class="dv">3</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>      sd <span class="ot">=</span> sd<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow =</span> N, <span class="at">ncol =</span> n)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>    f.true <span class="ot">=</span> B <span class="sc">%*%</span> alpha.mu</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>  B.eps <span class="ot">=</span> <span class="fu">func.basis</span>(time, L.eps, basis)</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow =</span> N, <span class="at">ncol =</span> n)</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    y[i,] <span class="ot">=</span> f.true <span class="sc">+</span> B.eps <span class="sc">%*%</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(L.eps, <span class="dv">0</span>, sd))</span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">y =</span> <span class="fu">t</span>(y), <span class="at">alpha.mu =</span> alpha.mu, <span class="at">time =</span> time, <span class="at">L.star=</span>L.star, <span class="at">f.true =</span> f.true))</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>n<span class="ot">=</span><span class="dv">50</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>N<span class="ot">=</span><span class="dv">40</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>sd<span class="ot">=</span><span class="dv">1</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>L.star<span class="ot">=</span><span class="dv">11</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>L.eps <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>alpha.mu <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>dfLegendre <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>                         <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>f.true),</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>                         <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Fourier"</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>dfFourier <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>f.true),</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span><span class="dv">2</span><span class="sc">*</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>dfSplines <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y,data<span class="sc">$</span>f.true),</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">rbind</span>(dfLegendre, dfFourier, dfSplines)</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> df, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">color =</span> type, <span class="at">group =</span> ind)) <span class="sc">+</span> </span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_colour_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"obs"</span> <span class="ot">=</span> <span class="st">"lightgrey"</span>,<span class="st">"True"</span> <span class="ot">=</span> <span class="st">"red"</span>)) <span class="sc">+</span></span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-BasisModel" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-BasisModel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-BasisModel-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-BasisModel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Illustrative example. We generate a regression functional model in the Fourier (left), Legendre (middle) and Splines (right) families. The red curve corresponds to the true function, and the gray curves correspond to noisy observations.
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#prp-proj" class="quarto-xref">Proposition&nbsp;1</a> and <a href="#prp-proj2" class="quarto-xref">Proposition&nbsp;2</a> are illustrated in Appendix.</p>
<!--@fig-estimatorL displays estimators calculated with different dimensions $L$. Data are generated with $L^*=11$, $L^\varepsilon=20$, $n=50$ and $N=40$. The true function and its projection $\underline f^{L,L^*}$ are in cyan, and the estimator $\underline{\hat{f}_{}}^{L,L^*}$ is in red. We compute it for the three families, Legendre, Fourier and splines. 
In all cases, the estimators are very precise when considering the relevant dimension, but estimating a function of dimension $L^*$ with a function of dimension $L<L^*$ is not consistent. Note that the performance of the estimator for the spline family is also good, even if the family is not orthonormal, because we work here at the level of the function (and not at the level of the coefficients). 





::: {.cell}

```{.r .cell-code}
estimator = function(data, basis, L){
  ### data: the observations, only the timepoints and the individual functions
  ### basis: functional basis, to be chosen in 'Fourier', 'Splines'
  ### L: number of functional basis for the signal
  
  if (basis == 'Fourier'){
    if (L%%2 == 0){ L = L+1}
  }
  B = func.basis(data$time, L, basis)
  
  ### Data projection
  Hi = solve(t(B) %*% B) %*% t(B) %*% data$y
  mu.hat = rowMeans(Hi)
  f.hat = c(B %*% mu.hat)
  data.proj = data
  data.proj$y = B %*% Hi
  cov.emp = crossprod(t(data.proj$y - f.hat)) / ncol(data.proj$y)
  
  return(list(f.hat=f.hat, mu.hat = mu.hat, cov.emp = cov.emp, data.proj = data.proj))
}

set.seed(1)
basis = "Legendre"
data = dgp(n=50,N=40,sd=1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)
B = func.basis(data$time, L=5, basis)
f.true.L5 = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)
est5 = estimator(data, basis, L=5)
est11 = estimator(data, basis, L=11)
dfLegendre = data.frame( Time = rep(data$time,4),
                         basis = rep(basis, 4*length(data$time)),
                         f = c(data$f.true, c(f.true.L5), est5$f.hat, est11$f.hat),
                         L = rep(c("L = 11", "L = 5", "L = 5", "L = 11"), each = length(data$time)),
                         type = rep(c("True", "True", "Estimated", "Estimated"), each = length(data$time)))

basis = "Fourier"
data = dgp(n=50,N=40,sd=1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)
B = func.basis(data$time, L=5, basis)
f.true.L5 = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)
est5 = estimator(data, basis, L=5)
est11 = estimator(data, basis, L=11)
dfFourier = data.frame( Time = rep(data$time,4),
                        basis = rep(basis, 4*length(data$time)),
                        f = c(data$f.true, c(f.true.L5), est5$f.hat, est11$f.hat),
                        L = rep(c("L = 11", "L = 5", "L = 5", "L = 11"), each = length(data$time)),
                        type = rep(c("True", "True", "Estimated", "Estimated"), each = length(data$time)))

basis = "Splines"
data = dgp(n=50,N=40,sd=2*1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)
B = func.basis(data$time, L=5, basis)
f.true.L5 = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)
est5 = estimator(data, basis, L=5)
est11 = estimator(data, basis, L=11)
dfSplines = data.frame( Time = rep(data$time,4),
                        basis = rep(basis, 4*length(data$time)),
                        f = c(data$f.true, c(f.true.L5), est5$f.hat, est11$f.hat),
                        L = rep(c("L = 11", "L = 5", "L = 5", "L = 11"), each = length(data$time)),
                        type = rep(c("True", "True", "Estimated", "Estimated"), each = length(data$time)))

df = rbind(dfLegendre, dfFourier, dfSplines)
ggplot(data = df, aes(x = Time, y = f, color = type)) + 
  geom_line(aes(linetype = type), linewidth= 0.5)+
  facet_grid(L~basis)
```

::: {.cell-output-display}
![Illustrative example. For each family (Fourier which is orthogonal, Legendre which is orthonormal and the splines which are not orthogonal wrt the standard scalar product), we consider a function with true dimension 11 (top), and its projection on the space of dimension 5 (bottom), displayed in cyan. The estimators in dimensions 11 and 5 are displayed in red.](ConfBand_files/figure-html/fig-estimatorL-1.svg){#fig-estimatorL height=50%}
:::
:::



!-->
</section>
<section id="sec-simu-band" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sec-simu-band"><span class="header-section-number">6.2</span> Confidence band for a fixed level</h2>
<p>The band derived in <a href="#thm-sunLoader" class="quarto-xref">Theorem&nbsp;1</a> is illustrated on <a href="#fig-bandL" class="quarto-xref">Figure&nbsp;2</a>. It displays on the top row several functional data generated under either the Fourier family (left), Legendre (middle) or Spline (right), on the middle row the confidence bands of <span class="math inline">\underline f^{L,L^*}</span> for different values of <span class="math inline">L=3,5</span> and <span class="math inline">11</span>, and on the bottom row the bound <span class="math inline">\hat d^L</span>. The true functions <span class="math inline">\underline f^{L,L^*}</span> are displayed in cyan and the confidence bands in purple. The bands are very precise for each <span class="math inline">L</span>. The behavior of <span class="math inline">\hat d^L</span> increases with <span class="math inline">L</span>. As <span class="math inline">d^L</span> can be seen as a variance, <span class="math inline">\hat d^L(t)</span> is larger on the boundary of the time domain, as there are less observations near 0 and 1.</p>
<p>We also evaluate numerically the levels of the obtained confidence bands. For this, 1000 datasets are simulated, the confidence band is estimated for each of them. The empirical confidence level is then evaluated as the proportion of confidence bands that contain the true function. <a href="#tbl-levelL" class="quarto-xref">Table&nbsp;1</a> presents the empirical confidence levels for different values of <span class="math inline">L</span> and two sample sizes <span class="math inline">n=50</span> and <span class="math inline">n=150</span>, with <span class="math inline">N=10</span>, <span class="math inline">N=40</span> and <span class="math inline">N=60</span>. When <span class="math inline">N=40</span> and <span class="math inline">N=60</span>, the level is the expected one whatever the value of <span class="math inline">L</span>, especially when <span class="math inline">L&lt;L^*</span> and <span class="math inline">N=40</span>, but also when <span class="math inline">L&gt;L^\varepsilon</span>. We will see in the next sections that this will not be the case for the debiased confidence band. When <span class="math inline">N=10</span>, the level is too small, especially when <span class="math inline">L</span> is large. This might be due to the the large number of parameters to be estimated in the covariance matrix <span class="math inline">C</span>, with a small number of observations <span class="math inline">N</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>compute.c.L <span class="ot">=</span> <span class="cf">function</span>(data.scl, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data.scl: the rescaled data </span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  x_approx <span class="ot">=</span> <span class="fu">apply</span>(data.scl<span class="sc">$</span>y, <span class="dv">2</span>,<span class="at">FUN=</span><span class="cf">function</span>(yy){</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    fn <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">splinefun</span>(<span class="at">x =</span> data.scl<span class="sc">$</span>time, <span class="at">y =</span> yy, <span class="at">method =</span> <span class="st">"natural"</span>)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    pracma<span class="sc">::</span><span class="fu">fderiv</span>(<span class="at">f =</span> fn, <span class="at">x =</span> data.scl<span class="sc">$</span>time, <span class="at">n =</span> <span class="dv">1</span>, <span class="at">h =</span> <span class="fl">1e-6</span>, <span class="at">method =</span> <span class="st">"central"</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="fu">ncol</span>(data.scl<span class="sc">$</span>y)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  hat.tau <span class="ot">=</span> <span class="fu">apply</span>(x_approx, <span class="dv">1</span>, stats<span class="sc">::</span>sd) </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  hat.tau[<span class="fu">which</span>(<span class="fu">is.na</span>(hat.tau))] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  tau_01 <span class="ot">=</span> (hat.tau)[<span class="sc">-</span><span class="dv">1</span>]<span class="sc">%*%</span><span class="fu">diff</span>(data.scl<span class="sc">$</span>time)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  myfun <span class="ot">=</span> <span class="cf">function</span>(c){stats<span class="sc">::</span><span class="fu">pt</span>(c, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>, <span class="at">df =</span> N<span class="dv">-1</span>) <span class="sc">+</span> tau_01 <span class="sc">*</span> </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span> <span class="sc">+</span> c<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>(N<span class="dv">-1</span>))<span class="sc">^</span>(<span class="sc">-</span>(N<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>)<span class="sc">/</span>(<span class="dv">2</span> <span class="sc">*</span> pi) <span class="sc">-</span> alpha<span class="sc">/</span><span class="dv">2</span>}</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">uniroot</span>(<span class="at">f =</span> myfun,<span class="at">interval =</span> <span class="fu">c</span>(.<span class="dv">5</span>,<span class="dv">8</span>))<span class="sc">$</span>root</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(c.L)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>CB1 <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>  est <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est<span class="sc">$</span>data.proj</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est<span class="sc">$</span>cov.emp))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est<span class="sc">$</span>f.hat <span class="sc">+</span> d.L</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est<span class="sc">$</span>f.hat <span class="sc">-</span> d.L</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">d.L =</span> d.L, <span class="at">c.L =</span> c.L, <span class="at">width =</span> <span class="fu">max</span>(<span class="fu">abs</span>(f.hat.up<span class="sc">-</span>f.hat.low))))</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>d.L.Lmax <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax=</span><span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax)) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, alpha)</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(c.L.Lmax<span class="fl">.2</span>)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>dfObs <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">ind =</span> <span class="fu">integer</span>())</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>dfTrue <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                    <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                    <span class="at">f =</span> <span class="fu">double</span>())</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>dfTrueProjected <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                             <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                             <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                             <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>dfBand <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                     <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                     <span class="at">flow =</span> <span class="fu">double</span>(),</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                     <span class="at">fup =</span> <span class="fu">double</span>(),</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                     <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>dfdL <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                   <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                   <span class="at">dL =</span> <span class="fu">double</span>(),</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                   <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="dv">40</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span>N,<span class="at">sd=</span><span class="dv">2</span><span class="sc">*</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span>  {data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span>N,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)}</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  dfObs <span class="ot">=</span> <span class="fu">rbind</span>(dfObs,<span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time, N),</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(<span class="fu">c</span>(data<span class="sc">$</span>y))),</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y),</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>N, <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  dfTrue <span class="ot">=</span> <span class="fu">rbind</span>(dfTrue,<span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">f =</span> data<span class="sc">$</span>f.true))</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    conf.band <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, L)</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    dfBand <span class="ot">=</span> <span class="fu">rbind</span>(dfBand, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">flow =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>f.hat.low), </span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">fup =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>f.hat.up), </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    dfTrueProjected <span class="ot">=</span> <span class="fu">rbind</span>(dfTrueProjected, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">f =</span> <span class="fu">c</span>(f.true.L), </span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">dimension =</span> <span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    dfdL <span class="ot">=</span> <span class="fu">rbind</span>(dfdL, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dL =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>d.L),</span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L,<span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfObs, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">group =</span> ind), <span class="at">linewidth =</span> <span class="fl">0.1</span>, <span class="at">color =</span> <span class="st">"grey"</span>) <span class="sc">+</span></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrue, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f), <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span> </span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBand, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> flow, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBand, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> fup, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.8</span>) <span class="sc">+</span> </span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrueProjected, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">group =</span> dimension), <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">linewidth =</span> <span class="fl">0.2</span>)<span class="sc">+</span> </span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"confidence band"</span>)</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdL, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dL, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension)) <span class="sc">+</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a><span class="fu">ggarrange</span>(p1, p2, p3, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">common.legend =</span> <span class="cn">TRUE</span>, <span class="at">legend =</span> <span class="st">"bottom"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-bandL" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bandL-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-bandL-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bandL-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Illustrative example. For the three families, resp. Fourier, Legendre and the splines, we display on the top row the observed functional data, on the middle row the confidence bands for different values of L (3, 5 and 11), and on the bottom row the bound dL.
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">40</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">60</span>)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  vec.basis <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'Fourier'</span>, <span class="st">"Legendre"</span>, <span class="st">"Splines"</span>)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="fu">max</span>(vec.L),<span class="fu">length</span>(vec.n),<span class="fu">length</span>(vec.N), <span class="fu">length</span>(vec.basis)))</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.basis <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.basis)){</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (ind.N <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.N)){</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>            <span class="fu">set.seed</span>(rep)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (vec.basis[ind.basis] <span class="sc">==</span> <span class="st">"Splines"</span>){           data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> vec.basis[ind.basis], <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            } <span class="cf">else</span> { data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> vec.basis[ind.basis]) }</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            conf.band <span class="ot">=</span> <span class="fu">CB1</span>(data, vec.basis[ind.basis], L, <span class="at">alpha=</span> <span class="fl">0.05</span>)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (vec.basis[ind.basis] <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>            B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, vec.basis[ind.basis])</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>            B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L, vec.basis[ind.basis])</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>            f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">sum</span>(f.true.L<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true.L<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>              cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            } </span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>          perf[L,ind.n, ind.N, ind.basis] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab1.RData"</span>)</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"Res_Tab1.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>perf.F <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">1</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">1</span>],perf[vec.L,,<span class="dv">3</span>,<span class="dv">1</span>])</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>perf.L <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">2</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">2</span>],perf[vec.L,,<span class="dv">3</span>,<span class="dv">2</span>])</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>perf.S <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">3</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">3</span>],perf[vec.L,,<span class="dv">3</span>,<span class="dv">3</span>])</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.F) <span class="ot">=</span> vec.L</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.L) <span class="ot">=</span> vec.L</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.S) <span class="ot">=</span> vec.L</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.F) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'50/10'</span>, <span class="st">'150/10'</span>, <span class="st">'50/40'</span>, <span class="st">'150/40'</span>, <span class="st">'50/60'</span>, <span class="st">'150/60'</span>)</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.L) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'50/10'</span>, <span class="st">'150/10'</span>, <span class="st">'50/40'</span>, <span class="st">'150/40'</span>, <span class="st">'50/60'</span>, <span class="st">'150/60'</span>)</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.S) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'50/10'</span>, <span class="st">'150/10'</span>, <span class="st">'50/40'</span>, <span class="st">'150/40'</span>, <span class="st">'50/60'</span>, <span class="st">'150/60'</span>)</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a><span class="co">#kable(perf)</span></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>perf.F <span class="sc">%&gt;%</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">6</span>))</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>perf.L <span class="sc">%&gt;%</span></span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">6</span>))</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>perf.S <span class="sc">%&gt;%</span></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">6</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-levelL" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-levelL-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: The confidence level of the confidence band CB is evaluated from 1000 repetitions. Confidence bands are calculated with the Fourier family (a), Legendre family (b) and Splines family (c), for several L in rows and several n and N in columns, for alpha = 0.05.
</figcaption>
<div aria-describedby="tbl-levelL-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">

</div>
<div class="cell-output-display">

</div>
<div class="cell-output-display">

</div>
</div>
</figure>
</div>
</div>
</section>
<section id="sec-simudebias" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="sec-simudebias"><span class="header-section-number">6.3</span> Confidence bands by correcting the bias</h2>
<p>We illustrate the results given in <a href="#prp-CBf" class="quarto-xref">Proposition&nbsp;5</a>. In <a href="#fig-Lstar" class="quarto-xref">Figure&nbsp;3</a>, top row, we plot the confidence bands obtained for different dimensions <span class="math inline">L \in \{3,5,11,15,21\}</span> with Fourier, Legendre and Splines families and <span class="math inline">\alpha=\beta=\sqrt{0.05}\approx 0.22</span>. We can see that all the confidence bands are alike. Especially, they are unbiased, even for <span class="math inline">L=3</span>. A larger dimension <span class="math inline">L</span> provides a smoother band. On the middle and bottom rows of <a href="#fig-Lstar" class="quarto-xref">Figure&nbsp;3</a>, we illustrate the two terms that enter the confidence band, <span class="math inline">t \mapsto \hat d_1^L(t)</span> and <span class="math inline">t\mapsto \hat d_2^{L,L_{\max}}(t)</span>. Their behavior is the same along time. The function <span class="math inline">\hat d_1^L(t)</span> can be seen as a variance, this is why it is larger near 0 and 1 where there are less observations. The function <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> is smaller than <span class="math inline">\hat d_1^L(t)</span> because it controls the remaining rest after the projection. Note that as expected when <span class="math inline">L&gt;L^\varepsilon</span>, <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> is close to 0. As explained before, the influence of <span class="math inline">L</span> is not the same for the two functions. When <span class="math inline">L</span> increases, <span class="math inline">\hat d_1^L(t)</span> increases while <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> decreases.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>CB2 <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the time-points and the individual functions</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.1</span> <span class="ot">=</span> data<span class="fl">.2</span> <span class="ot">=</span> data</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  ind<span class="fl">.1</span> <span class="ot">=</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>], <span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.1</span><span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,ind<span class="fl">.1</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.2</span><span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,<span class="sc">-</span>ind<span class="fl">.1</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.1</span>, basis, L)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>scl <span class="ot">=</span> data.<span class="fl">1.</span>proj</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>scl<span class="sc">$</span>y <span class="ot">=</span> (data.<span class="fl">1.</span>proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  c.L<span class="fl">.1</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">1.</span>scl, alpha)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>  d.L<span class="fl">.1</span> <span class="ot">=</span> c.L<span class="fl">.1</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">1.</span>scl<span class="sc">$</span>y))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.2</span>, basis, L)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.2</span>, basis, Lmax)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax)) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(cov.emp.rest))</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(cov.emp.rest)<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L<span class="fl">.1</span> <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L<span class="fl">.1</span> <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">d.L =</span> d.L<span class="fl">.1</span>, <span class="at">d.L.Lmax =</span> d.L.Lmax<span class="fl">.2</span>, <span class="at">width =</span> <span class="fu">max</span>(<span class="fu">abs</span>(f.hat.up<span class="sc">-</span>f.hat.low))))</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>dfTrue <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>                    <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>                    <span class="at">basis =</span> <span class="fu">character</span>()</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>dfBandup <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                      <span class="at">bandup =</span> <span class="fu">double</span>(),</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                      <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>dfBandlow <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>                       <span class="at">bandlow =</span> <span class="fu">double</span>(),</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>                       <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>                       <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>dfdL <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>                  <span class="at">dLLmax =</span> <span class="fu">double</span>(),</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>                  <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>                  <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a>dfdLLmax <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dL =</span> <span class="fu">double</span>(),</span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a>                      <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>)</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){ data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">2</span><span class="sc">*</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)}</span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>  dfTrue <span class="ot">=</span> <span class="fu">rbind</span>(dfTrue, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb6-68"><a href="#cb6-68" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">f =</span> data<span class="sc">$</span>f.true,</span>
<span id="cb6-69"><a href="#cb6-69" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb6-70"><a href="#cb6-70" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb6-71"><a href="#cb6-71" aria-hidden="true" tabindex="-1"></a>  crit.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">nrow =</span> <span class="dv">30</span>)</span>
<span id="cb6-72"><a href="#cb6-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb6-73"><a href="#cb6-73" aria-hidden="true" tabindex="-1"></a>    conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">CB2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb6-74"><a href="#cb6-74" aria-hidden="true" tabindex="-1"></a>    crit.sel[L,] <span class="ot">=</span><span class="fu">c</span>(<span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L), <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax),</span>
<span id="cb6-75"><a href="#cb6-75" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">sum</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L<span class="sc">+</span>conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax)))</span>
<span id="cb6-76"><a href="#cb6-76" aria-hidden="true" tabindex="-1"></a>    dfBandup <span class="ot">=</span> <span class="fu">rbind</span>(dfBandup, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb6-77"><a href="#cb6-77" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">bandup =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up),</span>
<span id="cb6-78"><a href="#cb6-78" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb6-79"><a href="#cb6-79" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb6-80"><a href="#cb6-80" aria-hidden="true" tabindex="-1"></a>    dfBandlow <span class="ot">=</span> <span class="fu">rbind</span>(dfBandlow, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb6-81"><a href="#cb6-81" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">bandlow =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low),</span>
<span id="cb6-82"><a href="#cb6-82" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb6-83"><a href="#cb6-83" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb6-84"><a href="#cb6-84" aria-hidden="true" tabindex="-1"></a>    dfdL <span class="ot">=</span> <span class="fu">rbind</span>(dfdL, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb6-85"><a href="#cb6-85" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dL =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L),</span>
<span id="cb6-86"><a href="#cb6-86" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb6-87"><a href="#cb6-87" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb6-88"><a href="#cb6-88" aria-hidden="true" tabindex="-1"></a>    dfdLLmax <span class="ot">=</span> <span class="fu">rbind</span>(dfdLLmax, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb6-89"><a href="#cb6-89" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dLLmax =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax),</span>
<span id="cb6-90"><a href="#cb6-90" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb6-91"><a href="#cb6-91" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb6-92"><a href="#cb6-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-93"><a href="#cb6-93" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-94"><a href="#cb6-94" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-95"><a href="#cb6-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-96"><a href="#cb6-96" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb6-97"><a href="#cb6-97" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrue, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f)) <span class="sc">+</span></span>
<span id="cb6-98"><a href="#cb6-98" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandup, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandup, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb6-99"><a href="#cb6-99" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandlow, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandlow, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb6-100"><a href="#cb6-100" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span> basis)</span>
<span id="cb6-101"><a href="#cb6-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-102"><a href="#cb6-102" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb6-103"><a href="#cb6-103" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdL, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dL, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb6-104"><a href="#cb6-104" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>( <span class="sc">~</span> basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"d.L"</span>)</span>
<span id="cb6-105"><a href="#cb6-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-106"><a href="#cb6-106" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb6-107"><a href="#cb6-107" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdLLmax, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dLLmax, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb6-108"><a href="#cb6-108" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>( <span class="sc">~</span> basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"d.L.Lmax"</span>)</span>
<span id="cb6-109"><a href="#cb6-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-110"><a href="#cb6-110" aria-hidden="true" tabindex="-1"></a><span class="fu">ggarrange</span>(p1, p2, p3, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">common.legend =</span> <span class="cn">TRUE</span>, <span class="at">legend =</span> <span class="st">"bottom"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-Lstar" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-Lstar-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-Lstar-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-Lstar-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Illustrative example. For a given dataset, we plot several confidence bands (top row), functions dL (middle row) and dLLmax (bottom row). Bands and functions are estimated with Fourier (left column), Legendre (middle column) and Spline (right column) basis and several dimensions L (3, 5, 11, 15, 21).
</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#tbl-levLstar" class="quarto-xref">Table&nbsp;2</a>, we simulate 1000 repeated datasets with the Legendre family and with two sample sizes <span class="math inline">n=50</span> and <span class="math inline">n=150</span> and <span class="math inline">N=40</span>. For each dataset, we compute the confidence band defined in <a href="#prp-CBf" class="quarto-xref">Proposition&nbsp;5</a> with a theoretical confidence level of <span class="math inline">1-\alpha\beta=0.95</span> and for different values of <span class="math inline">L</span>. Then the confidence level is approximated as the proportion of confidence bands containing the true function <span class="math inline">f</span>. Remark that when <span class="math inline">L&lt;L^{\varepsilon}</span>, the level is the expected one, that is 0.95. When <span class="math inline">L&gt;L^{\varepsilon}</span>, the level is not more ensured, as explained before. Indeed the term <span class="math inline">d^{L,L^{\max}}</span> is mainly equal to 0, and the level is close to <span class="math inline">1-\alpha</span> instead of <span class="math inline">1-\alpha\beta</span>. This is not the case for the band in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>, as this is due to the correction of the bias.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> <span class="fu">max</span>(vec.L), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>      cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">set.seed</span>(rep)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">basis =</span> <span class="st">"Legendre"</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">CB2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.2</span>, <span class="at">beta=</span><span class="fl">0.2</span>)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        f.true <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> data<span class="sc">$</span>f.true, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span>} </span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>      perf[L,ind.n] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> perf[vec.L,]</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(perf) <span class="ot">=</span> vec.L</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(perf) <span class="ot">=</span> vec.n</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab2.RData"</span>)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_Tab2.RData'</span>)}</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>perf <span class="sc">%&gt;%</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n"</span> <span class="ot">=</span> <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-levLstar" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-levLstar-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2: Illustrative example. We display the level of confidence for the proposed confidence band CB2, for several L in rows and several n in columns, N=40, for alpha=0.2 and beta=0.2 (and then in total the confidence band reaches the level 0.95), and considering the Legendre family.
</figcaption>
<div aria-describedby="tbl-levLstar-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">

</div>
</div>
</figure>
</div>
</div>
<p>We illustrate the different terms involved in <a href="#eq-def-Lhat" class="quarto-xref">Equation&nbsp;7</a>. In <a href="#fig-dLLmax" class="quarto-xref">Figure&nbsp;4</a>, we plot for a given dataset, the infinity norm of the width of the band <span class="math inline">\hat d^L(t) + \hat d^{L,L_{\max}}(t)</span> (top), of <span class="math inline">\hat d^L(t)</span> (middle) and <span class="math inline">\hat d^{L,L_{\max}}(t)</span> (bottom) functions obtained with the Fourier (left column), Legendre (middle column) and Spline (right column) basis. As already said, <span class="math inline">\|\hat d^L\|_{\infty}</span> increases with <span class="math inline">L</span> while <span class="math inline">\|\hat d^{L,L_{\max}}\|_{\infty}</span> decreases (and is zero when <span class="math inline">L&gt;L^{\varepsilon}</span>). The width of the band wrt <span class="math inline">L</span> does not have a <span class="math inline">U</span>-shape, as expected. It is thus difficult to minimize this criterion and the selection of <span class="math inline">\hat L</span> is thus not stable. But again, whatever the value of <span class="math inline">\hat L</span>, the corresponding band is debiased in the collection. <span style="color: red;">We will see in the next section that its width is smaller than standard approaches.</span> The performance of the selection is <span style="color: red;">also</span> illustrated in the next section.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Norm =</span> <span class="fu">double</span>(),</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">type =</span> <span class="fu">character</span>(),</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">dimension =</span> <span class="fu">integer</span>()</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){   data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> d.L <span class="ot">=</span> d.L.Lmax <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">CB2</span>(data, basis, L, <span class="at">Lmax =</span> L.max, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>width)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    d.L <span class="ot">=</span> <span class="fu">c</span>(d.L, <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L))</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    d.L.Lmax <span class="ot">=</span> <span class="fu">c</span>(d.L.Lmax, <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax))</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">=</span> <span class="fu">rbind</span>(df, <span class="fu">data.frame</span> (<span class="at">Norm =</span> <span class="fu">c</span>(length.band, d.L, d.L.Lmax),</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>                             <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Band width norm"</span>, <span class="st">"d.L norm"</span>, <span class="st">"d.L.Lmax norm"</span>), <span class="at">each =</span> <span class="fu">length</span>(vec.L)),</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>                             <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">3</span><span class="sc">*</span> <span class="fu">length</span>(vec.L)),</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>                             <span class="at">dimension =</span> <span class="fu">rep</span>(vec.L, <span class="dv">3</span>)))</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Norm, <span class="at">fill =</span> type)) <span class="sc">+</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span> </span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(type <span class="sc">~</span> basis, <span class="at">scales =</span> <span class="st">'free'</span>) <span class="sc">+</span> <span class="fu">xlab</span>(<span class="st">"L"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-dLLmax" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-dLLmax-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-dLLmax-1.svg" style="height:50.0%" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-dLLmax-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Illustrative example. For a given dataset, we calculate the norm of the width of the confidence band (top), of the dL function (middle) and the dLLmax function (bottom), for several dimensions L and for Fourier (left column), Legendre (middle column) and Splines (right column) basis.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-simumodsel" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="sec-simumodsel"><span class="header-section-number">6.4</span> Model selection criterion</h2>
<p>We <span style="color: red;">want to</span> evaluate the performance of the <span style="color: red;">two</span> selection criteria introduced in this paper.</p>
<p><span style="color: red;">First, we consider the second approach presented in <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a>. </span> In <a href="#fig-critlast" class="quarto-xref">Figure&nbsp;5</a>, we illustrate the behavior of the selection criterion introduced in <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a> on simulated data, with <span class="math inline">\lambda=1</span> for the three basis. We can see that <span class="math inline">\tilde L</span> is overestimated. When considering nested spaces, it ensures that <span class="math inline">\tilde L</span> tends to be larger than <span class="math inline">L^*</span> and thus the confidence band is automatically unbiased.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>dfCriterion <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">criterion =</span> <span class="fu">double</span>(),</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                         <span class="at">dimension =</span> <span class="fu">integer</span>(),</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>) }</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">L.eps =</span> <span class="dv">28</span>, <span class="at">sd=</span><span class="dv">2</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">L.eps =</span> <span class="dv">28</span>, <span class="at">sd =</span> <span class="dv">1</span>)}</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    length.band[L] <span class="ot">=</span> conf.band.L<span class="sc">$</span>width</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (lambda <span class="cf">in</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>)){</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    dfCriterion <span class="ot">=</span> <span class="fu">rbind</span>(dfCriterion, <span class="fu">data.frame</span>(<span class="at">criterion =</span> crit,</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">dimension =</span> vec.L,</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">lambdas =</span> lambda,</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfCriterion, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> criterion, <span class="at">color =</span> lambdas)) <span class="sc">+</span> </span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>()<span class="sc">+</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-critlast" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-critlast-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-critlast-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-critlast-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Illustrative example. For a given simulated dataset, we show the behavior of the criteria as a function of dimension L, for several lambdas, for Fourier (left), Legendre (middle) and Splines (right) basis.
</figcaption>
</figure>
</div>
</div>
</div>
<p><span style="color: red;">We compare the two strategies <span class="math inline">CB_2</span> and <span class="math inline">CB_3</span> with some standard approaches. More precisely, </span> we simulate 100 repeated datasets. The different confidence bands and the norm of their widths are computed for several <span class="math inline">L</span>. We apply the selection criteria and plot the distribution of the estimated dimension in <a href="#fig-modelsel" class="quarto-xref">Figure&nbsp;6</a>, for the three basis families, for several model selection criteria: <span class="math inline">\hat L</span>, <span class="math inline">\tilde L</span>, cross validation and hard thresholding. The dimension <span class="math inline">\hat L</span> is almost always larger than the true <span class="math inline">L^*=11</span>. The fact that it is larger is not a problem because the selected band is unbiased and has the correct level as soon as <span class="math inline">L^\varepsilon</span> is large. However, the criterion tends to select a band that is (too) smooth. We can see that the selected dimension <span class="math inline">\tilde{L}</span> is smaller in distribution, and closer to the true value than <span class="math inline">\hat{L}</span>. In addition, as we then use the confidence band of <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a>, the confidence level is guaranteed to be as expected. The model selected by cross validation is rather good, for all the basis considered. On the other hand, the model selected by hard thresholding is not good, particularly for a non orthonormal basis, which makes sense in relation to <a href="#prp-proj" class="quarto-xref">Proposition&nbsp;1</a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  repet <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  length.CBL.CV <span class="ot">=</span> length.CBL.L0 <span class="ot">=</span> <span class="fu">c</span>(<span class="cn">NA</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  dfLengthSelect.CV <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">length =</span> <span class="fu">double</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  dfLhatSelect.CV <span class="ot">=</span> dfLhatSelect.L0 <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Lhat =</span> <span class="fu">double</span>(), <span class="at">L =</span> <span class="fu">integer</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  dfBandWidth <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">double</span>(),</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>                           <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                           <span class="at">dimension =</span> <span class="fu">integer</span>())</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  dfLhat <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Lhat =</span> <span class="fu">double</span>(), <span class="at">L =</span> <span class="fu">integer</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  ind.basis <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  cpt <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="dv">6</span>, <span class="at">ncol =</span> <span class="dv">3</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    ind.basis <span class="ot">=</span> ind.basis <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    mod.sel <span class="ot">=</span> mod.sel.L0 <span class="ot">=</span> mod.sel.CV <span class="ot">=</span> coeff.L0 <span class="ot">=</span> err <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    mod.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> repet, <span class="at">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    L.mod.sel <span class="ot">=</span> c.L <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    Lmax <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    ind <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>repet){<span class="fu">print</span>(rep)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>      <span class="fu">set.seed</span>(rep)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){      data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>, <span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span>  {data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>, <span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)}</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>      length.band <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>      data.train <span class="ot">=</span> data.test <span class="ot">=</span> data</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>      data.train<span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[, <span class="dv">1</span><span class="sc">:</span>(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>)]</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>      data.test<span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span><span class="sc">+</span><span class="dv">1</span>) <span class="sc">:</span> (<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>])]</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>      tot.VC <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">each =</span> <span class="fu">dim</span>(data.train<span class="sc">$</span>y)[<span class="dv">2</span>] <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>      err <span class="ot">&lt;-</span> <span class="fu">sapply</span>(vec.L, <span class="cf">function</span>(L) {</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        <span class="fu">mean</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="cf">function</span>(VC) {</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>          train <span class="ot">&lt;-</span> data.train</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>          train<span class="sc">$</span>y <span class="ot">&lt;-</span> train<span class="sc">$</span>y[,<span class="sc">-</span><span class="fu">which</span>(tot.VC <span class="sc">==</span> VC)]</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>          test <span class="ot">&lt;-</span> data.train</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>          test<span class="sc">$</span>y <span class="ot">&lt;-</span> test<span class="sc">$</span>y[, <span class="fu">which</span>(tot.VC <span class="sc">==</span> VC)]</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>          est.L <span class="ot">&lt;-</span> <span class="fu">estimator</span>(train, basis, L)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>          <span class="fu">sqrt</span>(<span class="fu">mean</span>((test<span class="sc">$</span>y <span class="sc">-</span> est.L<span class="sc">$</span>f.hat)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>        }))</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>      })</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>        CB2.L <span class="ot">=</span> <span class="fu">CB2</span>(data, <span class="at">basis =</span> basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>        length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, CB2.L<span class="sc">$</span>width)</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>        conf.band.L <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>        c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>        est.L <span class="ot">=</span> <span class="fu">estimator</span>(data.train, basis, L)</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>        coeff.L0[L] <span class="ot">=</span> <span class="fu">sum</span>(<span class="fu">abs</span>(est.L<span class="sc">$</span>mu.hat) <span class="sc">&gt;</span> <span class="fl">0.1</span>)</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">min</span>(length.band), vec.L[<span class="fu">which.min</span>(length.band)])</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>      CB2.Lhat <span class="ot">=</span> <span class="fu">CB2</span>(data, <span class="at">basis =</span> basis, mod.sel[rep,<span class="dv">2</span>], <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>      conf.band.L.max <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, <span class="at">L =</span> Lmax, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>      c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L </span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">3</span>] <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>width</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>      conf.band.L.star <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, <span class="at">L =</span> <span class="dv">11</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">4</span>] <span class="ot">=</span> conf.band.L.star<span class="sc">$</span>width</span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>      lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>      crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a>      L.mod.sel[rep] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>      CB3 <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, <span class="at">L =</span> L.mod.sel[rep], <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">5</span>] <span class="ot">=</span> CB3<span class="sc">$</span>width</span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a>      mod.sel.CV[rep] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(err)]</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a>      conf.band.CV <span class="ot">=</span> <span class="fu">CB1</span>(data.test, basis, mod.sel.CV[rep], <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>      length.CBL.CV[rep] <span class="ot">=</span> conf.band.CV<span class="sc">$</span>width</span>
<span id="cb10-70"><a href="#cb10-70" aria-hidden="true" tabindex="-1"></a>      mod.sel.L0[rep] <span class="ot">=</span> <span class="fu">max</span>(coeff.L0, <span class="at">na.rm=</span><span class="cn">TRUE</span>)</span>
<span id="cb10-71"><a href="#cb10-71" aria-hidden="true" tabindex="-1"></a>      conf.band.L0 <span class="ot">=</span> <span class="fu">CB1</span>(data.test, basis, mod.sel.L0[rep], <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb10-72"><a href="#cb10-72" aria-hidden="true" tabindex="-1"></a>      length.CBL.L0[rep] <span class="ot">=</span> conf.band.L0<span class="sc">$</span>width</span>
<span id="cb10-73"><a href="#cb10-73" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb10-74"><a href="#cb10-74" aria-hidden="true" tabindex="-1"></a>      <span class="do">## coverage</span></span>
<span id="cb10-75"><a href="#cb10-75" aria-hidden="true" tabindex="-1"></a>      n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb10-76"><a href="#cb10-76" aria-hidden="true" tabindex="-1"></a>      time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb10-77"><a href="#cb10-77" aria-hidden="true" tabindex="-1"></a>      f.true <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> data<span class="sc">$</span>f.true, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb10-78"><a href="#cb10-78" aria-hidden="true" tabindex="-1"></a>      models <span class="ot">=</span> <span class="fu">list</span>(CB2.Lhat, conf.band.L.max, conf.band.L.star, CB3, conf.band.CV, conf.band.L0)</span>
<span id="cb10-79"><a href="#cb10-79" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (mod <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>){</span>
<span id="cb10-80"><a href="#cb10-80" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> models[[mod]]<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb10-81"><a href="#cb10-81" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> models[[mod]]<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb10-82"><a href="#cb10-82" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){cpt[mod,ind.basis] <span class="ot">=</span> cpt[mod,ind.basis] <span class="sc">+</span><span class="dv">1</span></span>
<span id="cb10-83"><a href="#cb10-83" aria-hidden="true" tabindex="-1"></a>        } <span class="cf">else</span> { <span class="cf">if</span>(mod <span class="sc">==</span> <span class="dv">4</span>){ind <span class="ot">=</span> <span class="fu">c</span>(ind, rep)}}</span>
<span id="cb10-84"><a href="#cb10-84" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-85"><a href="#cb10-85" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb10-86"><a href="#cb10-86" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb10-87"><a href="#cb10-87" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-88"><a href="#cb10-88" aria-hidden="true" tabindex="-1"></a>    dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">c</span>(mod.sel[ ,<span class="dv">1</span>], mod.sel[ ,<span class="dv">3</span>], mod.sel[ ,<span class="dv">4</span>], mod.sel[ ,<span class="dv">5</span>], length.CBL.CV, length.CBL.L0),</span>
<span id="cb10-89"><a href="#cb10-89" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis, repet<span class="sc">*</span><span class="dv">6</span>), <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Lhat"</span>, <span class="st">"Lmax"</span>, <span class="st">"Lstar"</span>,<span class="st">"Ltilde"</span>, <span class="st">"L.CV"</span>, <span class="st">"L.L0"</span>), </span>
<span id="cb10-90"><a href="#cb10-90" aria-hidden="true" tabindex="-1"></a>                                                                                             <span class="at">each =</span> repet))) </span>
<span id="cb10-91"><a href="#cb10-91" aria-hidden="true" tabindex="-1"></a>    dfLhat <span class="ot">=</span> <span class="fu">rbind</span>(dfLhat, <span class="fu">data.frame</span>(</span>
<span id="cb10-92"><a href="#cb10-92" aria-hidden="true" tabindex="-1"></a>      <span class="at">L =</span> vec.L,</span>
<span id="cb10-93"><a href="#cb10-93" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel[,<span class="dv">2</span>], <span class="at">levels =</span> vec.L))),</span>
<span id="cb10-94"><a href="#cb10-94" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat.CV =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel.CV, <span class="at">levels =</span> vec.L))),      </span>
<span id="cb10-95"><a href="#cb10-95" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat.L0 =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel.L0, <span class="at">levels =</span> vec.L))),</span>
<span id="cb10-96"><a href="#cb10-96" aria-hidden="true" tabindex="-1"></a>      <span class="at">L.tilde =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(L.mod.sel, <span class="at">levels =</span> vec.L))),</span>
<span id="cb10-97"><a href="#cb10-97" aria-hidden="true" tabindex="-1"></a>      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb10-98"><a href="#cb10-98" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-99"><a href="#cb10-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-100"><a href="#cb10-100" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-101"><a href="#cb10-101" aria-hidden="true" tabindex="-1"></a>  cpt <span class="ot">=</span> cpt<span class="sc">/</span>repet</span>
<span id="cb10-102"><a href="#cb10-102" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-103"><a href="#cb10-103" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(cpt, <span class="at">file =</span> <span class="st">"Res_Tab4.RData"</span>)</span>
<span id="cb10-104"><a href="#cb10-104" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab3_BandWidth.RData"</span>)</span>
<span id="cb10-105"><a href="#cb10-105" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfLhat, <span class="at">file =</span> <span class="st">"Res_Tab3_Lhat.RData"</span>)</span>
<span id="cb10-106"><a href="#cb10-106" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb10-107"><a href="#cb10-107" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">'Res_Tab4.RData'</span>)}</span>
<span id="cb10-108"><a href="#cb10-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-109"><a href="#cb10-109" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(cpt) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"L hat"</span>, <span class="st">"Lmax"</span>, <span class="st">"Lstar"</span>, <span class="st">"Ltilde"</span>, <span class="st">"L.CV"</span>, <span class="st">"L.L0"</span>)</span>
<span id="cb10-110"><a href="#cb10-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-111"><a href="#cb10-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-112"><a href="#cb10-112" aria-hidden="true" tabindex="-1"></a>cpt <span class="sc">%&gt;%</span></span>
<span id="cb10-113"><a href="#cb10-113" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb10-114"><a href="#cb10-114" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"model"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"Legendre"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"Fourier"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"Splines"</span> <span class="ot">=</span> <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-levLstar2" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-levLstar2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3: Illustrative example. We display the level of confidence over 100 repetitions for the proposed confidence band CB3, for several model selection criterion in rows and several basis in columns, for alpha=0.05.
</figcaption>
<div aria-describedby="tbl-levLstar2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">

</div>
</div>
</figure>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">'Res_Tab3_Lhat.RData'</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> dfLhat, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat)) <span class="sc">+</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> dfLhat, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> L.tilde)) <span class="sc">+</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> dfLhat, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat.CV)) <span class="sc">+</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>p4 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> dfLhat, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat.L0)) <span class="sc">+</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="fu">grid.arrange</span>(p1, p2, p3, p4, <span class="at">nrow =</span> <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-modelsel" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-modelsel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-modelsel-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-modelsel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Illustrative example with <span class="math inline">N=40</span>. From 100 datasets, we calculate the distribution of the estimated dimension L, for four model selection criteria: from top to bottom, the debiased band proposed in CB2 with Lhat, the band CB3 with Ltilde, the cross validation and hard thresholding methods. The true dimension is <span class="math inline">L^* = 11</span>.
</figcaption>
</figure>
</div>
</div>
</div>
<p>The reformulation of the band around <span class="math inline">\underline{\hat f}_2^{ L_{\max}, L^*}</span> is close to the band presented in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> for <span class="math inline">L=L_{\max}</span>, that is a band centered around <span class="math inline">\underline{\hat f}^{ L_{\max}, L^*}</span>. A natural question is to understand what is the gain by doing so instead of using the band from <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> with <span class="math inline">L=L_{\max}</span>, namely the band <span class="math inline">\left [\underline{\hat f}^{ L_{\max}, L^*}(t)-\hat d^{L_{\max}}(t); \underline{\hat f}^{ L_{\max}, L^*}(t)+\hat d^{L_{\max}}(t)\right]</span>. To do that, we have to understand the behavior of the different terms. As it is difficult to compare theoretically the width of the two bands, we compare them using simulations. For 100 repeated datasets, we compute several confidence bands: the <span class="math inline">CB_1</span> band constructed in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> with <span class="math inline">L_{\max}</span>, the <span class="math inline">CB_{2}</span> band defined in <a href="#prp-CBf" class="quarto-xref">Proposition&nbsp;5</a> with <span class="math inline">\hat L</span>, the <span class="math inline">CB_{3}</span> band defined in <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a> with <span class="math inline">\tilde L</span> and the ideal (and not accessible) band constructed in <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> with the true <span class="math inline">L^*</span>. In <a href="#fig-width-2" class="quarto-xref">Figure&nbsp;7</a>, we present boxplots of the norms of the band width with <span class="math inline">\hat L</span>, <span class="math inline">L_{\max}</span>, <span class="math inline">L^*</span> and <span class="math inline">\tilde{L}</span>. The width of the confidence band with the true <span class="math inline">L^*</span> is smaller, which is expected but unfortunately not achievable. The width of the confidence band <span class="math inline">CB_1</span> is smaller than that of the band <span class="math inline">CB_2</span>. This can be explained by the fact that we estimate two different quantities, on smaller datasets, for more conservative levels (<span class="math inline">1-\alpha</span> and <span class="math inline">1-\beta</span> respectively) in order to finally achieve the confidence level of <span class="math inline">1-\alpha\beta</span>. This also explains why the cross validation and hard-thresholding methods, which also divide the sample into two parts, do not give good results either. The model given by the heuristic model selection criterion <span class="math inline">\tilde crit</span> achieves good performance. Note that the width of the selected model <span class="math inline">\tilde L</span> is better than the width of the confidence band with a large level <span class="math inline">L_{\max}</span>, which one should have used to avoid model selection.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">'Res_Tab3_BandWidth.RData'</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfBandWidth, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Band.width)) <span class="sc">+</span> </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>basis, <span class="at">scales =</span> <span class="st">"free_y"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-width-2" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-width-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-width-2-1.svg" style="height:25.0%" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-width-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Illustrative example. We display within boxplots the confidence band’s width over 100 repetitions for the dimension selected by the several criterion introduced in this paper, for Fourier (left), Legendre (middle) and Splines (right) basis.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-gen" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="sec-gen"><span class="header-section-number">6.5</span> Generalization out of the model</h2>
<p>We now illustrate the behaviour of the bands when the basis used for estimation is poorly specified. We simulate 1000 data sets with a spline basis and estimate the confidence bands with the Fourier and Legendre basis, for different values of <span class="math inline">n</span> and <span class="math inline">N</span>. The coverage rates are presented in <a href="#tbl-levelL-2" class="quarto-xref">Table&nbsp;4</a>. The Fourier basis does not give a correct rate. On the other hand, the Legendre basis gives very satisfactory coverage rates for <span class="math inline">L&gt;20</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>, <span class="dv">31</span>, <span class="dv">35</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">40</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  basis<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'Fourier'</span>, <span class="st">'Legendre'</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="fu">max</span>(vec.L),<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (ind.N <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.N)){</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (ind.basis <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>            <span class="fu">set.seed</span>(rep)</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>              data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis, <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>            } <span class="cf">else</span> {data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis)}</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>            conf.band <span class="ot">=</span> <span class="fu">CB1</span>(data, basis<span class="fl">.2</span>[ind.basis], L)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>            B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>            B <span class="ot">=</span> <span class="fu">func.basis</span>(time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>            f.true <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>            f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>            f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>              cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>            } </span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>          perf[L,ind.n, ind.N, ind.basis] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab_other.RData"</span>)</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"Res_Tab_other.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">1</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">1</span>])</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.Fourier) <span class="ot">=</span> vec.L</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.Fourier) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">" 50/10"</span>, <span class="st">"150/10"</span>, <span class="st">"50/40"</span>, <span class="st">"150/40"</span>)</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="sc">%&gt;%</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">4</span>))</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>pref.Legendre <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">2</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">2</span>])</span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(pref.Legendre) <span class="ot">=</span> vec.L</span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(pref.Legendre) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">" 50/10"</span>, <span class="st">"150/10"</span>, <span class="st">"50/40"</span>, <span class="st">"150/40"</span>)</span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>pref.Legendre <span class="sc">%&gt;%</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-levelL-2" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-levelL-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4: Illustrative example. The confidence level of the confidence band is evaluated from 1000 repetitions. Data is generated using a Splines basis, and confidence bands are calculated with the Fourier (a) and Legendre (b) families, for several L in rows and several n and N in columns.
</figcaption>
<div aria-describedby="tbl-levelL-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">

</div>
<div class="cell-output-display">

</div>
</div>
</figure>
</div>
</div>
<p>Next, we illustrate the <span class="math inline">\tilde L</span> dimension selection method and compare it to the cross-validation method. <a href="#tbl-levelL-3" class="quarto-xref">Table&nbsp;5</a> presents the coverage rates of the corresponding confidence bands estimated with the Fourier and Legendre basis, in the case <span class="math inline">N=40</span> and <span class="math inline">n=150</span>. Once again, we see that the Fourier basis does not give good results, either by cross-validation or by <span class="math inline">\tilde L</span>. On the other hand, with the Legendre basis, the <span class="math inline">\tilde L</span> method gives a satisfactory coverage rate, even if it is underestimated, whereas the cross-validation method is very poor. Moreover, the widths of the confidence bands selected with <span class="math inline">\tilde L</span> and by cross validation are represented by boxplot in <a href="#fig-width-3" class="quarto-xref">Figure&nbsp;8</a>. It can be seen that the cross-validation approach provides wider bands, even though their confidence level is not guaranteed. The method proposed in this paper provides a narrower band with a correct level of confidence. We thus recommend to use the Legendre family with the criteria <span class="math inline">\tilde L</span>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>, <span class="dv">31</span>, <span class="dv">35</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">150</span>) </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">40</span>)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  basis<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'Fourier'</span>, <span class="st">'Legendre'</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  perf.sel <span class="ot">=</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>  err <span class="ot">=</span> coeff.L0 <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  L.mod.sel <span class="ot">=</span> mod.sel.CV <span class="ot">=</span> length.CBL.CV <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  mod.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> nb.repeat, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>  width <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim=</span><span class="fu">c</span>(<span class="dv">2</span>, nb.repeat))</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  dfBandWidth <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">double</span>(),</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>                           <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>                           <span class="at">dimension =</span> <span class="fu">integer</span>())</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (ind.N <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.N)){</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (ind.basis <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>        cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>          <span class="fu">set.seed</span>(rep)</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>            data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis, <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>          } <span class="cf">else</span> {data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis)}</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>          data.train <span class="ot">=</span> data</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>          data.train<span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[, <span class="dv">1</span><span class="sc">:</span>(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>)]</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>          data.test <span class="ot">=</span> data</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>          data.test<span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>) <span class="sc">:</span> (<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>])]</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>          tot.VC <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">each =</span> <span class="fu">dim</span>(data.train<span class="sc">$</span>y)[<span class="dv">2</span>] <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>          err <span class="ot">&lt;-</span> <span class="fu">sapply</span>(vec.L, <span class="cf">function</span>(L) {</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mean</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="cf">function</span>(VC) {</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>              train <span class="ot">&lt;-</span> data.train</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>              train<span class="sc">$</span>y <span class="ot">&lt;-</span> train<span class="sc">$</span>y[,<span class="sc">-</span><span class="fu">which</span>(tot.VC <span class="sc">==</span> VC)]</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>              test <span class="ot">&lt;-</span> data.train</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>              test<span class="sc">$</span>y <span class="ot">&lt;-</span> test<span class="sc">$</span>y[, <span class="fu">which</span>(tot.VC <span class="sc">==</span> VC)]</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>              est.L <span class="ot">&lt;-</span> <span class="fu">estimator</span>(train, basis, L)</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>              <span class="fu">sqrt</span>(<span class="fu">mean</span>((test<span class="sc">$</span>y <span class="sc">-</span> est.L<span class="sc">$</span>f.hat)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>            }))</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>          })</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>            CB2.L <span class="ot">=</span> <span class="fu">CB2</span>(data, <span class="at">basis =</span> basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>            length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, CB2.L<span class="sc">$</span>width)</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>            conf.band.L <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>            c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>          mod.sel[rep,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">min</span>(length.band), vec.L[<span class="fu">which.min</span>(length.band)])</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>          lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>          crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>          L.mod.sel[rep] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>          CB3 <span class="ot">=</span> <span class="fu">CB1</span>(data, <span class="at">basis =</span> basis<span class="fl">.2</span>[ind.basis], <span class="at">L =</span> L.mod.sel[rep], <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>          mod.sel.CV[rep] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(err)]</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a>          conf.band.CV <span class="ot">=</span> <span class="fu">CB1</span>(data.test, <span class="at">basis =</span> basis<span class="fl">.2</span>[ind.basis], mod.sel.CV[rep], <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a>          <span class="do">## coverage</span></span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>          n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a>          time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>          B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a>          B <span class="ot">=</span> <span class="fu">func.basis</span>(time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a>          f.true <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a>          models <span class="ot">=</span> <span class="fu">list</span>(CB3, conf.band.CV)</span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a>          width[<span class="dv">1</span>,rep] <span class="ot">=</span> CB3<span class="sc">$</span>width</span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a>          width[<span class="dv">2</span>,rep] <span class="ot">=</span> conf.band.CV<span class="sc">$</span>width</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (mod <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true" tabindex="-1"></a>            f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> models[[mod]]<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true" tabindex="-1"></a>            f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> models[[mod]]<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){perf.sel[mod,ind.n, ind.N, ind.basis] <span class="ot">=</span> perf.sel[mod,ind.n, ind.N, ind.basis] <span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true" tabindex="-1"></a>        dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">c</span>(width[<span class="dv">1</span>,], width[<span class="dv">2</span>,]),</span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis<span class="fl">.2</span>[ind.basis], nb.repeat<span class="sc">*</span><span class="dv">2</span>), <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L tilde"</span>, <span class="st">"L.CV"</span>), </span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true" tabindex="-1"></a>                                                                                             <span class="at">each =</span> nb.repeat))) </span>
<span id="cb14-85"><a href="#cb14-85" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb14-86"><a href="#cb14-86" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb14-87"><a href="#cb14-87" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-88"><a href="#cb14-88" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-89"><a href="#cb14-89" aria-hidden="true" tabindex="-1"></a>  perf.sel <span class="ot">=</span> perf.sel <span class="sc">/</span> nb.repeat  </span>
<span id="cb14-90"><a href="#cb14-90" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-91"><a href="#cb14-91" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf.sel, <span class="at">file =</span> <span class="st">"Res_Tab_other_2.RData"</span>)</span>
<span id="cb14-92"><a href="#cb14-92" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab_other_2_width.RData"</span>)</span>
<span id="cb14-93"><a href="#cb14-93" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"Res_Tab_other_2.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb14-94"><a href="#cb14-94" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="ot">=</span> <span class="fu">matrix</span>(perf.sel[,,,<span class="dv">1</span>], <span class="at">nrow=</span><span class="dv">2</span>, <span class="at">ncol=</span><span class="dv">1</span>)</span>
<span id="cb14-95"><a href="#cb14-95" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.Fourier) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'L tilde'</span>, <span class="st">'L.CV'</span>)</span>
<span id="cb14-96"><a href="#cb14-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-97"><a href="#cb14-97" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="sc">%&gt;%</span></span>
<span id="cb14-98"><a href="#cb14-98" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb14-99"><a href="#cb14-99" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n=150, N=40"</span> <span class="ot">=</span> <span class="dv">1</span>))</span>
<span id="cb14-100"><a href="#cb14-100" aria-hidden="true" tabindex="-1"></a>pref.Splines <span class="ot">=</span> <span class="fu">matrix</span>(perf.sel[,,<span class="dv">1</span>,<span class="dv">2</span>], <span class="at">nrow=</span><span class="dv">2</span>, <span class="at">ncol=</span><span class="dv">1</span>)</span>
<span id="cb14-101"><a href="#cb14-101" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(pref.Splines) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'L tilde'</span>, <span class="st">'L.CV'</span>)</span>
<span id="cb14-102"><a href="#cb14-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-103"><a href="#cb14-103" aria-hidden="true" tabindex="-1"></a>pref.Splines <span class="sc">%&gt;%</span></span>
<span id="cb14-104"><a href="#cb14-104" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb14-105"><a href="#cb14-105" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n=150, N=40"</span> <span class="ot">=</span> <span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-levelL-3" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-levelL-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;5: Illustrative example. The confidence level of the confidence band is evaluated from 100 repetitions. Data is generated using a Splines basis, and confidence bands are calculated with the Fourier (a) and Legendre (b) families, for several model selection criterion in rows, L in rows and several n and N in columns.
</figcaption>
<div aria-describedby="tbl-levelL-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">

</div>
<div class="cell-output-display">

</div>
</div>
</figure>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">"Res_Tab_other_2_width.RData"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfBandWidth, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Band.width)) <span class="sc">+</span> </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>basis, <span class="at">scales =</span> <span class="st">"free_y"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-width-3" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-width-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-width-3-1.svg" style="height:25.0%" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-width-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Illustrative example. The confidence level of the confidence band is evaluated from 100 repetitions. Data is generated using a Splines basis, and confidence bands are calculated with the Fourier (a) and Legendre (b) families, for several model selection criterion in rows, L in rows and several n and N in columns.
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-realdata" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Real data analysis</h1>
<p>In this section, we illustrate the proposed method on the Berkeley Growth Study data. It consists of the heights in centimeters of 39 boys at 31 ages from 1 to 18. We approximate these curves by the 3 basis Legendre, Splines and Fourier. We select the level of each basis using the method introduced in <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(growth)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">list</span>()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>time <span class="ot">=</span> (growth<span class="sc">$</span>age <span class="sc">-</span> <span class="fu">min</span>(growth<span class="sc">$</span>age))<span class="sc">/</span>(<span class="fu">max</span>(growth<span class="sc">$</span>age) <span class="sc">-</span> <span class="fu">min</span>(growth<span class="sc">$</span>age))</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>y <span class="ot">=</span> growth<span class="sc">$</span>hgtm</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">25</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="dv">3</span><span class="sc">:</span><span class="dv">24</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fl">0.2</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>dfBandlow <span class="ot">=</span> dfBandup <span class="ot">=</span> df.max <span class="ot">=</span> res_growth <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Splines"</span>, <span class="st">"Fourier"</span>)){</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  mod.sel<span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">24</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> alpha)</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax <span class="ot">=</span> <span class="fu">max</span>(conf.band.L.max<span class="sc">$</span>c.L)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  df.max <span class="ot">=</span> <span class="fu">rbind</span>(df.max, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age, </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">band.up =</span> <span class="fu">t</span>(conf.band.L.max<span class="sc">$</span>f.hat.up),</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">band.low =</span> <span class="fu">t</span>(conf.band.L.max<span class="sc">$</span>f.hat.low),</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, L, <span class="at">alpha =</span> (alpha))</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>  mod.sel <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">#print(paste0('model selected:', mod.sel))</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>  conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, mod.sel, <span class="at">alpha =</span> alpha)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>  dfBandup <span class="ot">=</span> <span class="fu">rbind</span>(dfBandup, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age,</span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">bandup =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up),</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>  dfBandlow <span class="ot">=</span> <span class="fu">rbind</span>(dfBandlow, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age,</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">bandlow =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low),</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">#print(paste0('length L sel:', conf.band.L.star.2$c.L))</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>  res_growth <span class="ot">=</span> <span class="fu">round</span>(<span class="fu">cbind</span>(res_growth, <span class="fu">c</span>(conf.band.L.max<span class="sc">$</span>c.L, conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>c.L, mod.sel)),<span class="dv">2</span>)</span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(res_growth) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Splines"</span>, <span class="st">"Fourier"</span>)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(res_growth) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Width Lmax"</span>, <span class="st">"Width selected"</span>, <span class="st">"Model selected"</span>)</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>df.data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">rep</span>(growth<span class="sc">$</span>age,<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]), <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]), <span class="at">each =</span> <span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span> <span class="fu">geom_line</span>(<span class="at">data=</span>df.data, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span>f, <span class="at">group=</span>ind), <span class="at">color =</span> <span class="st">"lightgrey"</span>,<span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandup, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandup,<span class="at">col =</span> basis, <span class="at">group =</span> basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandlow, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandlow,<span class="at">col =</span> basis, <span class="at">group =</span> basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> df.max, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span> band.up, <span class="at">group=</span>basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> df.max, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span> band.low, <span class="at">group=</span>basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span> basis)</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>p1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-realdata" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-realdata-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-realdata-1.svg" style="height:25.0%" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-realdata-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: Real data analysis example. We display the confidence bands for Fourier (left), Legendre (middle) and Splines (right) basis on the Berkeley Growth Study data. Black curves correspond to the confidence bands with <span class="math inline">L_{max}</span>, while colored one are the confidence bands CBE.
</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>res_growth <span class="sc">%&gt;%</span> </span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">" "</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"Basis"</span> <span class="ot">=</span> <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="tbl-realdata" class="cell quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-realdata-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;6: Real data analysis example, Berkeley Growth Study data. We display the width of the confidence bands for Fourier, Legendre and Splines basis for the confidence band of <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> with Lmax and the confidence band of <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a>. We also precise the dimension of the selected model.
</figcaption>
<div aria-describedby="tbl-realdata-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">

</div>
</div>
</figure>
</div>
</div>
<p>In <a href="#fig-realdata" class="quarto-xref">Figure&nbsp;9</a>, we display the confidence bands associated <span style="color: red;">with</span> <!--to!--> <a href="#sec-bandSun" class="quarto-xref">Section&nbsp;3</a> in black and <span style="color: red;">those</span> <!--the one!--> associated <span style="color: red;">with</span> <!--to!--> <a href="#sec-modsel" class="quarto-xref">Section&nbsp;5</a>, for the three basis. As the data is not periodic, the Fourier basis is meaningless, <span style="color: red;">as is</span> <!--and so is!--> the associated confidence band, whatever the dimension considered. Splines and Legendre basis give similar confidence bands. <span style="color: red;">By</span> <!--When!--> analyzing the width of the bands in <a href="#tbl-realdata" class="quarto-xref">Table&nbsp;6</a>, compared <span style="color: red;">to that</span> <!--with the one!--> obtained with <span class="math inline">L_{\max}</span>, we <span style="color: red;">find</span> <!--see!--> that they are less smooth but also smaller, and from our empirical study we guess that it makes a trade-off between bias and variance.</p>
</section>
<section id="sec-conc" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Conclusion</h1>
<p>This paper <span style="color: red;">deals with</span> <!--discusses!--> the construction of confidence bands when considering a <span style="color: red;">functional model.</span> <!--linear model over a functional family.!--> Depending on the nature of the family (an orthogonal or orthonormal basis, or simply a vector space), <span style="color: red;">the</span> theoretical guarantees of the linear estimator are <span style="color: red;">recalled</span> <!--reminded!--> and illustrated. Several confidence bands are then proposed. <!--Throughout the paper,!--> <span style="color: red;">An</span> extensive experimental study on Fourier, Legendre and Spline basis <!--have!--> illustrate<span style="color: red;">s</span> the theoretical and methodological propositions, and a real data study is proposed to conclude the paper.</p>
<p>First, when considering a functional family with fixed dimension, we discuss the confidence band derived from <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span>. It is biased if the dimension is not high enough to approximate well the true function. <span style="color: red;">We then propose a</span> new confidence band <!--is proposed!--> that corrects this bias. To do this, the bias is estimated and the additional randomness is controlled. A selection criterion is proposed to select the best dimension. Unfortunately, the two <span style="color: red;">types</span> <!--kinds!--> of randomness <span style="color: red;">lead</span> <!--are leading!--> to a wider confidence band, and this result is <span style="color: red;">therefore no</span> <!--then not!--> more interesting than the naive one, which consists of taking the largest possible dimension <span class="math inline">L_{\max}</span>. Finally, a heuristic selection criterion is proposed to select the dimension on the first confidence band, <span style="color: red;">which has not corrected</span> <!--that did not correct!--> the bias. It takes into account the bias as well as the variance, to select a moderate dimension. <span style="color: red;">Numerical experiments show that this criterion, combined with the Legendre basis, achieve the best performance when considering the confidence level and the width of the corresponding simultaneous confidence band. </span></p>
<!--The last selection criterion is heuristic, <span style='color: red;'>and includes terms that are intuitive.</span> while each term is intuitive.!-->
<p>An interesting next step, but out of the scope of this paper, <span style="color: red;">is</span> <!--consists of!--> a theoretical study of this criterion. <span style="color: red;">To our knowledge, there are no results concerning the</span> <!--No result, to our knowledge, exist for!--> confidence band with the supremum norm. The euclidean norm <span style="color: red;">has been extensively studied,</span> <!--is well-studied in general,!--> but is not of interest here, where we want to ensure that the tube is valid as a whole. The supremum norm, on <span style="color: red;">the other hand,</span> <!--its side,!--> is difficult to study theoretically. <span style="color: red;">Futhermore, a</span> <!--A!--> keypoint here <!--also!--> is the randomness of the criterion, <span style="color: red;">which must also</span> <!--that has also to!--> be taken into account, through an oracle inequality for example.</p>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-ANEIROS2022104871" class="csl-entry" role="listitem">
Aneiros, Germán, Silvia Novo, and Philippe Vieu. 2022. <span>“Variable Selection in Functional Regression Models: A Review.”</span> <em>Journal of Multivariate Analysis</em> 188: 104871.
</div>
<div id="ref-BASNA2022104868" class="csl-entry" role="listitem">
Basna, Rani, Hiba Nassar, and Krzysztof Podgórski. 2022. <span>“Data Driven Orthogonal Basis Selection for Functional Data Analysis.”</span> <em>Journal of Multivariate Analysis</em> 189: 104868.
</div>
<div id="ref-bunea2011" class="csl-entry" role="listitem">
Bunea, Florentina, Andrada E. Ivanescu, and Marten H. Wegkamp. 2011. <span>“Adaptive Inference for the Mean of a Gaussian Process in Functional Data.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 73 (4): 531–58.
</div>
<div id="ref-Chen2015" class="csl-entry" role="listitem">
Chen, Ming, and Qiongxia Song. 2015. <span>“<span class="nocase">Simultaneous inference of the mean of functional time series</span>.”</span> <em>Electronic Journal of Statistics</em> 9 (2): 1779–98. <a href="https://doi.org/10.1214/15-EJS1052">https://doi.org/10.1214/15-EJS1052</a>.
</div>
<div id="ref-Claeskens2003" class="csl-entry" role="listitem">
Claeskens, G., and I. Van Keilegom. 2003. <span>“Bootstrap Confidence Bands for Regression Curves and Their Derivatives.”</span> <em>Ann. Stat.</em> 31: 1852–1884".
</div>
<div id="ref-conformalPrediction2022" class="csl-entry" role="listitem">
Diquigiovanni, Jacopo, Matteo Fontana, and Simone Vantini. 2022. <span>“Conformal Prediction Bands for Multivariate Functional Data.”</span> <em>Journal of Multivariate Analysis</em> 189: 104879.
</div>
<div id="ref-GoeppSubmitted" class="csl-entry" role="listitem">
Goepp, V., O. Bouaziz, and G. Nuel. 2025. <span>“Spline Regression with Automatic Knot Selection.”</span> <em>Computational Statistics and Data Analysis</em> 202.
</div>
<div id="ref-Hall1991" class="csl-entry" role="listitem">
Hall, P. 1991. <span>“On Convergence Rates of Suprema.”</span> <em>Probab Theory Related Fields</em>.
</div>
<div id="ref-Jacques2023" class="csl-entry" role="listitem">
Hernández, Nicolás, Jairo Cugliari, and Julien Jacques. 2024. <span>“Simultaneous Predictive Bands for Functional Time Series Using Minimum Entropy Sets.”</span> <em>Communications in Statistics - Simulation and Computation</em>, 1–25.
</div>
<div id="ref-jacques2022" class="csl-entry" role="listitem">
Jacques, Julien, and Sanja Samardžić. 2022. <span>“<span class="nocase">Analysing Cycling Sensors Data Through Ordinal Logistic Regression with Functional Covariates</span>.”</span> <em>Journal of the Royal Statistical Society Series C: Applied Statistics</em> 71 (4): 969–86.
</div>
<div id="ref-kokoszka2017introduction" class="csl-entry" role="listitem">
Kokoszka, P., and M. Reimherr. 2017. <em>Introduction to Functional Data Analysis</em>. Chapman &amp; Hall / CRC Numerical Analysis and Scientific Computing. CRC Press.
</div>
<div id="ref-Krivobokova2010" class="csl-entry" role="listitem">
Krivobokova, Tatyana, Thomas Kneib, and Gerda Claeskens. 2010. <span>“Simultaneous Confidence Bands for Penalized Spline Estimators.”</span> <em>Journal of the American Statistical Association</em> 105 (490): 852–63.
</div>
<div id="ref-Pascal2017" class="csl-entry" role="listitem">
Lacour, C., P. Massart, and V. Rivoirard. 2017. <span>“Estimator Selection: A New Method with Applications to Kernel Density Estimation.”</span> <em>Sankhya A</em> 79: 298–335.
</div>
<div id="ref-LI2022104806" class="csl-entry" role="listitem">
Li, Yehua, Yumou Qiu, and Yuhang Xu. 2022. <span>“From Multivariate to Functional Data Analysis: Fundamentals, Recent Developments, and Emerging Areas.”</span> <em>Journal of Multivariate Analysis</em> 188: 104806.
</div>
<div id="ref-Liebl2019" class="csl-entry" role="listitem">
Liebl, D, and M. Reimherr. 2023. <span>“Fast and Fair Simultaneous Confidence Bands for Functional Parameters.”</span> <em>Journal of the Royal Statistical Society Series B: Statistical Methodology</em> 85: 842–68.
</div>
<div id="ref-Neumann1998" class="csl-entry" role="listitem">
Neumann, M., and J. Polzehl. 1998. <span>“Simultaneous Bootstrap Confidence Bands in Nonparametric Regression.”</span> <em>J Nonparametr Statist</em> 9: 307–33.
</div>
<div id="ref-Quinton-2017-escon" class="csl-entry" role="listitem">
Quinton, J-C., E. Devijver, A. Leclercq-Samson, and A. Smeding. 2017. <span>“Functional Mixed Effect Models for Mouse-Tracking Data in Social Cognition.”</span> In <em>ESCON Transfer of Knowledge Conference, Gdansk, Polland</em>.
</div>
<div id="ref-CB_survivalAnalysis2022" class="csl-entry" role="listitem">
Sachs, Michael C., Adam Brand, and Erin E. Gabriel. 2022. <span>“Confidence Bands in Survival Analysis.”</span> <em>The British Journal of Cancer. Supplement</em> 127: 1636–41.
</div>
<div id="ref-sun1994" class="csl-entry" role="listitem">
Sun, Jiayang, and Clive R. Loader. 1994. <span>“Simultaneous Confidence Bands for Linear Regression and Smoothing.”</span> <em>Ann. Statist.</em> 22 (3): 1328–45.
</div>
<div id="ref-Telschow2023" class="csl-entry" role="listitem">
Telschow, Fabian J. E., Dan Cheng, Pratyush Pranav, and Armin Schwartzman. 2023. <span>“<span class="nocase">Estimation of expected Euler characteristic curves of nonstationary smooth random fields</span>.”</span> <em>The Annals of Statistics</em> 51 (5): 2272–97.
</div>
<div id="ref-TELSCHOW202270" class="csl-entry" role="listitem">
Telschow, Fabian J. E., and Armin Schwartzman. 2022. <span>“Simultaneous Confidence Bands for Functional Data Using the Gaussian Kinematic Formula.”</span> <em>Journal of Statistical Planning and Inference</em> 216: 70–94.
</div>
<div id="ref-wang2022" class="csl-entry" role="listitem">
Wang, L. And Yang, J. And Gu. 2022. <span>“Oracle-Efficient Estimation for Functional Data Error Distribution with Simultaneous Confidence Band.”</span> <em>Computational Statistics &amp; Data Analysis</em> 167: 107363.
</div>
<div id="ref-Xia1998" class="csl-entry" role="listitem">
Xia, Y. 1998. <span>“Bias-Corrected Confidence Bands in Nonparametric Regression.”</span> <em>J.R. Stat. Soc. Ser. B</em> 60: 797–811.
</div>
<div id="ref-Zhang2020" class="csl-entry" role="listitem">
Zhang, C. And Wu, Y. And Wang. 2020. <span>“Prediction of Working Memory Ability Based on <span>EEG</span> by Functional Data Analysis.”</span> <em>J Neur. Meth.</em> 333: 108552.
</div>
<div id="ref-Zhou1998" class="csl-entry" role="listitem">
Zhou, S., X. Shen, and D. A. Wolfe. 1998. <span>“Local Asymptotics for Regression Splines and Confidence Regions.”</span> <em>Ann. Statist.</em> 26: 1760–82.
</div>
</div>
</section>
<section id="appendix-proofs" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Appendix: proofs</h1>
<section id="proof-of-prp-error" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="proof-of-prp-error"><span class="header-section-number">9.1</span> Proof of <a href="#prp-error" class="quarto-xref">Proposition&nbsp;3</a></h2>
<p>Let us prove the first point. We have <span class="math display"> \mathbb{E}(\hat{\underline{\mu}}^{L,L^\star}) = (\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbb{E}(\mathbf{y}) =(\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbf{B}_{L^*}\mu^{L^*}=:\underline{\mu}^{L,L^\star}.</span></p>
<p>The theory of the linear model gives that the variance of <span class="math inline">\hat{\underline{\mu}}^L</span> is equal to <span class="math inline">\sigma^2 (\mathbf{B}^T\mathbf{B})^{-1} \mathbf{B}^T\Sigma \mathbf{B}(\mathbf{B}^T\mathbf{B})^{-1}</span> with <span class="math inline">\Sigma=Diag(\Sigma_1, \ldots, \Sigma_N)</span> the <span class="math inline">nN \times nN</span> covariance matrix of <span class="math inline">\mathbf{y}</span>. So finally, we have</p>
<p><span class="math display">
\hat{\underline{\mu}}^{L,L^\star}
\sim \mathcal{N}\left(\underline{\mu}^{L,L^\star}, \sigma^2\Sigma_{B}^{L, L^ \varepsilon}
\right).
</span></p>
<p>Now we can easily deduce the distribution of <span class="math inline">\hat{\underline{f}}^{L,L^*}(t)</span>, for each <span class="math inline">t\in [0,1]</span>: <span class="math display">\hat{\underline{f}}^{L,L^*}(t)- \mathbf f^{L,L^*}(t) \sim \mathcal{N}\left(0, \sigma^2 B(t)\Sigma_{B}^{L, L^\varepsilon} B(t)^T\right).</span></p>
<p><span style="color: red;">To prove that</span> <span class="math inline">(\hat{\underline{f}}^{L, L^*}-f^{L,L^*})()</span> <span style="color: red;">is a Gaussian process, we consider any finite sequence of times</span>, <span class="math inline">(t_1, \ldots, t_d)\in [0,1]</span>. <span style="color: red;">The sequence</span> <span class="math inline">(\hat{\underline{f}}^{L, L^*}(t_1)-f^{L,L^*}(t_1), \ldots, \hat{\underline{f}}^{L, L^*}(t_d)-f^{L,L^*}(t_d))</span> <span style="color: red;">is Gaussian, centered and the covariance is equal to</span> <span class="math inline">cov(\hat{\underline{f}}^{L, L^*}(t_1)-f^{L,L^*}(t_1), \hat{\underline{f}}^{L, L^*}(t_2)-f^{L,L^*}(t_2)) = \sigma^2 B(t_1)\Sigma_{B}^{L, L^\varepsilon} B(t_2)^T</span>. <span style="color: red;">Thus the process is Gaussian.</span></p>
</section>
<section id="proof-of-thm-cb_liebl_asymptotic" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="proof-of-thm-cb_liebl_asymptotic"><span class="header-section-number">9.2</span> Proof of <a href="#thm-CB_Liebl_asymptotic" class="quarto-xref">Theorem&nbsp;2</a></h2>
<p>We have <span class="math display">P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-\underline{f}^{L, L^*}(t)+ \underline{f}^{L, L^*}(t)- f^{L,L^*}(t)| \leq \hat d^L(t))</span></p>
<p>Set Assumption 1 and Assumption 3 and a probability <span class="math inline">\alpha\in [0,1]</span>. Then, we have, <span class="math display">\lim_{n \rightarrow +\infty} P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = 1-\alpha</span> with <span class="math inline">\hat d^L(t) = \hat c^L \sqrt{\hat C_L(t,t)/N}</span> and <span class="math inline">\hat c^L</span> defined as the solution of <a href="#eq-cL" class="quarto-xref">Equation&nbsp;4</a>.</p>
</section>
<section id="proof-of-prp-cbf" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="proof-of-prp-cbf"><span class="header-section-number">9.3</span> Proof of <a href="#prp-CBf" class="quarto-xref">Proposition&nbsp;5</a></h2>
<p>To simplify the notations, let us denote <span class="math inline">a(t) = \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t)</span> and <span class="math inline">b(t) = \underline{f}^{L_{\max},L^*}(t)- \underline{f}^{L,L^*}(t)-(\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L,L^*}(t))</span>. We have <span class="math display">\begin{align*}
P\left( \exists t |a(t)+b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right) &amp;\leq
P\left( \exists t |a(t)|+|b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right)\\
&amp;= P\left( \exists t |a(t)| \geq \hat d_1^L(t) \right)P\left( \exists t |b(t)|\geq \hat d_2^{L,L_{\max}}(t)\right) = \alpha\beta.
\end{align*}</span></p>
<p>The last equality holds thanks to the independence of the two sub-samples.</p>
</section>
</section>
<section id="appendix-more-experiments" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> Appendix: more experiments</h1>
<p><a href="#prp-proj" class="quarto-xref">Proposition&nbsp;1</a> and <a href="#prp-proj2" class="quarto-xref">Proposition&nbsp;2</a> are illustrated in <a href="#fig-coefficients" class="quarto-xref">Figure&nbsp;10</a>. The true dimension is <span class="math inline">L^*=11</span>. Three families are considered, Fourier, Legendre and Splines. The plots display the absolute difference between the coefficients <span class="math inline">\mu_\ell^{L^*}</span> and the projected coefficients <span class="math inline">\underline{\mu}^{L,L^*}</span>, for different <span class="math inline">\ell</span> in x-axis and for different values of <span class="math inline">L</span> and <span class="math inline">n</span> in the y-axis, namely a case with <span class="math inline">L&lt;L^*</span> and two values of <span class="math inline">n</span>: <span class="math inline">L=7, n=20</span> and <span class="math inline">L=7, n=100</span>; and a case with <span class="math inline">L&gt;L^*</span> and two values of <span class="math inline">n</span>: <span class="math inline">L=15, n=20</span> and <span class="math inline">L=15, n=100</span>. The absolute difference is represented as a gradient of color, this gradient being adapted to each functional family. We can see that as Legendre (resp. Fourier) are orthonormal (resp. orthogonal) families, the differences are close to <span class="math inline">0</span> when <span class="math inline">L=15</span>, whatever the values of <span class="math inline">n</span>. When <span class="math inline">L&lt;L^*</span>, the difference is close to <span class="math inline">0</span> when <span class="math inline">n</span> is large. This property does not hold for the spline family, which is not orthogonal.</p>
<div class="cell">
<details class="code-fold">
<summary>Hide/Show the code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RColorBrewer)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">=</span> <span class="fu">brewer.pal</span>(<span class="dv">9</span>, <span class="st">"BuPu"</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>pal <span class="ot">&lt;-</span> <span class="fu">colorRampPalette</span>(cols)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>L.star <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>Time <span class="ot">=</span> <span class="fu">seq</span>(data<span class="sc">$</span>time[<span class="dv">1</span>], data<span class="sc">$</span>time[<span class="fu">length</span>(data<span class="sc">$</span>time)], <span class="at">length.out =</span> <span class="dv">100</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>L.star <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">7</span>,<span class="dv">15</span>)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Fourier"</span>, <span class="st">"Legendre"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">20</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">2</span><span class="sc">*</span><span class="dv">1</span>,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> { data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">20</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  alpha.tot <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    B.n.large <span class="ot">=</span> <span class="fu">func.basis</span>(Time, L, basis)</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    B.Lstar.n.large <span class="ot">=</span> <span class="fu">func.basis</span>(Time, L.star, basis)</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    alpha.true.L <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    alpha.true.L.n.large <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.n.large) <span class="sc">%*%</span> B.n.large) <span class="sc">%*%</span> <span class="fu">t</span>(B.n.large) <span class="sc">%*%</span> B.Lstar.n.large <span class="sc">%*%</span> data<span class="sc">$</span>alpha.mu</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    alpha.tot <span class="ot">=</span> <span class="fu">cbind</span>(alpha.tot, alpha.true.L[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))]<span class="sc">-</span>data<span class="sc">$</span>alpha.mu[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))], alpha.true.L.n.large[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))] <span class="sc">-</span> data<span class="sc">$</span>alpha.mu[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))])</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">image.plot</span>(<span class="fu">abs</span>(alpha.tot), <span class="at">main =</span> <span class="fu">paste0</span>(basis, <span class="st">"'s basis"</span>), <span class="at">col =</span> <span class="fu">pal</span>(<span class="dv">20</span>), <span class="at">yaxt=</span><span class="st">"n"</span>, <span class="at">xaxt =</span> <span class="st">"n"</span>, <span class="at">xlab =</span> <span class="st">"index of the basis"</span> )</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">axis</span>(<span class="dv">2</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length =</span> <span class="fu">ncol</span>(alpha.tot)), <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"L=7, n=20"</span>, <span class="st">"L=7, n=100"</span>, <span class="st">"L=15, n=20"</span>, <span class="st">"L=15, n=100"</span>), <span class="at">las =</span> <span class="dv">2</span>, <span class="at">cex.axis =</span> <span class="fl">0.6</span>)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">axis</span>(<span class="dv">1</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">length.out =</span> <span class="dv">7</span>), <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>, <span class="st">"4"</span>, <span class="st">"5"</span>, <span class="st">"6"</span>, <span class="st">"7"</span>))</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-coefficients" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-coefficients-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="ConfBand_files/figure-html/fig-coefficients-1.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-coefficients-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Illustrative example. The true dimension is 11, we generate the coefficients with three families, Fourier (which is orthogonal), Legendre (which is orthonormal) and the splines (which are not orthogonal wrt the standard scalar product). In the y-axis, two dimensions of the family (7 or 15) and two numbers of timepoints (20 or 100) are compared. We plot in x-axis the value of the absolute difference between the true coefficients and their approximations for the first 7 coefficients of the basis. The color scale is adapted to each functional basis.
</figcaption>
</figure>
</div>
</div>
</div>
<!-- -->

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{devijver2024,
  author = {Devijver, Emilie and Samson, Adeline},
  publisher = {Société Française de Statistique},
  title = {Should We Correct the Bias in {Confidence} {Bands} for
    {Repeated} {Functional} {Data?}},
  journal = {Computo},
  date = {2024-12-08},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {While confidence intervals for finite quantities are
    well-established, constructing confidence bands for objects of
    infinite dimension, such as functions, poses challenges. In this
    paper, we explore the concept of parametric confidence bands for
    functional data with an orthonormal basis. Specifically, we revisit
    the method proposed by Sun and Loader, which yields confidence bands
    for the projection of the regression function in a fixed-dimensional
    space. This approach can introduce bias in the confidence bands when
    the dimension of the basis is misspecified. Leveraging this insight,
    we introduce a corrected, unbiased confidence band. Surprisingly,
    our corrected band tends to be wider than what a naive approach
    would suggest. To address this, we propose a model selection
    criterion that allows for data-driven estimation of the basis
    dimension. The bias is then automatically corrected after dimension
    selection. We illustrate these strategies using an extensive
    simulation study. We conclude with an application to real data.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-devijver2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Devijver, Emilie, and Adeline Samson. 2024. <span>“Should We Correct the
Bias in Confidence Bands for Repeated Functional Data?”</span>
<em>Computo</em>, December. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb19" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Should we correct the bias in Confidence Bands for Repeated Functional Data?"</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Emilie Devijver</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">    email: emilie.devijver@univ-grenoble-alpes.fr</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://lig-aptikal.imag.fr/~devijvee/</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: CNRS, Univ. Grenoble Alpes, Grenoble INP, LIG, 38000 Grenoble, France</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Adeline Samson</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co">    email: adeline.leclercq-samson@univ-grenoble-alpes.fr</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://adeline.e-samson.org</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Univ. Grenoble Alpes, CNRS, Grenoble INP, LJK, 38000 Grenoble, France</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="co"> While confidence intervals for finite quantities are well-established, constructing confidence bands for objects of infinite dimension, such as functions, poses challenges. In this paper, we explore the concept of parametric confidence bands for functional data with an orthonormal basis. Specifically, we revisit the method proposed by Sun and Loader, which yields confidence bands for the projection of the regression function in a fixed-dimensional space. This approach can introduce bias in the confidence bands when the dimension of the basis is misspecified. Leveraging this insight, we introduce a corrected, unbiased confidence band. Surprisingly, our corrected band tends to be wider than what a naive approach would suggest. To address this, we propose a model selection criterion that allows for data-driven estimation of the basis dimension. The bias is then automatically corrected after dimension selection. We illustrate these strategies using an extensive simulation study. We conclude with an application to real data.</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [functional data, repeated data, confidence band, Kac-Rice formulae, bias, dimension selection]</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "template-computo-r"</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>colorize <span class="ot">&lt;-</span> <span class="cf">function</span>(x, color) {</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span> (knitr<span class="sc">::</span><span class="fu">is_latex_output</span>()) {</span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a> <span class="fu">sprintf</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">textcolor{%s}{%s}"</span>, color, x)</span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a> } <span class="cf">else</span> <span class="cf">if</span> (knitr<span class="sc">::</span><span class="fu">is_html_output</span>()) {</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a> <span class="fu">sprintf</span>(<span class="st">"&lt;span style='color: %s;'&gt;%s&lt;/span&gt;"</span>, color,</span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a> x)</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a> } <span class="cf">else</span> x</span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-53"><a href="#cb19-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-54"><a href="#cb19-54" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a>Functional data analysis is widely used for handling complex data with smooth shapes, finding applications in diverse fields such as neuroscience (e.g., EEG data, @Zhang2020), psychology (e.g., mouse-tracking data, @Quinton-2017-escon), and sensor data from daily-life activities (@jacques2022).</span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a>We consider <span class="in">`r colorize("several", "red")`</span> <span class="co">&lt;!-- multiple --&gt;</span> independent observations of the same function, <span class="in">`r colorize("i.e.", "red")`</span> <span class="co">&lt;!-- yielding--&gt;</span> noisy functional data. To analyze <span class="in">`r colorize("this", "red")`</span> <span class="co">&lt;!-- such--&gt;</span> data, a  <span class="in">`r colorize("classic", "red")`</span><span class="co">&lt;!-- common --&gt;</span> approach <span class="co">&lt;!-- , typically in the parametric setting,--&gt;</span> involves projecting the data onto a functional space defined by a family of functions (@LI2022104806, @kokoszka2017introduction Chapter 3). When the family <span class="in">`r colorize("is", "red")`</span> an orthonormal basis, e.g.,  <span class="in">`r colorize("the","red")`</span>  Legendre  <span class="in">`r colorize("basis", "red")`</span> (with the standard scalar product) or Fourier (with another scalar product), the projection is  <span class="in">`r colorize("explicit and it is possible to obtain theoretical results.", "red")`</span> <span class="co">&lt;!-- clearly understood. !--&gt;</span>  <span class="in">`r colorize("However, some families, such as splines, are not orthonormal for the standard scalar product.", "red")`</span>  <span class="co">&lt;!--But families such as splines are not orthonormal for the standard scalar product !--&gt;</span> <span class="in">`r colorize("We will discuss the impact of the choice of this family on  estimation. We explain why the use of a ", "red")`</span> <span class="co">&lt;!-- leveraging an approximate !--&gt;</span> functional space offers a key advantage: it  <span class="in">`r colorize("reduces the problem of inference to the estimation of", "red")`</span> <span class="co">&lt;!--simplifies the inference problem to estimating!--&gt;</span> coefficients, for example  <span class="in">`r colorize("by", "red")`</span>  <span class="co">&lt;!--through methods like!--&gt;</span> least squares or maximum likelihood estimation.  <span class="in">`r colorize("The function estimator is then simply an average after projection onto the functional base.", "red")`</span> <span class="co">&lt;!--Subsequently, the function is estimated as the mean of the functional data following projection onto the functional basis.!--&gt;</span> <span class="in">`r colorize("It is  important to accompany the function estimate with a measure of the uncertainty of that estimate, usually", "red")`</span> <span class="co">&lt;!-- Measuring the uncertainty of an estimator is usually done! --&gt;</span> using confidence intervals <span class="in">`r colorize("or bands", "red")`</span>. In this paper,  <span class="in">`r colorize("we focus on constructing", "red")`</span>  <span class="co">&lt;!--our focus lies specifically on providing!--&gt;</span> a simultaneous confidence band for the  <span class="in">`r colorize("mean of the", "red")`</span> function<span class="co">&lt;!-- means !--&gt;</span>, rather than point-wise confidence intervals. This task presents several challenges: the confidence band must effectively control the simultaneous functional type-I error rate, as opposed to point-wise rates; it must strike a balance between being sufficiently conservative to maintain a confidence level while not being overly so as to render it meaningless; and the method used to construct this confidence band should be computationally feasible for practical application.</span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>Several developments have already been proposed to answer these questions. First, <span class="in">`r colorize("let us", "red")`</span> consider the case <span class="in">`r colorize("of a single", "red")`</span> <span class="co">&lt;!--with only one!--&gt;</span> individual (no repetition) but with many time points. Some methods study the asymptotic distribution of the infinity norm between the true function and its estimator. The asymptotics in the number of time points is studied in @Hall1991, @Claeskens2003. This approach only works for large datasets in time and is likely to be too conservative otherwise. For small samples, bootstrap methods have been developed to compute the confidence band (@Neumann1998, @Claeskens2003), but with a high computational cost. Another approach is to construct confidence bands based on the volume of the tube formula. @sun1994 studied the tail probabilities of suprema of Gaussian random processes. This approach is based on an unbiased linear estimator of the regression function. @Zhou1998 used the volume-of-tube formula for estimation by regression splines. @Krivobokova2010 used this method for the construction of confidence bands by penalized spline estimators. They proposed to mix Bayesian and frequentist approaches, <span class="in">`r colorize("in order to obtain", "red")`</span> <span class="co">&lt;!--to get!--&gt;</span> the good properties <span class="in">`r colorize("of", "red")`</span> <span class="co">&lt;!--from!--&gt;</span> the Bayesian world <span class="in">`r colorize("while", "red")`</span> <span class="co">&lt;!--but!--&gt;</span> reducing the variability to be less conservative using the frequentist approach. The bias is <span class="in">`r colorize("taken into account by", "red")`</span> <span class="co">&lt;!--considered through!--&gt;</span> spline modeling, assuming <span class="in">`r colorize("that enough", "red")`</span> <span class="co">&lt;!--sufficient!--&gt;</span> knots are considered. </span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-64"><a href="#cb19-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-65"><a href="#cb19-65" aria-hidden="true" tabindex="-1"></a>Some papers, like ours, rely on several observations of the same function.  @Liebl2019 <span class="co">&lt;!--have!--&gt;</span> proposed a method based <span class="in">`r colorize("on the Kac-rice formula, ", "red")`</span> random field theory and the volume-of-tube formula. They provide a band with locally varying widths using an unbiased estimator. Their method does not require <span class="co">&lt;!--the!--&gt;</span> estimation of the full covariance function of the estimator, but only its diagonal. This reduces the computational time. From a practical viewpoint, @CB_survivalAnalysis2022 introduced a package to popularize simultaneous confidence bands, in the context of survival analysis.  @bunea2011 propose a threshold-type estimator and derive error bounds and simultaneous confidence bands, having an unbiased estimator. @TELSCHOW202270 propose a simultaneous confidence band based on the Gaussian kinematic formula. Again, it assumes access to an <span class="in">`r colorize("asymptotically", "red")`</span> unbiased estimator of the function of interest. <span class="in">`r colorize("The coverage will thus be guaranteed in the asymptotic setting after removing the bias,  by smoothing the data for example. Their paper considers the non-gaussian and non-stationary cases.", "red")`</span> @wang2022 proposed    a simultaneous Kolmogorov-Smirnov confidence band by modeling the error distribution, thus avoiding the estimation of the covariance structure of the underlying stochastic process. They rely on B-splines for the estimation of the mean curve.</span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a>Note that recent extensions have been proposed, <span class="in">`r colorize("based on Lipschitz-Killing-Curvatures estimators", "red")`</span> <span class="co">&lt;!--to nonstationary random field !--&gt;</span> in @Telschow2023, based on conformal prediction in @conformalPrediction2022, or having a prediction goal in mind in @Jacques2023 by considering functional time series data set. <span class="co">&lt;!-- These extensions are out of the scope of this paper, focusing on the simple functional case. !--&gt;</span> </span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>One limitation of all those approaches is that they do not <span class="co">&lt;!-- generally !--&gt;</span> <span class="in">`r colorize("clearly", "red")`</span> take into account the bias of the functional estimator. <span class="in">`r colorize("Taking account of bias is particularly important when working in a non-asymptotic context.", "red")`</span> @sun1994 proposed a bias correction for a particular class of functions but left the smoothing parameter choice open, leading to an unusable estimator. In the nonparametric framework, the bias is approximated using the estimator of the second derivative of the underlying mean function (@Xia1998). But in general, there is a lack of discussion on how to handle the bias of the functional estimator, even in the simple case of a functional space of finite dimension. </span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("Another issue is the selection of the dimension of the basis. Hard-thresholding approaches, cross-validation methods", "red")`</span> (@LI2022104806) <span class="in">`r colorize("or model selection framework could be used to select the best dimension.", "red")`</span> </span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a> <span class="in">`r colorize("However, these approaches need to be adapted to the specific case of controlling the level of a confidence band. Few references exist on this subject.  For example,  while the model selection paradigm has been extensively studied in the literature, in multivariate statistics or functional data analysis (e.g.,", "red")`</span> @GoeppSubmitted, @ANEIROS2022104871, @BASNA2022104868), <span class="in">`r colorize("it has not been explored in the context of confidence band construction.", "red")`</span></span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a>The objective of this paper is to address the bias problem in confidence band construction for a general function, <span class="in">`r colorize("in the non-asymptotic setting", "red")`</span>, utilizing a finite functional orthonormal family <span class="in">`r colorize("and to select the best band.", "red")`</span> Our contributions are as follows:</span>
<span id="cb19-76"><a href="#cb19-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-77"><a href="#cb19-77" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>we disentangle the bias issue by explicitly defining the parameter of interest within the approach of @sun1994;</span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>we propose a bias correction method in a new confidence band for the function of interest. <span class="in">`r colorize("This provides a collection of debiased confidence bands. We also propose a criteria to select the best band, by splitting the sample into two sub-samples", "red")`</span></span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="co">&lt;!-- Finally !--&gt;</span>  </span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("to avoid the loss of precision due to sample splitting,", "red")`</span>  we propose a second heuristic method for selecting the dimension of the approximation space, treating it as a model selection problem, with a trade-off between conservatism and confidence level assurance; <span class="in">`r colorize("this approach does not  correct the bias of each band of the collection but selects a band with a negligible bias;", "red")`</span></span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>we illustrate <span class="co">&lt;!-- this confidence band, concluding on the conservatism of the procedure !--&gt;</span> <span class="in">`r colorize("the proposed strategies and compare them to cross-validation or threshold approaches", "red")`</span>;</span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`r colorize("we also illustrate the impact of the choice of the functional family, including non-orthonormal families.", "red")`</span> </span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-86"><a href="#cb19-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-87"><a href="#cb19-87" aria-hidden="true" tabindex="-1"></a>The paper is organized as follows: @sec-model introduces the functional regression model, the considered functional family and the corresponding approximate regression models, as well as an estimator defined in the finite space, along with descriptions of the error terms. In @sec-bandSun, we propose a confidence band for the approximate regression function in the space of finite dimension, where the dimension is fixed. @sec-band2 proposes a strategy to construct a confidence band for the true function. This last confidence band being too conservative, @sec-modsel introduces a model selection criterion to select the best confidence band, doing a trade-off between conservatism and confidence level assurance. @sec-simulation <span class="in">`r colorize(" illustrates the different estimating procedures of the confidence band.", "red")`</span>  @sec-realdata <span class="in">`r colorize(" proposes an application on real data.", "red")`</span> @sec-conc ends the paper by a conclusion and discussion of perspectives. </span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--The different estimation procedures are illustrated throughout the sections. !--&gt;</span></span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a><span class="fu"># Statistical Model {#sec-model}</span></span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>In this paper, we consider time series as discrete measurements of functional curves. We first present the general functional regression model (@sec-functional_model) where the regression function belongs to a finite functional family of dimension $L^*$. </span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a>In practice, this dimension $L^*$ is unknown and we will work on functional space of dimension $L$. The regression model on the finite family of functions is presented in @sec-projection_model, and an estimator is proposed in @sec-estim, with a description of the error terms. </span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a> <span class="in">`r colorize(" In the rest of the paper, we consider the space ", "red")`</span> $L^2(<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>)$ with its standard scalar product $&lt;f_1,f_2&gt; = \int_0^1 |f_1(t)f_2(t)|dt$, for $f_1,f_2 \in L^2(<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>)$. The notation $Vect$ denotes the linear span.</span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>\bigskip</span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a><span class="fu">## Functional regression model {#sec-functional_model}</span></span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>Let $y_{ij}$ be the measure at fixed time $t_{j} \in <span class="co">[</span><span class="ot">a,b</span><span class="co">]</span>$ for individual $i=1, \ldots, N$, with $j=1, \ldots, n$. <span class="in">`r colorize("The case with time observations dependent of the individuals is a natural extension of this case, but introduces a bias through the interpolation that is not easy to take into account. ", "red")`</span> We restrict ourselves to $<span class="co">[</span><span class="ot">a,b</span><span class="co">]</span> = <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, without loss of generality. </span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a>We assume these observations are discrete-time measurements of individual curves, which are independent and noisy realisations of a common function $f$ that belongs to a functional space. Thus for each individual $i$, we consider the following functional regression model</span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>y_{ij} = f(t_{j}) + \varepsilon_{ij}, </span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a>where $\varepsilon_{i.}=(\varepsilon_{i1}, \ldots, \varepsilon_{in})$ is the <span class="in">`r colorize("measurement", "red")`</span> noise <span class="co">&lt;!-- representing the individual functional variation around $f$.</span></span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a><span class="co">We !--&gt;</span>assuming that the $\varepsilon_{i}$ are independent. <span class="co">&lt;!-- Their distribution is detailed below. !--&gt;</span> </span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a>For each individual $i=1, \ldots, N$, we denote $y_{i.}=(y_{i1}, \ldots, y_{in})$ <span class="co">&lt;!-- the $n\times 1$ vector of observations !--&gt;</span>, $t_{.}=(t_{1}, \ldots, t_{n})$ <span class="co">&lt;!-- the $n \times 1$ vector of observation times !--&gt;</span> and $f(t_{.})=(f(t_{1}), \ldots, f(t_{n}))$ the $n \times 1$ vectors of the <span class="in">`r colorize(" observations, times and ", "red")`</span> function $f$ evaluated in $t_{.}$, respectively. We also denote $\mathbf{y} = (y_{1.}, \ldots, y_{N.})$ the whole matrix of observations. </span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-110"><a href="#cb19-110" aria-hidden="true" tabindex="-1"></a>Let us introduce the functional space $\mathcal{S}^{L^*} = Vect((t \mapsto B_\ell^{L^*}(t))_{1\leq \ell \leq L^*})$ with $L^*$ functions $(B_\ell^{L^*})_{1\leq \ell \leq L^*}$ assumed to be linearly independent.</span>
<span id="cb19-111"><a href="#cb19-111" aria-hidden="true" tabindex="-1"></a>Then, for any $f \in \mathcal{S}^{L^*}$, there exists a unique vector of coefficients $(\mu_{\ell}^{L^*})_{1\leq \ell \leq L^*}$ such that, for all $t$, $f(t) = \sum_{\ell =1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t)$. </span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a>The regression function $f$ verifies the following assumption:</span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a>***Assumption 1.***</span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a>The function $f$ belongs to the space $\mathcal{S}^{L^*}$ of dimension $L^*$. It is denoted ${f}^{L^*}$ and defined as:</span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a>$$f(t) = {f}^{L^*}(t) = \sum_{\ell = 1}^{L^*} \mu_\ell^{L^*} B^{L^*}_\ell(t). $$</span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-118"><a href="#cb19-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-119"><a href="#cb19-119" aria-hidden="true" tabindex="-1"></a>Many functional spaces are available in the literature, as Splines, Fourier or Legendre families. We introduce the following assumption:</span>
<span id="cb19-120"><a href="#cb19-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-121"><a href="#cb19-121" aria-hidden="true" tabindex="-1"></a>***Assumption 2.***</span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a>The functional family $(t \mapsto B^{L^*}_\ell(t))_{1\leq \ell\leq L^*}$ is orthonormal with respect to the standard scalar product $&lt;.,.&gt;$. </span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a>Note that if Assumption 2 holds, one get $\mu_\ell^{L^*} = &lt;{f}^{L^*},B^{L^*}_\ell&gt;$ for $\ell = 1,\ldots, L^*$. </span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a>The Legendre family is orthonormal, the Fourier family is orthogonal for the standard scalar product (but not orthonormal), and the B-splines family is not orthogonal. <span class="in">`r colorize(" We will illustrate the impact of using one family or the other.", "red")`</span> </span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a>We also consider a functional noise through the following assumption. </span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a>***Assumption 3.***</span>
<span id="cb19-131"><a href="#cb19-131" aria-hidden="true" tabindex="-1"></a>The sequence $\varepsilon_{i}$ is functional and <span class="in">`r colorize(" allows Karhunen-Loève $L^2$ representation:", "red")`</span> </span>
<span id="cb19-132"><a href="#cb19-132" aria-hidden="true" tabindex="-1"></a>there exists a sequence of coefficients $(c_{i\ell})_{1\leq \ell}$ such that</span>
<span id="cb19-133"><a href="#cb19-133" aria-hidden="true" tabindex="-1"></a>$$\varepsilon_{ij} = \sum_{\ell \geq 1} c_{i\ell} \phi_\ell(t_{j}),$$</span>
<span id="cb19-134"><a href="#cb19-134" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("where the functions", "red")`</span> $(\phi_\ell)_{1\leq L}$ `r colorize(" can be written through eigenvalues and eigenfunctions of the covariance matrix ", "red")` $cov(\varepsilon_{ij}, \varepsilon_{ij'})$.</span>
<span id="cb19-135"><a href="#cb19-135" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("Practically, we assume this sum to be finite, as done for example in ", "red")`</span> @Chen2015: there exists  $L^\varepsilon$ such that $$\varepsilon_{ij} = \sum_{1 \leq L \leq L^\varepsilon} c_{i\ell} \phi_\ell(t_{j}),$$</span>
<span id="cb19-136"><a href="#cb19-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-137"><a href="#cb19-137" aria-hidden="true" tabindex="-1"></a>We also assume that the coefficients are Gaussian: for all $i=1,\ldots, N$ and $\ell=1, \ldots, L^\varepsilon$,</span>
<span id="cb19-138"><a href="#cb19-138" aria-hidden="true" tabindex="-1"></a>$$c_{i \ell} \sim_{iid} \mathcal{N}(0,\sigma^2).$$ </span>
<span id="cb19-139"><a href="#cb19-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-140"><a href="#cb19-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-141"><a href="#cb19-141" aria-hidden="true" tabindex="-1"></a>Assumption 1 and Assumption 3 imply that each curve $y_i$ belongs to a finite family: for $j=1,\ldots,n$,</span>
<span id="cb19-142"><a href="#cb19-142" aria-hidden="true" tabindex="-1"></a>$$ y_{ij} = \sum_{\ell=1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t_{j}) + \sum_{\ell=1}^{L^\varepsilon} c_{i\ell} \phi_\ell(t_{j}). $$</span>
<span id="cb19-143"><a href="#cb19-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-144"><a href="#cb19-144" aria-hidden="true" tabindex="-1"></a>As the observations are recorded at discrete time points $(t_j)_{1\leq j \leq n}$, &lt;!--we introduce the family of functions evaluated at the discrete times of observations. For!--&gt; for $L\in \mathbb{N}$, let us denote $\mathbf{B}^L$ the matrix of $n\times L$ with coefficient in row $j$ and column $\ell$ equal to $B^L_\ell(t_{j})$, `r colorize("and the basis for the noise", "red")` $\Phi^{L^\varepsilon} = (\phi_\ell(t_j))_{1\leq \ell \leq L^\varepsilon, 1\leq j \leq n}$. </span>
<span id="cb19-145"><a href="#cb19-145" aria-hidden="true" tabindex="-1"></a>Let us introduce $c_{i.}=(c_{i1}, \ldots, c_{iL^\varepsilon})$ the $L^\varepsilon \times 1$ vector. Then $\varepsilon_{i.} = \Phi^{L^\varepsilon} c_{i.}$. </span>
<span id="cb19-146"><a href="#cb19-146" aria-hidden="true" tabindex="-1"></a>The vectors $y_{i.} \in \mathbb{R}^n$ are thus independent and $y_i\sim \mathcal{N}_n(f(t_{.}), \sigma^2 \Sigma^{L^\varepsilon})$ with $\Sigma^{L^\varepsilon} = \Phi^{L^\varepsilon} (\Phi^{L^\varepsilon})^T$.</span>
<span id="cb19-147"><a href="#cb19-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-148"><a href="#cb19-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-149"><a href="#cb19-149" aria-hidden="true" tabindex="-1"></a>The objective of this paper is to construct a tight confidence bound for $f^{L^*}$ using data $(y_{ij})_{ij}$. </span>
<span id="cb19-150"><a href="#cb19-150" aria-hidden="true" tabindex="-1"></a>The main challenge is that the true dimension $L^*$ is unknown. In the rest of the paper, we will work with a collection of models defined on a finite family of dimension $L$ with $L\in \{L_{\min}, \ldots, L_{\max}\}$, $L_{\max}$ being chosen to be sufficiently large by the user, expecting that $L^*\leq L_{\max}$. $L_{\max}$ <span class="in">`r colorize("has to be large enough to do overfitting.", "red")`</span>  Then we will propose different strategies to choose the best bandwidth among the different collections. </span>
<span id="cb19-151"><a href="#cb19-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-152"><a href="#cb19-152" aria-hidden="true" tabindex="-1"></a>First, in @sec-projection_model and @sec-estim, we define for a fixed $L$ the corresponding regression model and its estimator. Then @sec-bandSun, @sec-band2 and @sec-modsel will introduce the different bandwidths. </span>
<span id="cb19-153"><a href="#cb19-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-154"><a href="#cb19-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-155"><a href="#cb19-155" aria-hidden="true" tabindex="-1"></a><span class="fu">## Approximation of the model on a finite family {#sec-projection_model}</span></span>
<span id="cb19-156"><a href="#cb19-156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-157"><a href="#cb19-157" aria-hidden="true" tabindex="-1"></a>Let $f^{L^*} \in \mathcal{S}^{L^*}$ with $L^*$ unknown, and consider the space $\mathcal{S}^L$ for $L$ fixed in $<span class="sc">\{</span>L_{\min}, \ldots, L_{\max}<span class="sc">\}</span>$. </span>
<span id="cb19-158"><a href="#cb19-158" aria-hidden="true" tabindex="-1"></a>As $\mathcal{S}^L$ is a family of linearly independent functions, there <span class="in">`r colorize("is", "red")`</span> always <span class="co">&lt;!--exists!--&gt;</span> a unique vector $\mu^{L,L^*}$ of coefficients defining $f^{L,L^*}(t) = \sum_{\ell_=1}^L \mu_\ell^{L,L^*} B_\ell^L(t)=B^L(t) \mu^{L,L^*}$ such that</span>
<span id="cb19-159"><a href="#cb19-159" aria-hidden="true" tabindex="-1"></a>$$f^{L,L^*} = \arg\min_{f \in \mathcal{S}^L}\{\|f^{L^*} - f\|_2^2<span class="sc">\}</span>.$$</span>
<span id="cb19-160"><a href="#cb19-160" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--and if !--&gt;</span>  <span class="in">`r colorize("If", "red")`</span> the family is orthonormal<span class="co">&lt;!--(Assumption 2)!--&gt;</span>, it corresponds to the projected coefficients </span>
<span id="cb19-161"><a href="#cb19-161" aria-hidden="true" tabindex="-1"></a>$\mu_{\ell}^{L,L^*}$: </span>
<span id="cb19-162"><a href="#cb19-162" aria-hidden="true" tabindex="-1"></a>$$\mu_{\ell}^{L,L^*} :=&lt;f^{L^*}, B_\ell^L&gt;.$$</span>
<span id="cb19-163"><a href="#cb19-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-164"><a href="#cb19-164" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-165"><a href="#cb19-165" aria-hidden="true" tabindex="-1"></a>We can prove the following property:</span>
<span id="cb19-166"><a href="#cb19-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-167"><a href="#cb19-167" aria-hidden="true" tabindex="-1"></a>::: {#prp-proj}</span>
<span id="cb19-168"><a href="#cb19-168" aria-hidden="true" tabindex="-1"></a>Under Assumption 1, </span>
<span id="cb19-169"><a href="#cb19-169" aria-hidden="true" tabindex="-1"></a>$$f^{L^*,L^*} = f^{L^*}.$$</span>
<span id="cb19-170"><a href="#cb19-170" aria-hidden="true" tabindex="-1"></a>Moreover, if Assumption 2 also holds, the projection coefficients verify</span>
<span id="cb19-171"><a href="#cb19-171" aria-hidden="true" tabindex="-1"></a>$$\mu_{\ell}^{L,L^*} = \mu_\ell^{L^*} \quad{ for }\; \ell =1, \ldots, \min(L, L^{*}).$$</span>
<span id="cb19-172"><a href="#cb19-172" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-173"><a href="#cb19-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-174"><a href="#cb19-174" aria-hidden="true" tabindex="-1"></a>In practice, data are observed at discrete time, we consider the operator $\mathbf{P}^L$ defined as the matrix $\mathbf{P}^L = ((\mathbf{B}^L)^T \mathbf{B}^L)^{-1} (\mathbf{B}^L)^T$ of size $L\times n$.  <span class="in">`r colorize("This coincides with the orthogonal projection when we deal with an orthonormal basis, but it is also consistent for non orthonormal family, coming back to the least square estimator on a specified family.", "red")`</span>  <span class="co">&lt;!--(this operator is a bit more complex when the functional family is not orthonormal wrt the standard scalar product). !--&gt;</span></span>
<span id="cb19-175"><a href="#cb19-175" aria-hidden="true" tabindex="-1"></a>Then we define the coefficients $\underline{\mu}^{L,L^*}$ which are the coefficients of ${\mu}^{L,L^*}$ approximated on the vector space, denoted $\mathbf{S}^L$, defined by the matrix $\mathbf{B}^L$. </span>
<span id="cb19-176"><a href="#cb19-176" aria-hidden="true" tabindex="-1"></a>$$\underline{\mu}^{L,L^*} := \mathbf{P}^L \mathbf{B}^{L^*}\mu^{L^*}.$$</span>
<span id="cb19-177"><a href="#cb19-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-178"><a href="#cb19-178" aria-hidden="true" tabindex="-1"></a>The corresponding finite approximated regression function is denoted $\underline{f}^{L,L^*}$ and is defined, for all $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, as </span>
<span id="cb19-179"><a href="#cb19-179" aria-hidden="true" tabindex="-1"></a>$$\underline{f}^{L,L^*}(t) = B^L(t) \underline{\mu}^{L,L^*}.$$</span>
<span id="cb19-180"><a href="#cb19-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-181"><a href="#cb19-181" aria-hidden="true" tabindex="-1"></a>We can prove the following properties linking $L, L^*$ and the number of timepoints $n$:</span>
<span id="cb19-182"><a href="#cb19-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-183"><a href="#cb19-183" aria-hidden="true" tabindex="-1"></a>::: {#prp-proj2}</span>
<span id="cb19-184"><a href="#cb19-184" aria-hidden="true" tabindex="-1"></a>Under Assumption 1 and Assumption 2, </span>
<span id="cb19-185"><a href="#cb19-185" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("the diagonal elements of ", "red")`</span> $\mathbf{P}^L \mathbf{B}^{L^*}$ `r colorize("are such that for", "red")`  $\ell=1, \ldots, \min(L, L^*),$</span>
<span id="cb19-186"><a href="#cb19-186" aria-hidden="true" tabindex="-1"></a>$$<span class="co">[</span><span class="ot">\mathbf{P}^L \mathbf{B}^{L^*}</span><span class="co">]</span>_{\ell\ell}=1.$$</span>
<span id="cb19-187"><a href="#cb19-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-188"><a href="#cb19-188" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L\geq L^*$, &lt;!--$\mathbf{P}^L \mathbf{B}^{L^*}$ has $L^*$ diagonal elements equal to 1 and other non-diagonal elements close to 0.!--&gt; `r colorize("when $n&gt;L$, we have", "red")` for $\ell=1, \ldots, L^*$, </span>
<span id="cb19-189"><a href="#cb19-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-190"><a href="#cb19-190" aria-hidden="true" tabindex="-1"></a>$$ \underline{\mu}^{L,L^*}_\ell = \mu^{L^*}_\ell.$$</span>
<span id="cb19-191"><a href="#cb19-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-192"><a href="#cb19-192" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--The first $L^*$ elements of $\underline{\mu}^{L,L^*}$ are equal to $\mu^{L^*}$ when $n&gt;L$.!--&gt;</span></span>
<span id="cb19-193"><a href="#cb19-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-194"><a href="#cb19-194" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L&lt;L^*$, &lt;!--$\mathbf{P}^L\mathbf{B}^{L^*}$ has $L$ diagonal elements equal to 1.!--&gt; <span class="in">`r colorize("for", "red")`</span>  $\ell =1, \ldots, L$,</span>
<span id="cb19-195"><a href="#cb19-195" aria-hidden="true" tabindex="-1"></a>$$\underline{\mu}^{L,L^*}_\ell \neq \mu^{L^*}_\ell.$$</span>
<span id="cb19-196"><a href="#cb19-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-197"><a href="#cb19-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-198"><a href="#cb19-198" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- The first $L$ elements of $\underline{\mu}^{L,L^*}$ are different to $\mu_\ell^{L^*}$.!--&gt;</span></span>
<span id="cb19-199"><a href="#cb19-199" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $n\rightarrow\infty$, <span class="in">`r colorize("for", "red")`</span> $\ell = 1,\ldots, L$</span>
<span id="cb19-200"><a href="#cb19-200" aria-hidden="true" tabindex="-1"></a>$$\underline{\mu}_\ell^{L,L^*}\rightarrow \mu_\ell^{L^*}. $$</span>
<span id="cb19-201"><a href="#cb19-201" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $n&gt;L^*$, then $f^{L^*} = f^{L^*,L^*} = \underline{f}^{L^*,L^*}$. </span>
<span id="cb19-202"><a href="#cb19-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-203"><a href="#cb19-203" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-204"><a href="#cb19-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-205"><a href="#cb19-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-206"><a href="#cb19-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-207"><a href="#cb19-207" aria-hidden="true" tabindex="-1"></a><span class="fu">## Estimator {#sec-estim}</span></span>
<span id="cb19-208"><a href="#cb19-208" aria-hidden="true" tabindex="-1"></a>Let $L\in <span class="sc">\{</span>L_{\min}, \ldots, L_{\max}<span class="sc">\}</span>$. </span>
<span id="cb19-209"><a href="#cb19-209" aria-hidden="true" tabindex="-1"></a>This section presents the least square estimator of the regression function on the space of dimension $L$ defined by the family $\mathbf{B}^L$ and discusses its error.</span>
<span id="cb19-210"><a href="#cb19-210" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-211"><a href="#cb19-211" aria-hidden="true" tabindex="-1"></a><span class="fu">### Estimation of the regression function</span></span>
<span id="cb19-212"><a href="#cb19-212" aria-hidden="true" tabindex="-1"></a>When considering the estimation of the regression function $f^{L^*}$ on the space of dimension $L$ defined by the family $\mathbf{B}^L$, we do not directly estimate $f^{L^*}$ but its projection on this finite space, which corresponds to the projected function $\underline{f}^{L,L^*}(t)$ and its associated coefficients $(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}$. </span>
<span id="cb19-213"><a href="#cb19-213" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-214"><a href="#cb19-214" aria-hidden="true" tabindex="-1"></a>::: {#def-proj2}</span>
<span id="cb19-215"><a href="#cb19-215" aria-hidden="true" tabindex="-1"></a>The vector of coefficients $(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}$ is estimated by the least square estimator $\hat{\underline{\mu}}^{L, L^*}$ defined as:</span>
<span id="cb19-216"><a href="#cb19-216" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-217"><a href="#cb19-217" aria-hidden="true" tabindex="-1"></a>\hat{\underline{\mu}}^{L, L^*}:=\frac1N \sum_{i=1}^N</span>
<span id="cb19-218"><a href="#cb19-218" aria-hidden="true" tabindex="-1"></a>\mathbf{P}^L y_{i.}.</span>
<span id="cb19-219"><a href="#cb19-219" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-220"><a href="#cb19-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-221"><a href="#cb19-221" aria-hidden="true" tabindex="-1"></a>For a fixed $t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, the estimator of the function $\underline{f}^{L,L^*}(t)$ is defined by:</span>
<span id="cb19-222"><a href="#cb19-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-223"><a href="#cb19-223" aria-hidden="true" tabindex="-1"></a>$$ \underline{\hat{f}_{}}^{L,L^*}(t) = \sum_{\ell=1}^L \underline{\hat \mu}_\ell^{L,L^*} B^L_\ell(t)= B^L(t)\hat{\underline{\mu}}^{L,L^*}.</span>
<span id="cb19-224"><a href="#cb19-224" aria-hidden="true" tabindex="-1"></a>$$ {#eq-fhatL}</span>
<span id="cb19-225"><a href="#cb19-225" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-226"><a href="#cb19-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-227"><a href="#cb19-227" aria-hidden="true" tabindex="-1"></a>@eq-fhatL directly implies that the estimator is thus the empirical mean of the functional approximation of each individual vector of observations. </span>
<span id="cb19-228"><a href="#cb19-228" aria-hidden="true" tabindex="-1"></a>Because we work with least squares estimators, we can easily study the error of estimation of $\hat{\underline{\mu}}^{L, L^*}$ and $\underline{\hat{f}_{}}^{L,L^*}$. </span>
<span id="cb19-229"><a href="#cb19-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-230"><a href="#cb19-230" aria-hidden="true" tabindex="-1"></a>::: {#prp-error}</span>
<span id="cb19-231"><a href="#cb19-231" aria-hidden="true" tabindex="-1"></a>Under Assumption 1 and Assumption 3, we have</span>
<span id="cb19-232"><a href="#cb19-232" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-233"><a href="#cb19-233" aria-hidden="true" tabindex="-1"></a>\hat{\underline{\mu}}^{L, L^*}</span>
<span id="cb19-234"><a href="#cb19-234" aria-hidden="true" tabindex="-1"></a>&amp;\sim \mathcal{N}_L\left(\underline{\mu}^{L, L^*}, \frac{\sigma^2}N\Sigma_{B}^{L,L^\varepsilon}</span>
<span id="cb19-235"><a href="#cb19-235" aria-hidden="true" tabindex="-1"></a>\right),</span>
<span id="cb19-236"><a href="#cb19-236" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-237"><a href="#cb19-237" aria-hidden="true" tabindex="-1"></a>where the $L\times L$ covariance matrix $\Sigma_{B}^{L,L^{\varepsilon}}$ is defined as </span>
<span id="cb19-238"><a href="#cb19-238" aria-hidden="true" tabindex="-1"></a>$\Sigma_{B}^{L,L^\varepsilon}:=\mathbf{P}^L \Sigma^{L^\varepsilon} (\mathbf{P}^L)^T$</span>
<span id="cb19-239"><a href="#cb19-239" aria-hidden="true" tabindex="-1"></a>with $\Sigma^{L^\varepsilon}= \Phi^{L^\varepsilon} (\Phi^{L^\varepsilon})^T$.</span>
<span id="cb19-240"><a href="#cb19-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-241"><a href="#cb19-241" aria-hidden="true" tabindex="-1"></a>Moreover, $B^L()\mathbf{P}^L y_i$ is a Gaussian process with mean $\underline{f}^{L,L^*}()$ and covariance function $(s,t) \mapsto \sigma^2 B^L(s) \Sigma_{B}^{L,L^\varepsilon} (B^L(t))^T$, and $(\underline{\hat{f}_{}}^{L,L^*}- \underline{f}^{L,L^*})()$ is a centered Gaussian process with covariance function $C^{L,L^*}: (s,t) \mapsto \frac{\sigma^2}N B^L(s) \Sigma_{B}^{L,L^\varepsilon} B^L(t)^T$. </span>
<span id="cb19-242"><a href="#cb19-242" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-243"><a href="#cb19-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-244"><a href="#cb19-244" aria-hidden="true" tabindex="-1"></a>The proof is given in Appendix. </span>
<span id="cb19-245"><a href="#cb19-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-246"><a href="#cb19-246" aria-hidden="true" tabindex="-1"></a>Even if the estimator $\underline{\hat{f}_{}}^{L,L^*}$ is defined on the functional space associated to $\mathbf{S}^L$, it can also be seen as an estimator of the function $f^{ L^*}$ which lies in the space $\mathcal{S}^{L^*}$. In that case, the error includes a functional approximation term due to the approximation of $f^{ L^*}$ on the space $\mathcal{S}^L$, which will be nonzero if $L\neq L^*$. It corresponds to the bias of the estimator $\underline{\hat{f}_{}}^{L,L^*}$, i.e. the difference between its expectation and the true $f^{ L^*}$. Indeed, recalling that $f^{L^*} = \underline{f}^{L^*,L^*}$, the error of estimation can be decomposed into</span>
<span id="cb19-247"><a href="#cb19-247" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-248"><a href="#cb19-248" aria-hidden="true" tabindex="-1"></a>\underline{\hat{f}}^{L, L^*}(t) -f^{L^*}(t) </span>
<span id="cb19-249"><a href="#cb19-249" aria-hidden="true" tabindex="-1"></a>= \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t) + \underline{f}^{L, L^*}(t) - \underline{f}^{L^*,L^*}(t) =: Stat_{L,L^*}(t) + Bias_{L,L^*}(t),</span>
<span id="cb19-250"><a href="#cb19-250" aria-hidden="true" tabindex="-1"></a>$$ {#eq-decomposition}</span>
<span id="cb19-251"><a href="#cb19-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-252"><a href="#cb19-252" aria-hidden="true" tabindex="-1"></a>The first term $Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)$ is the (unrescaled) statistics of the model. The second term $Bias_{L,L^*}(t) = \mathbb{E}(\underline{\hat{f}}^{L, L^*}(t)) - \underline{f}^{L^*,L^*}(t)$ is the bias of the estimator $\underline{\hat{f}}^{L, L^*}(t)$ when estimating the true function $\underline{f}^{L^*,L^*}(t)$. </span>
<span id="cb19-253"><a href="#cb19-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-254"><a href="#cb19-254" aria-hidden="true" tabindex="-1"></a>Let us remark that this bias is different than the bias of the estimator $\underline{\hat{f}}^{L, L^*}(t)$ when estimating the projected function $\underline{f}^{L,L^*}=f^{ L^*}$, which is 0. </span>
<span id="cb19-255"><a href="#cb19-255" aria-hidden="true" tabindex="-1"></a>The two terms defined in @eq-decomposition are more detailed in the two next subsections. </span>
<span id="cb19-256"><a href="#cb19-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-257"><a href="#cb19-257" aria-hidden="true" tabindex="-1"></a><span class="fu">### Statistics </span></span>
<span id="cb19-258"><a href="#cb19-258" aria-hidden="true" tabindex="-1"></a>The statistics of the model, $t\mapsto Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)$, is a random functional quantity which depends on the estimator $\underline{\hat{f}}^{L, L^*}$. From @prp-error, for any $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, we define the centered and rescaled statistics $Z_L(t)$: <span class="co">&lt;!--such that: !--&gt;</span></span>
<span id="cb19-259"><a href="#cb19-259" aria-hidden="true" tabindex="-1"></a>$$Z_L(t):= \frac{Stat_{L,L^*}(t)}{\sqrt{\text{Var}(Stat_{L,L^*}(t))}} </span>
<span id="cb19-260"><a href="#cb19-260" aria-hidden="true" tabindex="-1"></a>= \frac{\underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)}{\sqrt{C^{L, L^*}(t,t)}}\sim \mathcal{N}(0,1). $$</span>
<span id="cb19-261"><a href="#cb19-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-262"><a href="#cb19-262" aria-hidden="true" tabindex="-1"></a>The covariance function can be naturally estimated using the observations $y_{i.}$ as </span>
<span id="cb19-263"><a href="#cb19-263" aria-hidden="true" tabindex="-1"></a>$$\hat C^{L, L^*}(s,t) = \frac1{N-1}\sum_{i=1}^{N} (B^L(s)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(s))(B^L(t)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(t)).$$</span>
<span id="cb19-264"><a href="#cb19-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-265"><a href="#cb19-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-266"><a href="#cb19-266" aria-hidden="true" tabindex="-1"></a><span class="fu">### Bias </span></span>
<span id="cb19-267"><a href="#cb19-267" aria-hidden="true" tabindex="-1"></a>The bias is due to the fact that the estimation is potentially performed in a different (finite) space than the space where the true function $\underline{f}^{L^*,L^*}$ lives. This is a functional bias, which is not random. It corresponds to the approximation of $f^{L^*}$ from $\mathcal{S}^{L^*}$ to the space $\mathcal{S}^{L}$. It can be written as follows:</span>
<span id="cb19-268"><a href="#cb19-268" aria-hidden="true" tabindex="-1"></a>$$Bias_{L,L^*}(t) = B^L(t) \underline{\mu} ^{L,L^*} - B^{L^*}(t) \mu^{L^*}.$$</span>
<span id="cb19-269"><a href="#cb19-269" aria-hidden="true" tabindex="-1"></a>Thus, when $L&lt;L^*$ and  the family is orthonormal, <span class="in">`r colorize("the approximation is the orthogonal projection and we can deduce that", "red")`</span>   <span class="co">&lt;!-- (Assumption 2 holds), !--&gt;</span></span>
<span id="cb19-270"><a href="#cb19-270" aria-hidden="true" tabindex="-1"></a>$$Bias_{L,L^*}(t)= \sum_{\ell=1}^L B_\ell^L(t)\underline{\mu}_\ell^{L,L^*} - \sum_{\ell=1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*} = \sum_{\ell = L+1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*}.$$</span>
<span id="cb19-271"><a href="#cb19-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-272"><a href="#cb19-272" aria-hidden="true" tabindex="-1"></a>From @prp-error, we can directly deduce the following proposition:</span>
<span id="cb19-273"><a href="#cb19-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-274"><a href="#cb19-274" aria-hidden="true" tabindex="-1"></a>::: {#prp-bias}</span>
<span id="cb19-275"><a href="#cb19-275" aria-hidden="true" tabindex="-1"></a>Under Assumption 1 and Assumption 3, the bias is, for all $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$,</span>
<span id="cb19-276"><a href="#cb19-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-277"><a href="#cb19-277" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>for $L&lt;L^*$, $Bias_{L,L^*}(t)\neq 0$,</span>
<span id="cb19-278"><a href="#cb19-278" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>for $L\geq L^*$, $Bias_{L,L^*}(t) = 0$.</span>
<span id="cb19-279"><a href="#cb19-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-280"><a href="#cb19-280" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-281"><a href="#cb19-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-282"><a href="#cb19-282" aria-hidden="true" tabindex="-1"></a>\bigskip</span>
<span id="cb19-283"><a href="#cb19-283" aria-hidden="true" tabindex="-1"></a>In the next section, we explain how we use this property to derive confidence bands of $\underline{f}^{L, L^*}$ and $f^{L, L^*}$. </span>
<span id="cb19-284"><a href="#cb19-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-285"><a href="#cb19-285" aria-hidden="true" tabindex="-1"></a><span class="fu"># Confidence Bands of $\underline{f}^{L, L^*}$ and $f^{L, L^*}$ for a fixed $L$ {#sec-bandSun}</span></span>
<span id="cb19-286"><a href="#cb19-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-287"><a href="#cb19-287" aria-hidden="true" tabindex="-1"></a>The objective is to construct a confidence band for the two functions $\underline{f}^{L, L^*}$ and $f^{L, L^*}$, based on the observations $\mathbf{y}$, for a given value $L\in \{L_{\min}, \ldots, L_{\max}\}$. The band for $\underline{f}^{L, L^*}$ enters the framework proposed by @sun1994 which relies on an unbiased and linear estimator of the function&lt;!--. This is the case for !--&gt;  `r colorize("as", "red")` the estimator $\underline{\hat f}^{L, L^*}$ &lt;!--which!--&gt; is an unbiased estimator of $\underline{f}^{L, L^*}$. We recall in @sec-bandSun2 the construction of this confidence band which attains a given confidence level in a non-asymptotic setting, that is for a finite number of observations $n$ for each individual. Then in @sec-bandfLLstar, we prove that the confidence band proposed by @sun1994 can be viewed as a confidence band for $f^{L, L^*}$ with an asymptotic confidence level, the asymptotic framework being considered when $n\rightarrow\infty$. </span>
<span id="cb19-288"><a href="#cb19-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-289"><a href="#cb19-289" aria-hidden="true" tabindex="-1"></a>\bigskip</span>
<span id="cb19-290"><a href="#cb19-290" aria-hidden="true" tabindex="-1"></a><span class="fu">## Confidence band for $\underline{f}^{L,L^*}$ {#sec-bandSun2}</span></span>
<span id="cb19-291"><a href="#cb19-291" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- Let $L\in \{L_{\min}, \ldots, L_{\max}\}$. !--&gt;</span></span>
<span id="cb19-292"><a href="#cb19-292" aria-hidden="true" tabindex="-1"></a>Consider $1-\alpha$ <span class="co">&lt;!--as!--&gt;</span> a fixed confidence level. The aim is to find a function $d^L()$ such that</span>
<span id="cb19-293"><a href="#cb19-293" aria-hidden="true" tabindex="-1"></a>$$\mathbb{P}\left( \forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>,\; \underline{\hat{f}_{}}^{L,L^*}(t) -d^L(t)\leq \underline{f}^{L,L^*}(t)\leq \underline{\hat{f}_{}}^{L,L^*}(t) +d^L(t)\right) = 1-\alpha.$$</span>
<span id="cb19-294"><a href="#cb19-294" aria-hidden="true" tabindex="-1"></a>Consider the normalized statistics $Z_L(t)$ which is a centered and reduced Gaussian process. We want to find the quantile $q^L$ satisfying</span>
<span id="cb19-295"><a href="#cb19-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-296"><a href="#cb19-296" aria-hidden="true" tabindex="-1"></a>$$q^L =\arg\min_{q} \left<span class="sc">\{</span> \mathbb{P}\left(\max_{t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>} \left|Z_L(t)\right| \leq q \right) = 1 - \alpha\right<span class="sc">\}</span>.$${#eq-qL}</span>
<span id="cb19-297"><a href="#cb19-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-298"><a href="#cb19-298" aria-hidden="true" tabindex="-1"></a>Then we can take $d^L(t) = q^L \sqrt{C^{L, L^*}(t,t)}$. The covariance function $C^{L, L^*}(t,t)$ can be replaced by its estimator $\hat{C}^{L,L^*}(t,t)$, making the distribution a Student's distribution with $N-1$ degrees of freedom. Thus, it only requires to be able to compute the critical value $q^L$.</span>
<span id="cb19-299"><a href="#cb19-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-300"><a href="#cb19-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-301"><a href="#cb19-301" aria-hidden="true" tabindex="-1"></a>This can be done following @sun1994 who propose a confidence band for a centered Gaussian process. Their procedure is based on an unbiased linear estimator of the function of interest, which is the case for $\underline{\hat{f}_{}}^{L,L^*}$ when we consider a band for $\underline{f}^{L,L^*}$. </span>
<span id="cb19-302"><a href="#cb19-302" aria-hidden="true" tabindex="-1"></a>We recall their result in the following proposition, the computation of the value $q^L$ is detailed thereafter. </span>
<span id="cb19-303"><a href="#cb19-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-304"><a href="#cb19-304" aria-hidden="true" tabindex="-1"></a>::: {#thm-sunLoader}</span>
<span id="cb19-305"><a href="#cb19-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-306"><a href="#cb19-306" aria-hidden="true" tabindex="-1"></a><span class="fu">## @sun1994</span></span>
<span id="cb19-307"><a href="#cb19-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-308"><a href="#cb19-308" aria-hidden="true" tabindex="-1"></a>Set Assumption 1 and Assumption 3 and a probability $\alpha\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Then, we have </span>
<span id="cb19-309"><a href="#cb19-309" aria-hidden="true" tabindex="-1"></a>$$\mathbb{P}\left(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, \left|\underline{\hat{f}}^{L, L^*}(t)-\underline{f}^{L,L^*}(t)\right| \leq \hat d^L(t)\right) = 1- \alpha$$</span>
<span id="cb19-310"><a href="#cb19-310" aria-hidden="true" tabindex="-1"></a>with </span>
<span id="cb19-311"><a href="#cb19-311" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-312"><a href="#cb19-312" aria-hidden="true" tabindex="-1"></a>\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N}</span>
<span id="cb19-313"><a href="#cb19-313" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-314"><a href="#cb19-314" aria-hidden="true" tabindex="-1"></a>and $\hat q^L$ defined as the solution of the following equation, seen as a function of $q^L$:</span>
<span id="cb19-315"><a href="#cb19-315" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-316"><a href="#cb19-316" aria-hidden="true" tabindex="-1"></a>\alpha = \mathbb{P}\left(|t_{N-1}|&gt;q^L\right) +\frac{\| \tau^L\|_1}{\pi}\left( 1+\frac{(q^L)^2}{N-1}\right)^{-(N-1)/2} ,</span>
<span id="cb19-317"><a href="#cb19-317" aria-hidden="true" tabindex="-1"></a>$${#eq-cL}</span>
<span id="cb19-318"><a href="#cb19-318" aria-hidden="true" tabindex="-1"></a>with $(\tau^L)^2(t)= \partial_{12} c(t,t) = Var(Z_L(t))'$ where </span>
<span id="cb19-319"><a href="#cb19-319" aria-hidden="true" tabindex="-1"></a>we denote $\partial_{12}c(t,t)$ the partial derivatives of a function $c(t,s)$ in the first and second coordinates and then evaluated at $t=s$. </span>
<span id="cb19-320"><a href="#cb19-320" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-321"><a href="#cb19-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-322"><a href="#cb19-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-323"><a href="#cb19-323" aria-hidden="true" tabindex="-1"></a>We can thus deduce a confidence band of level $1-\alpha$ for $\underline{f}^{L,L^*}$:</span>
<span id="cb19-324"><a href="#cb19-324" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-325"><a href="#cb19-325" aria-hidden="true" tabindex="-1"></a>CB_1(\underline{f}^{L,L^*})&amp; = \left\{ \forall t\in [0,1], \left [\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) \right ]\right<span class="sc">\}</span>.</span>
<span id="cb19-326"><a href="#cb19-326" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-327"><a href="#cb19-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-328"><a href="#cb19-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-329"><a href="#cb19-329" aria-hidden="true" tabindex="-1"></a>The value $\hat q^L$ is defined implicitly in @eq-cL which involves the unknown and not explicit quantity $t\mapsto \tau^L(t)$. @Liebl2019 propose to estimate $\tau^L(t)$, for all $t$, by</span>
<span id="cb19-330"><a href="#cb19-330" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-331"><a href="#cb19-331" aria-hidden="true" tabindex="-1"></a>\hat \tau^L(t) &amp;= \left(\widehat{Var}(({U}^{L})'_{1}(t), \ldots, ({U}^{L})'_{N}(t)\right)^{1/2}<span class="sc">\\</span></span>
<span id="cb19-332"><a href="#cb19-332" aria-hidden="true" tabindex="-1"></a>&amp;= \left(\frac{1}{N-1}\sum_{i=1}^N\left(({U}^{L})'_{i}(t)-\frac1N\sum_{j=1}^N({U}^{L})'_{j}(t)\right)^2\right)^{1/2},</span>
<span id="cb19-333"><a href="#cb19-333" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-334"><a href="#cb19-334" aria-hidden="true" tabindex="-1"></a>where ${U}^L_{i}(t) = (P^L y_{i.}(t)-\underline{\hat{f}}^{L, L^*}(t))/(\hat C^{L,L^*}(t))^{1/2}$ and $({U}^{L})'_{i}$ is a smooth version of the differentiated function ${U}^L_{i}$. Then we take the $L_1$-norm of $\hat \tau^L$. </span>
<span id="cb19-335"><a href="#cb19-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-336"><a href="#cb19-336" aria-hidden="true" tabindex="-1"></a>Let us describe the behavior of $\hat d^L$:</span>
<span id="cb19-337"><a href="#cb19-337" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-338"><a href="#cb19-338" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\|\hat d^L\|_\infty$ increases with $L$.</span>
<span id="cb19-339"><a href="#cb19-339" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the functions $(B_\ell^L)_{1\leq \ell \leq L}$ &lt;!--consists in!--&gt; `r colorize("form", "red")` an orthonormal family, $\|\hat d^L\|_\infty$ increases with $L$ until $L=L^*$ and then $\|\hat d^L\|_\infty$ is constant with $L$.</span>
<span id="cb19-340"><a href="#cb19-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-341"><a href="#cb19-341" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize(" Their behavior will be illustrated with different function families in", "red")`</span> @sec-simulation.</span>
<span id="cb19-342"><a href="#cb19-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-343"><a href="#cb19-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-344"><a href="#cb19-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-345"><a href="#cb19-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-346"><a href="#cb19-346" aria-hidden="true" tabindex="-1"></a><span class="fu">## Asymptotic confidence band for $f^{L,L^*}$ {#sec-bandfLLstar}</span></span>
<span id="cb19-347"><a href="#cb19-347" aria-hidden="true" tabindex="-1"></a>Note that <span class="co">&lt;!-- if one works !--&gt;</span> in the asymptotic framework $n\rightarrow\infty$, the previous definition of $\hat d^L$ induces a natural asymptotic confidence band for the function $f^{L,L^*}$. Indeed, we can prove that </span>
<span id="cb19-348"><a href="#cb19-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-349"><a href="#cb19-349" aria-hidden="true" tabindex="-1"></a>::: {#thm-CB_Liebl_asymptotic}</span>
<span id="cb19-350"><a href="#cb19-350" aria-hidden="true" tabindex="-1"></a>Set Assumption 1 and Assumption 3 and a probability $\alpha\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Then, we have, </span>
<span id="cb19-351"><a href="#cb19-351" aria-hidden="true" tabindex="-1"></a>$$\lim_{n \rightarrow +\infty} \mathbb{P}\left(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\underline{\hat{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)\right) = 1-\alpha,$$</span>
<span id="cb19-352"><a href="#cb19-352" aria-hidden="true" tabindex="-1"></a>with $\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N}$ and $\hat q^L$ is defined as the solution of @eq-cL.</span>
<span id="cb19-353"><a href="#cb19-353" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-354"><a href="#cb19-354" aria-hidden="true" tabindex="-1"></a>The proof is given in Appendix. </span>
<span id="cb19-355"><a href="#cb19-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-356"><a href="#cb19-356" aria-hidden="true" tabindex="-1"></a>Then a confidence band for $f^{L,L^*}$ at the asymptotic confidence level $1-\alpha$ for a large number of observations $n$ is given by </span>
<span id="cb19-357"><a href="#cb19-357" aria-hidden="true" tabindex="-1"></a>\begin{align*} </span>
<span id="cb19-358"><a href="#cb19-358" aria-hidden="true" tabindex="-1"></a>CB(f^{L,L^*})&amp; = \left\{ \forall t\in [0,1], \left[\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) \right]\right<span class="sc">\}</span>.</span>
<span id="cb19-359"><a href="#cb19-359" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-360"><a href="#cb19-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-361"><a href="#cb19-361" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- We do not provide any illustration of this property, as it would be similar than the previous ones. Indeed, we notice that the asymptotic is achieved even when $n$ is small on our examples. !--&gt;</span></span>
<span id="cb19-362"><a href="#cb19-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-363"><a href="#cb19-363" aria-hidden="true" tabindex="-1"></a><span class="fu"># Confidence Band of $f^{L^*}$ by correcting the bias {#sec-band2}</span></span>
<span id="cb19-364"><a href="#cb19-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-365"><a href="#cb19-365" aria-hidden="true" tabindex="-1"></a>The function of interest is $f^{L^*}=\underline{f}^{L^*, L^*}$, rather than $\underline{f}^{L,L^*}$. Therefore, our objective is to construct a confidence  `r colorize("band", "red")` for $f^{L^*}$. However, an unbiased estimator of $f^{L^*}$ is  `r colorize("not", "red")` &lt;!--un!--&gt;available by definition, since the true dimension $L^*$ is unknown. &lt;!--Instead, we propose!--&gt;  `r colorize("We propose instead", "red")` to work with the estimator $\underline{\hat f}^{L,L^*}$ and to debias the corresponding confidence band. </span>
<span id="cb19-366"><a href="#cb19-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-367"><a href="#cb19-367" aria-hidden="true" tabindex="-1"></a>To <span class="in">`r colorize("do", "red")`</span>  <span class="co">&lt;!--achieve!--&gt;</span> this, we use the decomposition <span class="co">&lt;!--outlined in @eq-decomposition!--&gt;</span> </span>
<span id="cb19-368"><a href="#cb19-368" aria-hidden="true" tabindex="-1"></a>between the bias term and the statistical term, <span class="in">`r colorize("outlined in", "red")`</span> @eq-decomposition. The idea is to bound the infinit<span class="in">`r colorize("e","red")`</span> norm of these two terms. A first strategy <span class="in">`r colorize("is to bound", "red")`</span>  <span class="co">&lt;!--consists in bounding!--&gt;</span> each term separately, <span class="co">&lt;!-- and!--&gt;</span> then <span class="in">`r colorize("add", "red")`</span>  <span class="co">&lt;!--summing!--&gt;</span> the two bounds to construct the confidence band. However, this approach tends to produce a band that is too large and <span class="in">`r colorize("too", "red")`</span> conservative. <span class="in">`r colorize("This is because", "red")`</span>  <span class="co">&lt;!--The reason is that!--&gt;</span> applying </span>
<span id="cb19-369"><a href="#cb19-369" aria-hidden="true" tabindex="-1"></a>the infinite norm <span class="in">`r colorize("to", "red")`</span> <span class="co">&lt;!--on!--&gt;</span> each term before bounding them does not take into account the functional nature of the two terms. </span>
<span id="cb19-370"><a href="#cb19-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-371"><a href="#cb19-371" aria-hidden="true" tabindex="-1"></a>A second strategy <span class="in">`r colorize("is to retain", "red")`</span>  <span class="co">&lt;!--consists in keeping!--&gt;</span> the functional aspect by bounding the infinity norm of the sum of the <span class="co">&lt;!--functional!--&gt;</span> two <span class="in">`r colorize("functional", "red")`</span> terms. This approach is detailed in this section. </span>
<span id="cb19-372"><a href="#cb19-372" aria-hidden="true" tabindex="-1"></a>In @sec-construction2, we first rewrite the band as a band around $\underline{f}^{L,L^*}(t)$. `r colorize("We need to estimate the band bound and the bias. To do this, we divide the sample into two sub-samples. This choice is not ideal because it increases the variability of the estimators. But at least, it provides  independence between the estimators of the two quantities, which makes it possible to establish the theoretical coverage of the final band. More precisely ", "red")` we use a first subsample $\mathbf{y}^1$ to estimate the bound &lt;!--as!--&gt;  defined in @sec-bandSun. A second subsample $\mathbf{y}^2$ is used to estimate the bias term (without the infinite norm). This `r colorize("results in", "red")`  &lt;!--yields!--&gt; a pointwise correction of the bias, and the final confidence band is centered around $\underline{\hat{f}}^{L_{\max},L^*}$. This procedure provides a collection of confidence bands, for $L\in <span class="sc">\{</span>L_{\min}, \ldots, L_{\max}<span class="sc">\}</span>$ with <span class="in">`r colorize("variable", "red")`</span> <span class="co">&lt;!--varying!--&gt;</span> width. Then, in @sec-SelectionL2, we propose a criterion to select the "best" band by minimizing its width. </span>
<span id="cb19-373"><a href="#cb19-373" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize(" We discuss the  band thus obtained at the end of the section and its limits. ", "red")`</span> </span>
<span id="cb19-374"><a href="#cb19-374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-375"><a href="#cb19-375" aria-hidden="true" tabindex="-1"></a><span class="fu">## Construction of the band of $f^{L^*}$ for a given $L$ {#sec-construction2}</span></span>
<span id="cb19-376"><a href="#cb19-376" aria-hidden="true" tabindex="-1"></a>We introduce two independent sub-samples $\mathbf{y}^1$ and $\mathbf{y}^2$ of $\mathbf{y}$ of length $N_1$ and $N_2$ </span>
<span id="cb19-377"><a href="#cb19-377" aria-hidden="true" tabindex="-1"></a>such that $N_1+N_2=N$. </span>
<span id="cb19-378"><a href="#cb19-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-379"><a href="#cb19-379" aria-hidden="true" tabindex="-1"></a>We use the first sub-sample $\mathbf{y}^1$ to calculate $\underline{\hat{f}_1}^{L,L^*}(t)$, an estimator of $\underline{f}^{L,L^*}(t)$ and a functional bound denoted $\hat d_1^L$ that controls the bias term $\underline{f}^{L,L^*}(t)-\underline{\hat{f}_1}^{L,L^*}(t)$. This bound is defined in @sec-bandSun applied on $\mathbf{y}^1$, for a given level $\alpha$, such that:</span>
<span id="cb19-380"><a href="#cb19-380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-381"><a href="#cb19-381" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-382"><a href="#cb19-382" aria-hidden="true" tabindex="-1"></a>\mathbb{P}\left(\forall t\in<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, -\hat d_1^L(t) \leq \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t) \leq \hat d_1^L(t)\right) = 1-\alpha.</span>
<span id="cb19-383"><a href="#cb19-383" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-dL1}</span>
<span id="cb19-384"><a href="#cb19-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-385"><a href="#cb19-385" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("Next,", "red")`</span> <span class="co">&lt;!--Then,!--&gt;</span> we need to control the bias $Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t)-f^{L^*}(t)$. Recall tha`r colorize("t", "red")` &lt;!--n!--&gt; when $L_{\max}$ is `r colorize("sufficiently", "red")` large &lt;!--enough!--&gt; and $n&gt; L_{\max}$, `r colorize("we have", "red")` $f^{L^*} = \underline{f}^{L_{\max},L^*}$. `r colorize("We therefore need", "red")` &lt;!--Therefore, we want!--&gt; to control the $Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}(t)$. It would be tempting to replace $Bias_{L,L^*}(t)$ by its estimation based on the second sample $\mathbf{y}^2$. But this would introduce an estimation error that we also need to control, in the same spirit `r colorize("as", "red")`  &lt;!--than!--&gt; what is done in @Pascal2017. We can `r colorize("again", "red")` use &lt;!--again!--&gt; @sec-bandSun to compute the function $\hat d_2^{L,L_{\max}}(t)$ on the sample $\mathbf{y}^2$, and the functional estimators $\underline{\hat{f}}_2^{L,L^*}(t)$ and $\underline{\hat f}_2^{L_{\max}, L^*}(t)$ of $\underline{f}^{L,L^*}(t)$ and $\underline{ f}^{L_{\max}, L^*}(t)$, respectively. This allows `r colorize("us", "red")` to construct the following band for $\underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}$ for a confidence level $1-\beta$, </span>
<span id="cb19-386"><a href="#cb19-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-387"><a href="#cb19-387" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-388"><a href="#cb19-388" aria-hidden="true" tabindex="-1"></a>\mathbb{P}\left(\forall t\in<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, - \hat d_2^{L,L_{\max}}(t) \leq \underline{ f}^{L_{\max}, L^*}(t)- \underline{ f}^{L, L^*}(t) - (\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t)) \leq \hat d_2^{L,L_{\max}}(t)\right) = 1-\beta.</span>
<span id="cb19-389"><a href="#cb19-389" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-dL2}</span>
<span id="cb19-390"><a href="#cb19-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-391"><a href="#cb19-391" aria-hidden="true" tabindex="-1"></a>Combining @eq-def-dL1 and @eq-def-dL2, we can provide a debiased confidence band of $f^{L^*}(t)$. </span>
<span id="cb19-392"><a href="#cb19-392" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-393"><a href="#cb19-393" aria-hidden="true" tabindex="-1"></a>::: {#prp-CBf}</span>
<span id="cb19-394"><a href="#cb19-394" aria-hidden="true" tabindex="-1"></a>Let us define </span>
<span id="cb19-395"><a href="#cb19-395" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-396"><a href="#cb19-396" aria-hidden="true" tabindex="-1"></a>\hat\theta_1^L(t) &amp;:= -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t) <span class="sc">\\</span></span>
<span id="cb19-397"><a href="#cb19-397" aria-hidden="true" tabindex="-1"></a>\hat\theta_2^L(t)&amp;:= \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t) - \underline{\hat f}_2^{L, L^*}(t),</span>
<span id="cb19-398"><a href="#cb19-398" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-399"><a href="#cb19-399" aria-hidden="true" tabindex="-1"></a>where $\hat d_1^L(t)$ is defined on sample $\mathbf{y}^1$ by @eq-def-dL1 for a level $\alpha$ and $\hat d_2^{L,L_{\max}}(t)$ is defined on sample $\mathbf{y}^2$ by @eq-def-dL2 for a level $\beta$. </span>
<span id="cb19-400"><a href="#cb19-400" aria-hidden="true" tabindex="-1"></a>Then we have</span>
<span id="cb19-401"><a href="#cb19-401" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-402"><a href="#cb19-402" aria-hidden="true" tabindex="-1"></a>\mathbb{P}\left(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, \quad \hat \theta_1^L(t) \leq f^{L^*}(t)- \underline{\hat f}_1^{L, L^*}(t)\leq \hat\theta_2^L(t)\right)\geq 1-\alpha\beta.</span>
<span id="cb19-403"><a href="#cb19-403" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-404"><a href="#cb19-404" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-405"><a href="#cb19-405" aria-hidden="true" tabindex="-1"></a>The proof is given in Appendix.</span>
<span id="cb19-406"><a href="#cb19-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-407"><a href="#cb19-407" aria-hidden="true" tabindex="-1"></a>This defines a confidence band which can be defined either around $\underline{\hat{f}_{1}}^{L,L^*}$: </span>
<span id="cb19-408"><a href="#cb19-408" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-409"><a href="#cb19-409" aria-hidden="true" tabindex="-1"></a>CB_2(\underline{f}^{L^*})=\left\{\forall t\in[0,1], \left[\underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_1^{ L}(t) \, ;\, \underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_2^{ L}(t) \right] \right<span class="sc">\}</span></span>
<span id="cb19-410"><a href="#cb19-410" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-411"><a href="#cb19-411" aria-hidden="true" tabindex="-1"></a>or around $\underline{\hat f}_2^{ L_{\max}, L^*}$:</span>
<span id="cb19-412"><a href="#cb19-412" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-413"><a href="#cb19-413" aria-hidden="true" tabindex="-1"></a>CB_2(\underline{f}^{L^*})=\left\{\forall t\in[0,1], \left[\underline{\hat f_2}^{ L_{\max}, L^*}(t) + \bar \theta_1^L(t) \, ; \, \underline{\hat f_2}^{ L_{\max}, L^*}(t) +\bar \theta_2^L(t) \right]\right<span class="sc">\}</span>.</span>
<span id="cb19-414"><a href="#cb19-414" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-415"><a href="#cb19-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-416"><a href="#cb19-416" aria-hidden="true" tabindex="-1"></a>with $\bar \theta_1^L(t) = \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f_2}^{ L, L^*}(t) -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t)$</span>
<span id="cb19-417"><a href="#cb19-417" aria-hidden="true" tabindex="-1"></a>and $\bar \theta_2^L(t) = \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f_2}^{ L, L^*}(t) + \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)$. </span>
<span id="cb19-418"><a href="#cb19-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-419"><a href="#cb19-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-420"><a href="#cb19-420" aria-hidden="true" tabindex="-1"></a>::: {#rem-dLLmax}</span>
<span id="cb19-421"><a href="#cb19-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-422"><a href="#cb19-422" aria-hidden="true" tabindex="-1"></a>The two functions $\hat d_1^L(t)$ and $\hat d_2^{L,L_{\max}}(t)$ are of the same order <span class="in">`r colorize("because", "red")`</span> <span class="co">&lt;!--as!--&gt;</span> they are <span class="in">`r colorize("constructed using", "red")`</span> <span class="co">&lt;!--built with!--&gt;</span> the same approach. They depend on the length of the samples. To obtain the thinnest band, the best strategy is to <span class="in">`r colorize("divide", "red")`</span> <span class="co">&lt;!--split!--&gt;</span> the sample in two sub-samples of equal length <span class="in">`r colorize("$N_1=N_2=N/2$.", "red")`</span> <span class="co">&lt;!--$n_1=n_2= n/2$. !--&gt;</span></span>
<span id="cb19-423"><a href="#cb19-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-424"><a href="#cb19-424" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-425"><a href="#cb19-425" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-426"><a href="#cb19-426" aria-hidden="true" tabindex="-1"></a>The behavior of $\hat d_1^L$ <span class="in">`r colorize("was", "red")`</span> <span class="co">&lt;!--has been!--&gt;</span> described in @sec-bandSun. Let us describe the behavior of $\hat d_2^{L,L_{\max}}$:</span>
<span id="cb19-427"><a href="#cb19-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-428"><a href="#cb19-428" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\|\hat d_2^{L,L_{\max}}\|_\infty$ decreases with $L$.</span>
<span id="cb19-429"><a href="#cb19-429" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L&gt;L^\varepsilon$, $\|\hat d_2^{L,L_{\max}}\|_\infty$ is constant with $L$ and the probability in @eq-def-dL2 is equal to $1$.</span>
<span id="cb19-430"><a href="#cb19-430" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L^{*}&lt;L&lt;L^\varepsilon$, $\|\hat d_2^{L,L_{\max}}\|_\infty$ is constant with $L$ when the functions $B_\ell^L$ <span class="in">`r colorize("form", "red")`</span> <span class="co">&lt;!--consists in!--&gt;</span> an orthonormal family. Otherwise, the behavior is erratic. </span>
<span id="cb19-431"><a href="#cb19-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-432"><a href="#cb19-432" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--It!--&gt;</span> <span class="in">`r colorize("This", "red")`</span> means that when the band defined in @prp-CBf is calculated for $L&gt;L^\varepsilon$, the confidence level is $1-\alpha$ instead of $1-\alpha\beta$. </span>
<span id="cb19-433"><a href="#cb19-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-434"><a href="#cb19-434" aria-hidden="true" tabindex="-1"></a>The advantage<span class="co">&lt;!--s!--&gt;</span> of this approach is that the <span class="in">`r colorize("band", "red")`</span> bias <span class="co">&lt;!--of the band!--&gt;</span> is corrected and the level for the true function $f^{L^*}$ is guaranteed when $L^\varepsilon$ is large. This was the main <span class="in">`r colorize("aim", "red")`</span> <span class="co">&lt;!--objective!--&gt;</span> of the paper. </span>
<span id="cb19-435"><a href="#cb19-435" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("The main limit of this approach is that the band is constructed with samples with half sizes, leading to less precision. This will be illustrated in ", "red")`</span> @sec-simulation. </span>
<span id="cb19-436"><a href="#cb19-436" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("Nevertheless, this method gives finer confidence bands than cross-validation, and with the right level of confidence.  ", "red")`</span></span>
<span id="cb19-437"><a href="#cb19-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-438"><a href="#cb19-438" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("A natural question is then the choice of the dimension $L$. This is the purpose of the next section. ", "red")`</span></span>
<span id="cb19-439"><a href="#cb19-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-440"><a href="#cb19-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-441"><a href="#cb19-441" aria-hidden="true" tabindex="-1"></a><span class="fu">## Influence of $L$ {#sec-SelectionL2}</span></span>
<span id="cb19-442"><a href="#cb19-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-443"><a href="#cb19-443" aria-hidden="true" tabindex="-1"></a>This approach <span class="in">`r colorize("produces", "red")`</span>  <span class="co">&lt;!--gives!--&gt;</span> a collection of <span class="in">`r colorize("debiased", "red")`</span> confidence bands for different values of $L$. The confidence bands have different widths but a same confidence level $1-\alpha\beta$. It is <span class="in">`r colorize("therefore", "red")`</span> <span class="co">&lt;!--thus!--&gt;</span> natural to want to select one of them. This means <span class="in">`r colorize("that", "red")`</span> we want to select the best dimension $L$ among the collection $<span class="sc">\{</span>L_{\min}, \ldots, L_{\max}<span class="sc">\}</span>$. We need to define what "best" means. It is quite intuitive to <span class="in">`r colorize("want", "red")`</span> <span class="co">&lt;!--focus!--&gt;</span> on the <span class="in">`r colorize("finest", "red")`</span> band, <span class="in">`r colorize("fine in the sense of a certain norm", "red")`</span>. <span class="co">&lt;!-- that is the thinnest. Thinnest could be thought in different norms.!--&gt;</span> Here we consider the infinite norm of the width of the confidence band. <span class="in">`r colorize("This", "red")`</span> <span class="co">&lt;!--which!--&gt;</span> gives <span class="co">&lt;!--a!--&gt;</span> preference to smooth bands. We <span class="in">`r colorize("therefore", "red")`</span> <span class="co">&lt;!--thus!--&gt;</span> define the following criteria <span class="in">`r colorize("of selection of $L$", "red")`</span></span>
<span id="cb19-444"><a href="#cb19-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-445"><a href="#cb19-445" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-446"><a href="#cb19-446" aria-hidden="true" tabindex="-1"></a>\hat L = \arg\min_L \left<span class="sc">\{</span>\sup_{t} |\hat\theta_2^L(t)-\hat\theta_1^L(t)|\right<span class="sc">\}</span> = \arg\min_L \left<span class="sc">\{</span>\sup_t | \hat d^L(t) + \hat d^{L,L_{\max}}(t)|\right<span class="sc">\}</span>.</span>
<span id="cb19-447"><a href="#cb19-447" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-Lhat}</span>
<span id="cb19-448"><a href="#cb19-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-449"><a href="#cb19-449" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("This global approach guarantees that each band of the collection is debiased and then the dimension is selected. It will be illustrated in ", "red")`</span> @sec-simulation.</span>
<span id="cb19-450"><a href="#cb19-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-451"><a href="#cb19-451" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("In the next section, instead of debiasing each band, we employ another strategy focusing on the construction of a selection criteria that will guarantee that the bias is negligible.", "red")`</span></span>
<span id="cb19-452"><a href="#cb19-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-453"><a href="#cb19-453" aria-hidden="true" tabindex="-1"></a><span class="fu"># Selection of the best confidence band with a criteria taking into account the bias {#sec-modsel}</span></span>
<span id="cb19-454"><a href="#cb19-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-455"><a href="#cb19-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-456"><a href="#cb19-456" aria-hidden="true" tabindex="-1"></a>In this section, we want to use the collection of confidence bands defined in @sec-bandSun without correcting their bias, but <span class="co">&lt;!--instead!--&gt;</span> by proposing a selection criterion that is a trade-off between this bias and the dimension of the basis. To do this, we propose a new heuristic criterion <span class="in">`r colorize("linked", "red")`</span> <span class="co">&lt;!--going back!--&gt;</span> to the definition of the band itself, <span class="in">`r colorize("considering the estimation of the band", "red")`</span> <span class="co">&lt;!--seen!--&gt;</span> as the estimation of a quantile of a certain empirical process. The criterion is inspired by model selection tools <span class="in">`r colorize("for choosing", "red")`</span> <span class="co">&lt;!--to select!--&gt;</span> the best dimension $L$. In the following, we assume that $L_{\max}$ is large enough such that $\underline f^{L_{\max},L^*}=f^{L^*}$.</span>
<span id="cb19-457"><a href="#cb19-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-458"><a href="#cb19-458" aria-hidden="true" tabindex="-1"></a>We work on the quantile $q^L$ introduced in @eq-qL, its oracle version $q^{L^*}$ for &lt;!--the!--&gt;  level $L^*$ and `r colorize("its", "red")` &lt;!--the!--&gt; estimate $\hat q^L$. All `r colorize("are scalars, belonging to a collection indexed by", "red")` &lt;!--of them are scalar, in a collection of scalars, with!--&gt; $L=L_{\min}, \ldots, L_{\max}$. A natural criterion `r colorize("for choosing", "red")` &lt;!--to choose!--&gt; the best $L$ is &lt;!--such!--&gt; that the estimator $\hat q^L$ minimizes the quadratic error $\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right)$. However, this quadratic error is unknown as $q^{L^*}$ is unknown. We can not <span class="co">&lt;!--directly!--&gt;</span> use it <span class="in">`r colorize("directly", "red")`</span>.</span>
<span id="cb19-459"><a href="#cb19-459" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-460"><a href="#cb19-460" aria-hidden="true" tabindex="-1"></a>Instead, we study $\|\hat{q}^{L_{\max}}-\hat q^L\|^2$. </span>
<span id="cb19-461"><a href="#cb19-461" aria-hidden="true" tabindex="-1"></a>While the theoretical quadratic error $\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right)$ decreases when $L&lt;L^*$ and increases when $L&gt;L^*$, the  $\|\hat{q}^{L_{\max}}-\hat q^L\|^2$ approximation to this error `r colorize("always decreases", "red")` &lt;!--is still decreasing!--&gt; when $L&gt;L^*$, as illustrated in @sec-simulation.</span>
<span id="cb19-462"><a href="#cb19-462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-463"><a href="#cb19-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-464"><a href="#cb19-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-465"><a href="#cb19-465" aria-hidden="true" tabindex="-1"></a>We <span class="in">`r colorize("see", "red")`</span> <span class="co">&lt;!--recognize!--&gt;</span> a behavior similar to a bias, high when <span class="in">`r colorize("the", "red")`</span> dimension is small, and small when <span class="in">`r colorize("the", "red")`</span> dimension is large. Selecting a dimension using this criterion will always overfit the data. <span class="in">`r colorize("We therefore", "red")`</span> <span class="co">&lt;!--Thus, we!--&gt;</span> propose to penalize this quantity by the dimension $L$ divided by the sample size $N$, as usual in model selection criterion. <span class="in">`r colorize("To do this", "red")`</span> <span class="co">&lt;!--For that,!--&gt;</span> we introduce a regularisation parameter $\lambda&gt;0$ which balances the two terms. </span>
<span id="cb19-466"><a href="#cb19-466" aria-hidden="true" tabindex="-1"></a>A natural criteria to select the best $L$ is then </span>
<span id="cb19-467"><a href="#cb19-467" aria-hidden="true" tabindex="-1"></a>$$\widetilde{crit}(L) = \|\hat q^{L_{\max}}-\hat q^L\|^2 +\lambda \frac{L}{N}.$$</span>
<span id="cb19-468"><a href="#cb19-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-469"><a href="#cb19-469" aria-hidden="true" tabindex="-1"></a>Then we define </span>
<span id="cb19-470"><a href="#cb19-470" aria-hidden="true" tabindex="-1"></a>$$\tilde L = \arg\min_L \widetilde{crit}(L),$$</span>
<span id="cb19-471"><a href="#cb19-471" aria-hidden="true" tabindex="-1"></a>and take the band centered around $\underline{\hat{f}}^{\tilde L, L^*}$:</span>
<span id="cb19-472"><a href="#cb19-472" aria-hidden="true" tabindex="-1"></a>$$CB_3(\underline{f} ^{L^*}) = CB_1(\underline{f}^{\tilde L, L^*})$$</span>
<span id="cb19-473"><a href="#cb19-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-474"><a href="#cb19-474" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize(" This criterion is illustrated in", "red")`</span> @sec-simumodsel. <span class="in">`r colorize(" We also compare with two other standard approaches, heuristic as well, namely the cross-validation approach used to select the dimension $L$ which minimizes the reconstruction error, and a thresholding method  which keeps the higher dimension $L$ with large enough coefficients. These two methods are less oriented to the objective of controling the level of the selected confidence band.", "red")`</span> </span>
<span id="cb19-475"><a href="#cb19-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-476"><a href="#cb19-476" aria-hidden="true" tabindex="-1"></a><span class="fu"># `r colorize(" Simulation study", "red")` {#sec-simulation}</span></span>
<span id="cb19-477"><a href="#cb19-477" aria-hidden="true" tabindex="-1"></a>In this section, we illustrate the different statements provided along the paper on generated data. First, in   @sec-dgp,  we describe the generating data process and illustrate the linear estimator considered in this paper. In @sec-simu-band,  we illustrate the first confidence band, for a fixed level, as introduced in @sec-bandSun.  Then, we illustrate the debiased confidence band in @sec-simudebias, and  discuss the model selection criterion in @sec-simumodsel. We finally study the generalization of the method out of the class of models in @sec-gen. </span>
<span id="cb19-478"><a href="#cb19-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-479"><a href="#cb19-479" aria-hidden="true" tabindex="-1"></a><span class="fu">## Generating data process {#sec-dgp}</span></span>
<span id="cb19-480"><a href="#cb19-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-481"><a href="#cb19-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-482"><a href="#cb19-482" aria-hidden="true" tabindex="-1"></a>To illustrate the model, we simulate a regression functional model with $n=50$ points per individual and $N=40$ individuals. In @fig-BasisModel, the function $f$ (red curve) belongs to the Fourier (resp. Legendre and Spline) family with $L^*=11$ and the noisy observations $y_{ij}$ (black curves) have a functional noise in dimension $L^{\varepsilon}=20$, also in the Fourier (resp. Legendre and Spline) family on the left plot (resp. middle and right). </span>
<span id="cb19-483"><a href="#cb19-483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-484"><a href="#cb19-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-485"><a href="#cb19-485" aria-hidden="true" tabindex="-1"></a><span class="in">```{r message=FALSE, fig.height=3, fig.width=7}</span></span>
<span id="cb19-486"><a href="#cb19-486" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-BasisModel</span></span>
<span id="cb19-487"><a href="#cb19-487" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. We generate a regression functional model in the Fourier (left), Legendre (middle) and Splines (right) families. The red curve corresponds to the true function, and the gray curves correspond to noisy observations."</span></span>
<span id="cb19-488"><a href="#cb19-488" aria-hidden="true" tabindex="-1"></a><span class="in">library(ggplot2)</span></span>
<span id="cb19-489"><a href="#cb19-489" aria-hidden="true" tabindex="-1"></a><span class="in">library(fda)</span></span>
<span id="cb19-490"><a href="#cb19-490" aria-hidden="true" tabindex="-1"></a><span class="in">library(orthopolynom)</span></span>
<span id="cb19-491"><a href="#cb19-491" aria-hidden="true" tabindex="-1"></a><span class="in">library(wavelets)</span></span>
<span id="cb19-492"><a href="#cb19-492" aria-hidden="true" tabindex="-1"></a><span class="in">library(basefun)</span></span>
<span id="cb19-493"><a href="#cb19-493" aria-hidden="true" tabindex="-1"></a><span class="in">library(fields)</span></span>
<span id="cb19-494"><a href="#cb19-494" aria-hidden="true" tabindex="-1"></a><span class="in">library(ggpubr)</span></span>
<span id="cb19-495"><a href="#cb19-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-496"><a href="#cb19-496" aria-hidden="true" tabindex="-1"></a><span class="in">func.basis = function(time, L, basis){</span></span>
<span id="cb19-497"><a href="#cb19-497" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == 'Splines'){</span></span>
<span id="cb19-498"><a href="#cb19-498" aria-hidden="true" tabindex="-1"></a><span class="in">    B = bsplineS(time,breaks = seq(min(time), max(time), length.out = L-1), norder = 3, 0) </span></span>
<span id="cb19-499"><a href="#cb19-499" aria-hidden="true" tabindex="-1"></a><span class="in">  } else if (basis == 'Fourier'){</span></span>
<span id="cb19-500"><a href="#cb19-500" aria-hidden="true" tabindex="-1"></a><span class="in">    B = fourier(time,nbasis = L) </span></span>
<span id="cb19-501"><a href="#cb19-501" aria-hidden="true" tabindex="-1"></a><span class="in">  } else if (basis == 'Legendre'){</span></span>
<span id="cb19-502"><a href="#cb19-502" aria-hidden="true" tabindex="-1"></a><span class="in">    B = Legendre_basis(numeric_var("x", support = c(min(time), max(time))), </span></span>
<span id="cb19-503"><a href="#cb19-503" aria-hidden="true" tabindex="-1"></a><span class="in">                       order = L-1)(time)</span></span>
<span id="cb19-504"><a href="#cb19-504" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-505"><a href="#cb19-505" aria-hidden="true" tabindex="-1"></a><span class="in">  return(B)</span></span>
<span id="cb19-506"><a href="#cb19-506" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-507"><a href="#cb19-507" aria-hidden="true" tabindex="-1"></a><span class="in">dgp = function(n=50,N=40,sd=1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = 'Fourier', f.true = NULL){ </span></span>
<span id="cb19-508"><a href="#cb19-508" aria-hidden="true" tabindex="-1"></a><span class="in">  ### n: number of timepoints</span></span>
<span id="cb19-509"><a href="#cb19-509" aria-hidden="true" tabindex="-1"></a><span class="in">  ### N: number of individuals</span></span>
<span id="cb19-510"><a href="#cb19-510" aria-hidden="true" tabindex="-1"></a><span class="in">  ### sd: noise level (standard deviation)</span></span>
<span id="cb19-511"><a href="#cb19-511" aria-hidden="true" tabindex="-1"></a><span class="in">  ### L: number of functional basis for the signal</span></span>
<span id="cb19-512"><a href="#cb19-512" aria-hidden="true" tabindex="-1"></a><span class="in">  ### L.eps: number of functional basis for the noise</span></span>
<span id="cb19-513"><a href="#cb19-513" aria-hidden="true" tabindex="-1"></a><span class="in">  ### alpha.mu: vector of coefficients</span></span>
<span id="cb19-514"><a href="#cb19-514" aria-hidden="true" tabindex="-1"></a><span class="in">  ### basis: functional basis, to be chosen in 'Legendre', 'Fourier', 'Splines'</span></span>
<span id="cb19-515"><a href="#cb19-515" aria-hidden="true" tabindex="-1"></a><span class="in">  ### f.true: if one wants to fix the true function</span></span>
<span id="cb19-516"><a href="#cb19-516" aria-hidden="true" tabindex="-1"></a><span class="in">  time = seq(0, 1, length.out = n)</span></span>
<span id="cb19-517"><a href="#cb19-517" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-518"><a href="#cb19-518" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == 'Fourier'){</span></span>
<span id="cb19-519"><a href="#cb19-519" aria-hidden="true" tabindex="-1"></a><span class="in">    if (L.star%%2 == 0){ L.star = L.star+1}</span></span>
<span id="cb19-520"><a href="#cb19-520" aria-hidden="true" tabindex="-1"></a><span class="in">    if (L.eps%%2 == 0){ L.eps = L.eps+1}</span></span>
<span id="cb19-521"><a href="#cb19-521" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-522"><a href="#cb19-522" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-523"><a href="#cb19-523" aria-hidden="true" tabindex="-1"></a><span class="in">  if (is.null(f.true)){</span></span>
<span id="cb19-524"><a href="#cb19-524" aria-hidden="true" tabindex="-1"></a><span class="in">    ### Create the functional basis </span></span>
<span id="cb19-525"><a href="#cb19-525" aria-hidden="true" tabindex="-1"></a><span class="in">    B = func.basis(time, L.star, basis)</span></span>
<span id="cb19-526"><a href="#cb19-526" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb19-527"><a href="#cb19-527" aria-hidden="true" tabindex="-1"></a><span class="in">    ### Generate randomly coefficients, if needed</span></span>
<span id="cb19-528"><a href="#cb19-528" aria-hidden="true" tabindex="-1"></a><span class="in">    if (is.null(alpha.mu)){</span></span>
<span id="cb19-529"><a href="#cb19-529" aria-hidden="true" tabindex="-1"></a><span class="in">      alpha.mu = sample(x = c(-5:-2, 2:5),size=L.star,replace=TRUE)} </span></span>
<span id="cb19-530"><a href="#cb19-530" aria-hidden="true" tabindex="-1"></a><span class="in">    if (basis == 'Fourier'){</span></span>
<span id="cb19-531"><a href="#cb19-531" aria-hidden="true" tabindex="-1"></a><span class="in">      alpha.mu = alpha.mu / 3</span></span>
<span id="cb19-532"><a href="#cb19-532" aria-hidden="true" tabindex="-1"></a><span class="in">      sd = sd/2</span></span>
<span id="cb19-533"><a href="#cb19-533" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb19-534"><a href="#cb19-534" aria-hidden="true" tabindex="-1"></a><span class="in">    y = matrix(0,nrow = N, ncol = n)</span></span>
<span id="cb19-535"><a href="#cb19-535" aria-hidden="true" tabindex="-1"></a><span class="in">    f.true = B %*% alpha.mu</span></span>
<span id="cb19-536"><a href="#cb19-536" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-537"><a href="#cb19-537" aria-hidden="true" tabindex="-1"></a><span class="in">  B.eps = func.basis(time, L.eps, basis)</span></span>
<span id="cb19-538"><a href="#cb19-538" aria-hidden="true" tabindex="-1"></a><span class="in">  y = matrix(0,nrow = N, ncol = n)</span></span>
<span id="cb19-539"><a href="#cb19-539" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in 1:N){</span></span>
<span id="cb19-540"><a href="#cb19-540" aria-hidden="true" tabindex="-1"></a><span class="in">    y[i,] = f.true + B.eps %*% matrix(rnorm(L.eps, 0, sd))</span></span>
<span id="cb19-541"><a href="#cb19-541" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-542"><a href="#cb19-542" aria-hidden="true" tabindex="-1"></a><span class="in">  return(list(y = t(y), alpha.mu = alpha.mu, time = time, L.star=L.star, f.true = f.true))</span></span>
<span id="cb19-543"><a href="#cb19-543" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-544"><a href="#cb19-544" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(1)</span></span>
<span id="cb19-545"><a href="#cb19-545" aria-hidden="true" tabindex="-1"></a><span class="in">n=50</span></span>
<span id="cb19-546"><a href="#cb19-546" aria-hidden="true" tabindex="-1"></a><span class="in">N=40</span></span>
<span id="cb19-547"><a href="#cb19-547" aria-hidden="true" tabindex="-1"></a><span class="in">sd=1</span></span>
<span id="cb19-548"><a href="#cb19-548" aria-hidden="true" tabindex="-1"></a><span class="in">L.star=11</span></span>
<span id="cb19-549"><a href="#cb19-549" aria-hidden="true" tabindex="-1"></a><span class="in">L.eps = 20</span></span>
<span id="cb19-550"><a href="#cb19-550" aria-hidden="true" tabindex="-1"></a><span class="in">alpha.mu = NULL</span></span>
<span id="cb19-551"><a href="#cb19-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-552"><a href="#cb19-552" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(1)</span></span>
<span id="cb19-553"><a href="#cb19-553" aria-hidden="true" tabindex="-1"></a><span class="in">basis = "Legendre"</span></span>
<span id="cb19-554"><a href="#cb19-554" aria-hidden="true" tabindex="-1"></a><span class="in">data = dgp(n=n,N=N,sd=sd,L.star=L.star, L.eps = L.eps, alpha.mu = alpha.mu, basis = basis, f.true = NULL)</span></span>
<span id="cb19-555"><a href="#cb19-555" aria-hidden="true" tabindex="-1"></a><span class="in">dfLegendre = data.frame( Time = rep(data$time,N+1),</span></span>
<span id="cb19-556"><a href="#cb19-556" aria-hidden="true" tabindex="-1"></a><span class="in">                         basis = rep(basis, (N+1)*length(data$time)),</span></span>
<span id="cb19-557"><a href="#cb19-557" aria-hidden="true" tabindex="-1"></a><span class="in">                         f = c(data$y, data$f.true),</span></span>
<span id="cb19-558"><a href="#cb19-558" aria-hidden="true" tabindex="-1"></a><span class="in">                         type = rep(c(rep("obs", N), "True"), each = n), ind = rep(1:(N+1), each = n))</span></span>
<span id="cb19-559"><a href="#cb19-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-560"><a href="#cb19-560" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-561"><a href="#cb19-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-562"><a href="#cb19-562" aria-hidden="true" tabindex="-1"></a><span class="in">basis = "Fourier"</span></span>
<span id="cb19-563"><a href="#cb19-563" aria-hidden="true" tabindex="-1"></a><span class="in">data = dgp(n=n,N=N,sd=sd,L.star=L.star, L.eps = L.eps, alpha.mu = alpha.mu, basis = basis, f.true = NULL)</span></span>
<span id="cb19-564"><a href="#cb19-564" aria-hidden="true" tabindex="-1"></a><span class="in">dfFourier = data.frame( Time = rep(data$time,N+1),</span></span>
<span id="cb19-565"><a href="#cb19-565" aria-hidden="true" tabindex="-1"></a><span class="in">                        basis = rep(basis, (N+1)*length(data$time)),</span></span>
<span id="cb19-566"><a href="#cb19-566" aria-hidden="true" tabindex="-1"></a><span class="in">                        f = c(data$y, data$f.true),</span></span>
<span id="cb19-567"><a href="#cb19-567" aria-hidden="true" tabindex="-1"></a><span class="in">                        type = rep(c(rep("obs", N), "True"), each = n), ind = rep(1:(N+1), each = n))</span></span>
<span id="cb19-568"><a href="#cb19-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-569"><a href="#cb19-569" aria-hidden="true" tabindex="-1"></a><span class="in">basis = "Splines"</span></span>
<span id="cb19-570"><a href="#cb19-570" aria-hidden="true" tabindex="-1"></a><span class="in">data = dgp(n=n,N=N,sd=2*sd,L.star=L.star, L.eps = L.eps, alpha.mu = alpha.mu, basis = basis, f.true = NULL)</span></span>
<span id="cb19-571"><a href="#cb19-571" aria-hidden="true" tabindex="-1"></a><span class="in">dfSplines = data.frame( Time = rep(data$time,N+1),</span></span>
<span id="cb19-572"><a href="#cb19-572" aria-hidden="true" tabindex="-1"></a><span class="in">                        basis = rep(basis, (N+1)*length(data$time)),</span></span>
<span id="cb19-573"><a href="#cb19-573" aria-hidden="true" tabindex="-1"></a><span class="in">                        f = c(data$y,data$f.true),</span></span>
<span id="cb19-574"><a href="#cb19-574" aria-hidden="true" tabindex="-1"></a><span class="in">                        type = rep(c(rep("obs", N), "True"), each = n), ind = rep(1:(N+1), each = n))</span></span>
<span id="cb19-575"><a href="#cb19-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-576"><a href="#cb19-576" aria-hidden="true" tabindex="-1"></a><span class="in">df = rbind(dfLegendre, dfFourier, dfSplines)</span></span>
<span id="cb19-577"><a href="#cb19-577" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(data = df, aes(x = Time, y = f, color = type, group = ind)) + </span></span>
<span id="cb19-578"><a href="#cb19-578" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(linewidth= 0.5)+</span></span>
<span id="cb19-579"><a href="#cb19-579" aria-hidden="true" tabindex="-1"></a><span class="in">  scale_colour_manual(values = c("obs" = "lightgrey","True" = "red")) +</span></span>
<span id="cb19-580"><a href="#cb19-580" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-581"><a href="#cb19-581" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-582"><a href="#cb19-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-583"><a href="#cb19-583" aria-hidden="true" tabindex="-1"></a>@prp-proj and @prp-proj2 are illustrated in Appendix. </span>
<span id="cb19-584"><a href="#cb19-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-585"><a href="#cb19-585" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--@fig-estimatorL displays estimators calculated with different dimensions $L$. Data are generated with $L^*=11$, $L^\varepsilon=20$, $n=50$ and $N=40$. The true function and its projection $\underline f^{L,L^*}$ are in cyan, and the estimator $\underline{\hat{f}_{}}^{L,L^*}$ is in red. We compute it for the three families, Legendre, Fourier and splines. </span></span>
<span id="cb19-586"><a href="#cb19-586" aria-hidden="true" tabindex="-1"></a><span class="co">In all cases, the estimators are very precise when considering the relevant dimension, but estimating a function of dimension $L^*$ with a function of dimension $L&lt;L^*$ is not consistent. Note that the performance of the estimator for the spline family is also good, even if the family is not orthonormal, because we work here at the level of the function (and not at the level of the coefficients). </span></span>
<span id="cb19-587"><a href="#cb19-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-588"><a href="#cb19-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-589"><a href="#cb19-589" aria-hidden="true" tabindex="-1"></a><span class="co">```{r , out.height = "50%", fig.width=7}</span></span>
<span id="cb19-590"><a href="#cb19-590" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-estimatorL</span></span>
<span id="cb19-591"><a href="#cb19-591" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For each family (Fourier which is orthogonal, Legendre which is orthonormal and the splines which are not orthogonal wrt the standard scalar product), we consider a function with true dimension 11 (top), and its projection on the space of dimension 5 (bottom), displayed in cyan. The estimators in dimensions 11 and 5 are displayed in red."</span></span>
<span id="cb19-592"><a href="#cb19-592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-593"><a href="#cb19-593" aria-hidden="true" tabindex="-1"></a><span class="co">estimator = function(data, basis, L){</span></span>
<span id="cb19-594"><a href="#cb19-594" aria-hidden="true" tabindex="-1"></a><span class="co">  </span><span class="al">###</span><span class="co"> data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb19-595"><a href="#cb19-595" aria-hidden="true" tabindex="-1"></a><span class="co">  </span><span class="al">###</span><span class="co"> basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb19-596"><a href="#cb19-596" aria-hidden="true" tabindex="-1"></a><span class="co">  </span><span class="al">###</span><span class="co"> L: number of functional basis for the signal</span></span>
<span id="cb19-597"><a href="#cb19-597" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb19-598"><a href="#cb19-598" aria-hidden="true" tabindex="-1"></a><span class="co">  if (basis == 'Fourier'){</span></span>
<span id="cb19-599"><a href="#cb19-599" aria-hidden="true" tabindex="-1"></a><span class="co">    if (L%%2 == 0){ L = L+1}</span></span>
<span id="cb19-600"><a href="#cb19-600" aria-hidden="true" tabindex="-1"></a><span class="co">  }</span></span>
<span id="cb19-601"><a href="#cb19-601" aria-hidden="true" tabindex="-1"></a><span class="co">  B = func.basis(data$time, L, basis)</span></span>
<span id="cb19-602"><a href="#cb19-602" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb19-603"><a href="#cb19-603" aria-hidden="true" tabindex="-1"></a><span class="co">  </span><span class="al">###</span><span class="co"> Data projection</span></span>
<span id="cb19-604"><a href="#cb19-604" aria-hidden="true" tabindex="-1"></a><span class="co">  Hi = solve(t(B) %*% B) %*% t(B) %*% data$y</span></span>
<span id="cb19-605"><a href="#cb19-605" aria-hidden="true" tabindex="-1"></a><span class="co">  mu.hat = rowMeans(Hi)</span></span>
<span id="cb19-606"><a href="#cb19-606" aria-hidden="true" tabindex="-1"></a><span class="co">  f.hat = c(B %*% mu.hat)</span></span>
<span id="cb19-607"><a href="#cb19-607" aria-hidden="true" tabindex="-1"></a><span class="co">  data.proj = data</span></span>
<span id="cb19-608"><a href="#cb19-608" aria-hidden="true" tabindex="-1"></a><span class="co">  data.proj$y = B %*% Hi</span></span>
<span id="cb19-609"><a href="#cb19-609" aria-hidden="true" tabindex="-1"></a><span class="co">  cov.emp = crossprod(t(data.proj$y - f.hat)) / ncol(data.proj$y)</span></span>
<span id="cb19-610"><a href="#cb19-610" aria-hidden="true" tabindex="-1"></a><span class="co">  </span></span>
<span id="cb19-611"><a href="#cb19-611" aria-hidden="true" tabindex="-1"></a><span class="co">  return(list(f.hat=f.hat, mu.hat = mu.hat, cov.emp = cov.emp, data.proj = data.proj))</span></span>
<span id="cb19-612"><a href="#cb19-612" aria-hidden="true" tabindex="-1"></a><span class="co">}</span></span>
<span id="cb19-613"><a href="#cb19-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-614"><a href="#cb19-614" aria-hidden="true" tabindex="-1"></a><span class="co">set.seed(1)</span></span>
<span id="cb19-615"><a href="#cb19-615" aria-hidden="true" tabindex="-1"></a><span class="co">basis = "Legendre"</span></span>
<span id="cb19-616"><a href="#cb19-616" aria-hidden="true" tabindex="-1"></a><span class="co">data = dgp(n=50,N=40,sd=1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-617"><a href="#cb19-617" aria-hidden="true" tabindex="-1"></a><span class="co">B = func.basis(data$time, L=5, basis)</span></span>
<span id="cb19-618"><a href="#cb19-618" aria-hidden="true" tabindex="-1"></a><span class="co">f.true.L5 = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)</span></span>
<span id="cb19-619"><a href="#cb19-619" aria-hidden="true" tabindex="-1"></a><span class="co">est5 = estimator(data, basis, L=5)</span></span>
<span id="cb19-620"><a href="#cb19-620" aria-hidden="true" tabindex="-1"></a><span class="co">est11 = estimator(data, basis, L=11)</span></span>
<span id="cb19-621"><a href="#cb19-621" aria-hidden="true" tabindex="-1"></a><span class="co">dfLegendre = data.frame( Time = rep(data$time,4),</span></span>
<span id="cb19-622"><a href="#cb19-622" aria-hidden="true" tabindex="-1"></a><span class="co">                         basis = rep(basis, 4*length(data$time)),</span></span>
<span id="cb19-623"><a href="#cb19-623" aria-hidden="true" tabindex="-1"></a><span class="co">                         f = c(data$f.true, c(f.true.L5), est5$f.hat, est11$f.hat),</span></span>
<span id="cb19-624"><a href="#cb19-624" aria-hidden="true" tabindex="-1"></a><span class="co">                         L = rep(c("L = 11", "L = 5", "L = 5", "L = 11"), each = length(data$time)),</span></span>
<span id="cb19-625"><a href="#cb19-625" aria-hidden="true" tabindex="-1"></a><span class="co">                         type = rep(c("True", "True", "Estimated", "Estimated"), each = length(data$time)))</span></span>
<span id="cb19-626"><a href="#cb19-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-627"><a href="#cb19-627" aria-hidden="true" tabindex="-1"></a><span class="co">basis = "Fourier"</span></span>
<span id="cb19-628"><a href="#cb19-628" aria-hidden="true" tabindex="-1"></a><span class="co">data = dgp(n=50,N=40,sd=1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-629"><a href="#cb19-629" aria-hidden="true" tabindex="-1"></a><span class="co">B = func.basis(data$time, L=5, basis)</span></span>
<span id="cb19-630"><a href="#cb19-630" aria-hidden="true" tabindex="-1"></a><span class="co">f.true.L5 = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)</span></span>
<span id="cb19-631"><a href="#cb19-631" aria-hidden="true" tabindex="-1"></a><span class="co">est5 = estimator(data, basis, L=5)</span></span>
<span id="cb19-632"><a href="#cb19-632" aria-hidden="true" tabindex="-1"></a><span class="co">est11 = estimator(data, basis, L=11)</span></span>
<span id="cb19-633"><a href="#cb19-633" aria-hidden="true" tabindex="-1"></a><span class="co">dfFourier = data.frame( Time = rep(data$time,4),</span></span>
<span id="cb19-634"><a href="#cb19-634" aria-hidden="true" tabindex="-1"></a><span class="co">                        basis = rep(basis, 4*length(data$time)),</span></span>
<span id="cb19-635"><a href="#cb19-635" aria-hidden="true" tabindex="-1"></a><span class="co">                        f = c(data$f.true, c(f.true.L5), est5$f.hat, est11$f.hat),</span></span>
<span id="cb19-636"><a href="#cb19-636" aria-hidden="true" tabindex="-1"></a><span class="co">                        L = rep(c("L = 11", "L = 5", "L = 5", "L = 11"), each = length(data$time)),</span></span>
<span id="cb19-637"><a href="#cb19-637" aria-hidden="true" tabindex="-1"></a><span class="co">                        type = rep(c("True", "True", "Estimated", "Estimated"), each = length(data$time)))</span></span>
<span id="cb19-638"><a href="#cb19-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-639"><a href="#cb19-639" aria-hidden="true" tabindex="-1"></a><span class="co">basis = "Splines"</span></span>
<span id="cb19-640"><a href="#cb19-640" aria-hidden="true" tabindex="-1"></a><span class="co">data = dgp(n=50,N=40,sd=2*1,L.star=11, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-641"><a href="#cb19-641" aria-hidden="true" tabindex="-1"></a><span class="co">B = func.basis(data$time, L=5, basis)</span></span>
<span id="cb19-642"><a href="#cb19-642" aria-hidden="true" tabindex="-1"></a><span class="co">f.true.L5 = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)</span></span>
<span id="cb19-643"><a href="#cb19-643" aria-hidden="true" tabindex="-1"></a><span class="co">est5 = estimator(data, basis, L=5)</span></span>
<span id="cb19-644"><a href="#cb19-644" aria-hidden="true" tabindex="-1"></a><span class="co">est11 = estimator(data, basis, L=11)</span></span>
<span id="cb19-645"><a href="#cb19-645" aria-hidden="true" tabindex="-1"></a><span class="co">dfSplines = data.frame( Time = rep(data$time,4),</span></span>
<span id="cb19-646"><a href="#cb19-646" aria-hidden="true" tabindex="-1"></a><span class="co">                        basis = rep(basis, 4*length(data$time)),</span></span>
<span id="cb19-647"><a href="#cb19-647" aria-hidden="true" tabindex="-1"></a><span class="co">                        f = c(data$f.true, c(f.true.L5), est5$f.hat, est11$f.hat),</span></span>
<span id="cb19-648"><a href="#cb19-648" aria-hidden="true" tabindex="-1"></a><span class="co">                        L = rep(c("L = 11", "L = 5", "L = 5", "L = 11"), each = length(data$time)),</span></span>
<span id="cb19-649"><a href="#cb19-649" aria-hidden="true" tabindex="-1"></a><span class="co">                        type = rep(c("True", "True", "Estimated", "Estimated"), each = length(data$time)))</span></span>
<span id="cb19-650"><a href="#cb19-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-651"><a href="#cb19-651" aria-hidden="true" tabindex="-1"></a><span class="co">df = rbind(dfLegendre, dfFourier, dfSplines)</span></span>
<span id="cb19-652"><a href="#cb19-652" aria-hidden="true" tabindex="-1"></a><span class="co">ggplot(data = df, aes(x = Time, y = f, color = type)) + </span></span>
<span id="cb19-653"><a href="#cb19-653" aria-hidden="true" tabindex="-1"></a><span class="co">  geom_line(aes(linetype = type), linewidth= 0.5)+</span></span>
<span id="cb19-654"><a href="#cb19-654" aria-hidden="true" tabindex="-1"></a><span class="co">  facet_grid(L~basis)</span></span>
<span id="cb19-655"><a href="#cb19-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-656"><a href="#cb19-656" aria-hidden="true" tabindex="-1"></a><span class="co">```</span></span>
<span id="cb19-657"><a href="#cb19-657" aria-hidden="true" tabindex="-1"></a><span class="co">!--&gt;</span></span>
<span id="cb19-658"><a href="#cb19-658" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-659"><a href="#cb19-659" aria-hidden="true" tabindex="-1"></a><span class="fu">## Confidence band for a fixed level {#sec-simu-band}</span></span>
<span id="cb19-660"><a href="#cb19-660" aria-hidden="true" tabindex="-1"></a>The band derived in @thm-sunLoader is illustrated on @fig-bandL. It displays on the top row several functional data generated under either the Fourier family (left), Legendre (middle) or Spline (right), on the middle row the confidence bands of $\underline f^{L,L^*}$ for different values of $L=3,5$ and $11$, and on the bottom row the bound $\hat d^L$. The true functions $\underline f^{L,L^*}$ are displayed in cyan and the confidence bands in purple. The bands are very precise for each $L$. The behavior of $\hat d^L$ increases with $L$. As $d^L$ can be seen as a variance, $\hat d^L(t)$ is larger on the boundary of the time domain, as there are less observations near 0 and 1. </span>
<span id="cb19-661"><a href="#cb19-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-662"><a href="#cb19-662" aria-hidden="true" tabindex="-1"></a>We also evaluate numerically the levels of the obtained confidence bands. For this, 1000 datasets are simulated, the confidence band is estimated for each of them. </span>
<span id="cb19-663"><a href="#cb19-663" aria-hidden="true" tabindex="-1"></a>The empirical confidence level is then evaluated as the proportion of confidence bands that contain the true function. @tbl-levelL presents the empirical confidence levels for different values of $L$ and two sample sizes $n=50$ and $n=150$, with $N=10$, $N=40$ and $N=60$. </span>
<span id="cb19-664"><a href="#cb19-664" aria-hidden="true" tabindex="-1"></a>When $N=40$ and $N=60$, the level is the expected one whatever the value of $L$, especially when $L&lt;L^*$ and $N=40$,  but also when $L&gt;L^\varepsilon$. We will see in the next sections that this will not be the case for the debiased confidence band. When $N=10$, the level is too small, especially when $L$ is large. This might be due to the the large number of parameters to be estimated in the covariance matrix $C$, with a small number of observations $N$. </span>
<span id="cb19-665"><a href="#cb19-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-666"><a href="#cb19-666" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-667"><a href="#cb19-667" aria-hidden="true" tabindex="-1"></a><span class="in">```{r }</span></span>
<span id="cb19-668"><a href="#cb19-668" aria-hidden="true" tabindex="-1"></a><span class="in">compute.c.L = function(data.scl, alpha = 0.05){</span></span>
<span id="cb19-669"><a href="#cb19-669" aria-hidden="true" tabindex="-1"></a><span class="in">  ### data.scl: the rescaled data </span></span>
<span id="cb19-670"><a href="#cb19-670" aria-hidden="true" tabindex="-1"></a><span class="in">  ### alpha: the level for the confidence band</span></span>
<span id="cb19-671"><a href="#cb19-671" aria-hidden="true" tabindex="-1"></a><span class="in">  x_approx = apply(data.scl$y, 2,FUN=function(yy){</span></span>
<span id="cb19-672"><a href="#cb19-672" aria-hidden="true" tabindex="-1"></a><span class="in">    fn = stats::splinefun(x = data.scl$time, y = yy, method = "natural")</span></span>
<span id="cb19-673"><a href="#cb19-673" aria-hidden="true" tabindex="-1"></a><span class="in">    pracma::fderiv(f = fn, x = data.scl$time, n = 1, h = 1e-6, method = "central")</span></span>
<span id="cb19-674"><a href="#cb19-674" aria-hidden="true" tabindex="-1"></a><span class="in">  })</span></span>
<span id="cb19-675"><a href="#cb19-675" aria-hidden="true" tabindex="-1"></a><span class="in">  N = ncol(data.scl$y)</span></span>
<span id="cb19-676"><a href="#cb19-676" aria-hidden="true" tabindex="-1"></a><span class="in">  hat.tau = apply(x_approx, 1, stats::sd) </span></span>
<span id="cb19-677"><a href="#cb19-677" aria-hidden="true" tabindex="-1"></a><span class="in">  hat.tau[which(is.na(hat.tau))] = 0</span></span>
<span id="cb19-678"><a href="#cb19-678" aria-hidden="true" tabindex="-1"></a><span class="in">  tau_01 = (hat.tau)[-1]%*%diff(data.scl$time)</span></span>
<span id="cb19-679"><a href="#cb19-679" aria-hidden="true" tabindex="-1"></a><span class="in">  myfun = function(c){stats::pt(c, lower.tail = FALSE, df = N-1) + tau_01 * </span></span>
<span id="cb19-680"><a href="#cb19-680" aria-hidden="true" tabindex="-1"></a><span class="in">      (1 + c^2/(N-1))^(-(N-1)/2)/(2 * pi) - alpha/2}</span></span>
<span id="cb19-681"><a href="#cb19-681" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L = stats::uniroot(f = myfun,interval = c(.5,8))$root</span></span>
<span id="cb19-682"><a href="#cb19-682" aria-hidden="true" tabindex="-1"></a><span class="in">  return(c.L)</span></span>
<span id="cb19-683"><a href="#cb19-683" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-684"><a href="#cb19-684" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-685"><a href="#cb19-685" aria-hidden="true" tabindex="-1"></a><span class="in">CB1 = function(data, basis, L, alpha = 0.05){</span></span>
<span id="cb19-686"><a href="#cb19-686" aria-hidden="true" tabindex="-1"></a><span class="in">  ### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb19-687"><a href="#cb19-687" aria-hidden="true" tabindex="-1"></a><span class="in">  ### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb19-688"><a href="#cb19-688" aria-hidden="true" tabindex="-1"></a><span class="in">  ### L: number of functional basis for the signal</span></span>
<span id="cb19-689"><a href="#cb19-689" aria-hidden="true" tabindex="-1"></a><span class="in">  ### alpha: the level for the confidence band</span></span>
<span id="cb19-690"><a href="#cb19-690" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-691"><a href="#cb19-691" aria-hidden="true" tabindex="-1"></a><span class="in">  est = estimator(data, basis, L)</span></span>
<span id="cb19-692"><a href="#cb19-692" aria-hidden="true" tabindex="-1"></a><span class="in">  data.proj = est$data.proj</span></span>
<span id="cb19-693"><a href="#cb19-693" aria-hidden="true" tabindex="-1"></a><span class="in">  data.scl = data.proj</span></span>
<span id="cb19-694"><a href="#cb19-694" aria-hidden="true" tabindex="-1"></a><span class="in">  data.scl$y = (data.proj$y - est$f.hat)/sqrt(diag(est$cov.emp))</span></span>
<span id="cb19-695"><a href="#cb19-695" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-696"><a href="#cb19-696" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L = compute.c.L(data.scl, alpha)</span></span>
<span id="cb19-697"><a href="#cb19-697" aria-hidden="true" tabindex="-1"></a><span class="in">  d.L = c.L %*% sqrt(diag(est$cov.emp)/ncol(data.scl$y))</span></span>
<span id="cb19-698"><a href="#cb19-698" aria-hidden="true" tabindex="-1"></a><span class="in">  f.hat.up = est$f.hat + d.L</span></span>
<span id="cb19-699"><a href="#cb19-699" aria-hidden="true" tabindex="-1"></a><span class="in">  f.hat.low = est$f.hat - d.L</span></span>
<span id="cb19-700"><a href="#cb19-700" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-701"><a href="#cb19-701" aria-hidden="true" tabindex="-1"></a><span class="in">  return(list(f.hat.up = f.hat.up, f.hat.low = f.hat.low, d.L = d.L, c.L = c.L, width = max(abs(f.hat.up-f.hat.low))))</span></span>
<span id="cb19-702"><a href="#cb19-702" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-703"><a href="#cb19-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-704"><a href="#cb19-704" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-705"><a href="#cb19-705" aria-hidden="true" tabindex="-1"></a><span class="in">d.L.Lmax = function(data, basis, L, Lmax=30, alpha = 0.05){</span></span>
<span id="cb19-706"><a href="#cb19-706" aria-hidden="true" tabindex="-1"></a><span class="in">  est.2.f = estimator(data, basis, L)</span></span>
<span id="cb19-707"><a href="#cb19-707" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.proj = est.2.f$data.proj</span></span>
<span id="cb19-708"><a href="#cb19-708" aria-hidden="true" tabindex="-1"></a><span class="in">  est.2.f.Lmax = estimator(data, basis, Lmax)</span></span>
<span id="cb19-709"><a href="#cb19-709" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.proj.Lmax = est.2.f.Lmax$data.proj</span></span>
<span id="cb19-710"><a href="#cb19-710" aria-hidden="true" tabindex="-1"></a><span class="in">  residuals.L.Lmax = data.2.proj.Lmax$y - data.2.proj$y - (est.2.f.Lmax$f.hat - est.2.f$f.hat) </span></span>
<span id="cb19-711"><a href="#cb19-711" aria-hidden="true" tabindex="-1"></a><span class="in">  cov.emp.rest = crossprod(t(residuals.L.Lmax)) / ncol(residuals.L.Lmax)</span></span>
<span id="cb19-712"><a href="#cb19-712" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.scl = data.2.proj</span></span>
<span id="cb19-713"><a href="#cb19-713" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.scl$y = residuals.L.Lmax/sqrt(cov.emp.rest)</span></span>
<span id="cb19-714"><a href="#cb19-714" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L.Lmax.2 = compute.c.L(data.2.scl, alpha)</span></span>
<span id="cb19-715"><a href="#cb19-715" aria-hidden="true" tabindex="-1"></a><span class="in">  d.L.Lmax.2 = c.L.Lmax.2 %*% sqrt(cov.emp.rest/ncol(data.2.scl$y))</span></span>
<span id="cb19-716"><a href="#cb19-716" aria-hidden="true" tabindex="-1"></a><span class="in">  return(c.L.Lmax.2)</span></span>
<span id="cb19-717"><a href="#cb19-717" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-718"><a href="#cb19-718" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-719"><a href="#cb19-719" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-720"><a href="#cb19-720" aria-hidden="true" tabindex="-1"></a><span class="in">```{r , fig.height = 7, fig.width=7}</span></span>
<span id="cb19-721"><a href="#cb19-721" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-bandL</span></span>
<span id="cb19-722"><a href="#cb19-722" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. For the three families, resp. Fourier, Legendre and the splines, we display on the top row the observed functional data, on the middle row the confidence bands for different values of L (3, 5 and 11), and on the bottom row the bound dL."</span></span>
<span id="cb19-723"><a href="#cb19-723" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-724"><a href="#cb19-724" aria-hidden="true" tabindex="-1"></a><span class="in">dfObs = data.frame(Time = double(),</span></span>
<span id="cb19-725"><a href="#cb19-725" aria-hidden="true" tabindex="-1"></a><span class="in">                   basis = character(),</span></span>
<span id="cb19-726"><a href="#cb19-726" aria-hidden="true" tabindex="-1"></a><span class="in">                   f = double(),</span></span>
<span id="cb19-727"><a href="#cb19-727" aria-hidden="true" tabindex="-1"></a><span class="in">                   ind = integer())</span></span>
<span id="cb19-728"><a href="#cb19-728" aria-hidden="true" tabindex="-1"></a><span class="in">dfTrue = data.frame(Time = double(),</span></span>
<span id="cb19-729"><a href="#cb19-729" aria-hidden="true" tabindex="-1"></a><span class="in">                    basis = character(),</span></span>
<span id="cb19-730"><a href="#cb19-730" aria-hidden="true" tabindex="-1"></a><span class="in">                    f = double())</span></span>
<span id="cb19-731"><a href="#cb19-731" aria-hidden="true" tabindex="-1"></a><span class="in">dfTrueProjected = data.frame(Time = double(),</span></span>
<span id="cb19-732"><a href="#cb19-732" aria-hidden="true" tabindex="-1"></a><span class="in">                             basis = character(),</span></span>
<span id="cb19-733"><a href="#cb19-733" aria-hidden="true" tabindex="-1"></a><span class="in">                             f = double(),</span></span>
<span id="cb19-734"><a href="#cb19-734" aria-hidden="true" tabindex="-1"></a><span class="in">                             dimension = character())</span></span>
<span id="cb19-735"><a href="#cb19-735" aria-hidden="true" tabindex="-1"></a><span class="in">dfBand &lt;- data.frame(Time = double(),</span></span>
<span id="cb19-736"><a href="#cb19-736" aria-hidden="true" tabindex="-1"></a><span class="in">                     basis = character(),</span></span>
<span id="cb19-737"><a href="#cb19-737" aria-hidden="true" tabindex="-1"></a><span class="in">                     flow = double(),</span></span>
<span id="cb19-738"><a href="#cb19-738" aria-hidden="true" tabindex="-1"></a><span class="in">                     fup = double(),</span></span>
<span id="cb19-739"><a href="#cb19-739" aria-hidden="true" tabindex="-1"></a><span class="in">                     dimension = character())</span></span>
<span id="cb19-740"><a href="#cb19-740" aria-hidden="true" tabindex="-1"></a><span class="in">dfdL &lt;- data.frame(Time = double(),</span></span>
<span id="cb19-741"><a href="#cb19-741" aria-hidden="true" tabindex="-1"></a><span class="in">                   basis = character(),</span></span>
<span id="cb19-742"><a href="#cb19-742" aria-hidden="true" tabindex="-1"></a><span class="in">                   dL = double(),</span></span>
<span id="cb19-743"><a href="#cb19-743" aria-hidden="true" tabindex="-1"></a><span class="in">                   dimension = character())</span></span>
<span id="cb19-744"><a href="#cb19-744" aria-hidden="true" tabindex="-1"></a><span class="in">vec.L = c(3,5,11)</span></span>
<span id="cb19-745"><a href="#cb19-745" aria-hidden="true" tabindex="-1"></a><span class="in">for (basis in c("Legendre", "Fourier", "Splines")){</span></span>
<span id="cb19-746"><a href="#cb19-746" aria-hidden="true" tabindex="-1"></a><span class="in">  N = 40</span></span>
<span id="cb19-747"><a href="#cb19-747" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == "Splines"){</span></span>
<span id="cb19-748"><a href="#cb19-748" aria-hidden="true" tabindex="-1"></a><span class="in">    data = dgp(n=50,N=N,sd=2*1,L.star=10, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-749"><a href="#cb19-749" aria-hidden="true" tabindex="-1"></a><span class="in">  } else  {data = dgp(n=50,N=N,sd=1,L.star=10, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)}</span></span>
<span id="cb19-750"><a href="#cb19-750" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-751"><a href="#cb19-751" aria-hidden="true" tabindex="-1"></a><span class="in">  dfObs = rbind(dfObs,data.frame(Time = rep(data$time, N),</span></span>
<span id="cb19-752"><a href="#cb19-752" aria-hidden="true" tabindex="-1"></a><span class="in">                                 basis = rep(basis, length(c(data$y))),</span></span>
<span id="cb19-753"><a href="#cb19-753" aria-hidden="true" tabindex="-1"></a><span class="in">                                 f = c(data$y),</span></span>
<span id="cb19-754"><a href="#cb19-754" aria-hidden="true" tabindex="-1"></a><span class="in">                                 ind = rep(1:N, each = length(data$time))))</span></span>
<span id="cb19-755"><a href="#cb19-755" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-756"><a href="#cb19-756" aria-hidden="true" tabindex="-1"></a><span class="in">  dfTrue = rbind(dfTrue,data.frame(Time = data$time,</span></span>
<span id="cb19-757"><a href="#cb19-757" aria-hidden="true" tabindex="-1"></a><span class="in">                                   basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-758"><a href="#cb19-758" aria-hidden="true" tabindex="-1"></a><span class="in">                                   f = data$f.true))</span></span>
<span id="cb19-759"><a href="#cb19-759" aria-hidden="true" tabindex="-1"></a><span class="in">  for (L in vec.L){</span></span>
<span id="cb19-760"><a href="#cb19-760" aria-hidden="true" tabindex="-1"></a><span class="in">    conf.band = CB1(data, basis, L)</span></span>
<span id="cb19-761"><a href="#cb19-761" aria-hidden="true" tabindex="-1"></a><span class="in">    B = func.basis(data$time, L, basis)</span></span>
<span id="cb19-762"><a href="#cb19-762" aria-hidden="true" tabindex="-1"></a><span class="in">    f.true.L = t(B %*% solve(t(B) %*% B) %*% t(B) %*% data$f.true)</span></span>
<span id="cb19-763"><a href="#cb19-763" aria-hidden="true" tabindex="-1"></a><span class="in">    dfBand = rbind(dfBand, data.frame(Time = data$time,</span></span>
<span id="cb19-764"><a href="#cb19-764" aria-hidden="true" tabindex="-1"></a><span class="in">                                      basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-765"><a href="#cb19-765" aria-hidden="true" tabindex="-1"></a><span class="in">                                      flow = c(conf.band$f.hat.low), </span></span>
<span id="cb19-766"><a href="#cb19-766" aria-hidden="true" tabindex="-1"></a><span class="in">                                      fup = c(conf.band$f.hat.up), </span></span>
<span id="cb19-767"><a href="#cb19-767" aria-hidden="true" tabindex="-1"></a><span class="in">                                      dimension = as.factor(rep(L, length(data$time)))))</span></span>
<span id="cb19-768"><a href="#cb19-768" aria-hidden="true" tabindex="-1"></a><span class="in">    dfTrueProjected = rbind(dfTrueProjected, data.frame(Time = data$time,</span></span>
<span id="cb19-769"><a href="#cb19-769" aria-hidden="true" tabindex="-1"></a><span class="in">                                                        basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-770"><a href="#cb19-770" aria-hidden="true" tabindex="-1"></a><span class="in">                                                        f = c(f.true.L), </span></span>
<span id="cb19-771"><a href="#cb19-771" aria-hidden="true" tabindex="-1"></a><span class="in">                                                        dimension = rep(L, length(data$time))))</span></span>
<span id="cb19-772"><a href="#cb19-772" aria-hidden="true" tabindex="-1"></a><span class="in">    dfdL = rbind(dfdL, data.frame(Time = data$time,</span></span>
<span id="cb19-773"><a href="#cb19-773" aria-hidden="true" tabindex="-1"></a><span class="in">                                  basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-774"><a href="#cb19-774" aria-hidden="true" tabindex="-1"></a><span class="in">                                  dL = c(conf.band$d.L),</span></span>
<span id="cb19-775"><a href="#cb19-775" aria-hidden="true" tabindex="-1"></a><span class="in">                                  dimension = as.factor(rep(L,length(data$time)))))</span></span>
<span id="cb19-776"><a href="#cb19-776" aria-hidden="true" tabindex="-1"></a><span class="in">  } </span></span>
<span id="cb19-777"><a href="#cb19-777" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-778"><a href="#cb19-778" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-779"><a href="#cb19-779" aria-hidden="true" tabindex="-1"></a><span class="in">p1 &lt;- ggplot() + </span></span>
<span id="cb19-780"><a href="#cb19-780" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfObs, aes(x = Time, y = f, group = ind), linewidth = 0.1, color = "grey") +</span></span>
<span id="cb19-781"><a href="#cb19-781" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfTrue, aes(x = Time, y = f), colour = "black", linewidth = 0.5) + </span></span>
<span id="cb19-782"><a href="#cb19-782" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-783"><a href="#cb19-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-784"><a href="#cb19-784" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-785"><a href="#cb19-785" aria-hidden="true" tabindex="-1"></a><span class="in">p2 &lt;- ggplot() +</span></span>
<span id="cb19-786"><a href="#cb19-786" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfBand, aes(x = Time, y = flow, group = dimension, color = dimension), linewidth = 0.8) +</span></span>
<span id="cb19-787"><a href="#cb19-787" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfBand, aes(x = Time, y = fup, group = dimension, color = dimension), linewidth = 0.8) + </span></span>
<span id="cb19-788"><a href="#cb19-788" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfTrueProjected, aes(x = Time, y = f, group = dimension), colour = "black", linewidth = 0.2)+ </span></span>
<span id="cb19-789"><a href="#cb19-789" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis) + ylab("confidence band")</span></span>
<span id="cb19-790"><a href="#cb19-790" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-791"><a href="#cb19-791" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-792"><a href="#cb19-792" aria-hidden="true" tabindex="-1"></a><span class="in">p3 &lt;- ggplot() +</span></span>
<span id="cb19-793"><a href="#cb19-793" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfdL, aes(x = Time, y = dL, group = dimension, color = dimension)) +</span></span>
<span id="cb19-794"><a href="#cb19-794" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-795"><a href="#cb19-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-796"><a href="#cb19-796" aria-hidden="true" tabindex="-1"></a><span class="in">ggarrange(p1, p2, p3, nrow = 3, common.legend = TRUE, legend = "bottom")</span></span>
<span id="cb19-797"><a href="#cb19-797" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-798"><a href="#cb19-798" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-799"><a href="#cb19-799" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-802"><a href="#cb19-802" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb19-803"><a href="#cb19-803" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-levelL</span></span>
<span id="cb19-804"><a href="#cb19-804" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "The confidence level of the confidence band CB is evaluated from 1000 repetitions. Confidence bands are calculated with the Fourier family (a), Legendre family (b) and Splines family (c), for several L in rows and several n and N in columns, for alpha = 0.05."</span></span>
<span id="cb19-805"><a href="#cb19-805" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-806"><a href="#cb19-806" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb19-807"><a href="#cb19-807" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb19-808"><a href="#cb19-808" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb19-809"><a href="#cb19-809" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb19-810"><a href="#cb19-810" aria-hidden="true" tabindex="-1"></a>vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb19-811"><a href="#cb19-811" aria-hidden="true" tabindex="-1"></a>vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">40</span>)</span>
<span id="cb19-812"><a href="#cb19-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-813"><a href="#cb19-813" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb19-814"><a href="#cb19-814" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb19-815"><a href="#cb19-815" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb19-816"><a href="#cb19-816" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb19-817"><a href="#cb19-817" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb19-818"><a href="#cb19-818" aria-hidden="true" tabindex="-1"></a>  vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">60</span>)</span>
<span id="cb19-819"><a href="#cb19-819" aria-hidden="true" tabindex="-1"></a>  vec.basis <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'Fourier'</span>, <span class="st">"Legendre"</span>, <span class="st">"Splines"</span>)</span>
<span id="cb19-820"><a href="#cb19-820" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb19-821"><a href="#cb19-821" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="fu">max</span>(vec.L),<span class="fu">length</span>(vec.n),<span class="fu">length</span>(vec.N), <span class="fu">length</span>(vec.basis)))</span>
<span id="cb19-822"><a href="#cb19-822" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.basis <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.basis)){</span>
<span id="cb19-823"><a href="#cb19-823" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb19-824"><a href="#cb19-824" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (ind.N <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.N)){</span>
<span id="cb19-825"><a href="#cb19-825" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb19-826"><a href="#cb19-826" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb19-827"><a href="#cb19-827" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb19-828"><a href="#cb19-828" aria-hidden="true" tabindex="-1"></a>            <span class="fu">set.seed</span>(rep)</span>
<span id="cb19-829"><a href="#cb19-829" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (vec.basis[ind.basis] <span class="sc">==</span> <span class="st">"Splines"</span>){           data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> vec.basis[ind.basis], <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb19-830"><a href="#cb19-830" aria-hidden="true" tabindex="-1"></a>            } <span class="cf">else</span> { data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> vec.basis[ind.basis]) }</span>
<span id="cb19-831"><a href="#cb19-831" aria-hidden="true" tabindex="-1"></a>            conf.band <span class="ot">=</span> <span class="fu">CB1</span>(data, vec.basis[ind.basis], L, <span class="at">alpha=</span> <span class="fl">0.05</span>)</span>
<span id="cb19-832"><a href="#cb19-832" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (vec.basis[ind.basis] <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb19-833"><a href="#cb19-833" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb19-834"><a href="#cb19-834" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb19-835"><a href="#cb19-835" aria-hidden="true" tabindex="-1"></a>            B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, vec.basis[ind.basis])</span>
<span id="cb19-836"><a href="#cb19-836" aria-hidden="true" tabindex="-1"></a>            B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L, vec.basis[ind.basis])</span>
<span id="cb19-837"><a href="#cb19-837" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb19-838"><a href="#cb19-838" aria-hidden="true" tabindex="-1"></a>            f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb19-839"><a href="#cb19-839" aria-hidden="true" tabindex="-1"></a>            f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-840"><a href="#cb19-840" aria-hidden="true" tabindex="-1"></a>            f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-841"><a href="#cb19-841" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">sum</span>(f.true.L<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true.L<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb19-842"><a href="#cb19-842" aria-hidden="true" tabindex="-1"></a>              cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb19-843"><a href="#cb19-843" aria-hidden="true" tabindex="-1"></a>            } </span>
<span id="cb19-844"><a href="#cb19-844" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb19-845"><a href="#cb19-845" aria-hidden="true" tabindex="-1"></a>          perf[L,ind.n, ind.N, ind.basis] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb19-846"><a href="#cb19-846" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb19-847"><a href="#cb19-847" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb19-848"><a href="#cb19-848" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb19-849"><a href="#cb19-849" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-850"><a href="#cb19-850" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-851"><a href="#cb19-851" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab1.RData"</span>)</span>
<span id="cb19-852"><a href="#cb19-852" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"Res_Tab1.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb19-853"><a href="#cb19-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-854"><a href="#cb19-854" aria-hidden="true" tabindex="-1"></a>perf.F <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">1</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">1</span>],perf[vec.L,,<span class="dv">3</span>,<span class="dv">1</span>])</span>
<span id="cb19-855"><a href="#cb19-855" aria-hidden="true" tabindex="-1"></a>perf.L <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">2</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">2</span>],perf[vec.L,,<span class="dv">3</span>,<span class="dv">2</span>])</span>
<span id="cb19-856"><a href="#cb19-856" aria-hidden="true" tabindex="-1"></a>perf.S <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">3</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">3</span>],perf[vec.L,,<span class="dv">3</span>,<span class="dv">3</span>])</span>
<span id="cb19-857"><a href="#cb19-857" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.F) <span class="ot">=</span> vec.L</span>
<span id="cb19-858"><a href="#cb19-858" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.L) <span class="ot">=</span> vec.L</span>
<span id="cb19-859"><a href="#cb19-859" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.S) <span class="ot">=</span> vec.L</span>
<span id="cb19-860"><a href="#cb19-860" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.F) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'50/10'</span>, <span class="st">'150/10'</span>, <span class="st">'50/40'</span>, <span class="st">'150/40'</span>, <span class="st">'50/60'</span>, <span class="st">'150/60'</span>)</span>
<span id="cb19-861"><a href="#cb19-861" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.L) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'50/10'</span>, <span class="st">'150/10'</span>, <span class="st">'50/40'</span>, <span class="st">'150/40'</span>, <span class="st">'50/60'</span>, <span class="st">'150/60'</span>)</span>
<span id="cb19-862"><a href="#cb19-862" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.S) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'50/10'</span>, <span class="st">'150/10'</span>, <span class="st">'50/40'</span>, <span class="st">'150/40'</span>, <span class="st">'50/60'</span>, <span class="st">'150/60'</span>)</span>
<span id="cb19-863"><a href="#cb19-863" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-864"><a href="#cb19-864" aria-hidden="true" tabindex="-1"></a><span class="co">#kable(perf)</span></span>
<span id="cb19-865"><a href="#cb19-865" aria-hidden="true" tabindex="-1"></a>perf.F <span class="sc">%&gt;%</span></span>
<span id="cb19-866"><a href="#cb19-866" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-867"><a href="#cb19-867" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">6</span>))</span>
<span id="cb19-868"><a href="#cb19-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-869"><a href="#cb19-869" aria-hidden="true" tabindex="-1"></a>perf.L <span class="sc">%&gt;%</span></span>
<span id="cb19-870"><a href="#cb19-870" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-871"><a href="#cb19-871" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">6</span>))</span>
<span id="cb19-872"><a href="#cb19-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-873"><a href="#cb19-873" aria-hidden="true" tabindex="-1"></a>perf.S <span class="sc">%&gt;%</span></span>
<span id="cb19-874"><a href="#cb19-874" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-875"><a href="#cb19-875" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">6</span>))</span>
<span id="cb19-876"><a href="#cb19-876" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-877"><a href="#cb19-877" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-878"><a href="#cb19-878" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-879"><a href="#cb19-879" aria-hidden="true" tabindex="-1"></a><span class="fu">## Confidence bands by correcting the bias {#sec-simudebias}</span></span>
<span id="cb19-880"><a href="#cb19-880" aria-hidden="true" tabindex="-1"></a>We illustrate the results given in @prp-CBf. </span>
<span id="cb19-881"><a href="#cb19-881" aria-hidden="true" tabindex="-1"></a>In @fig-Lstar, top row, we plot the confidence bands obtained for different dimensions $L \in <span class="sc">\{</span>3,5,11,15,21<span class="sc">\}</span>$ with Fourier, Legendre and Splines families and $\alpha=\beta=\sqrt{0.05}\approx 0.22$. We can see that all the confidence bands are alike. Especially, they are unbiased, even for $L=3$. A larger dimension $L$ provides a smoother band. </span>
<span id="cb19-882"><a href="#cb19-882" aria-hidden="true" tabindex="-1"></a>On the middle and bottom rows of @fig-Lstar, we illustrate the two terms that enter the confidence band, $t \mapsto \hat d_1^L(t)$ and $t\mapsto \hat d_2^{L,L_{\max}}(t)$. Their behavior is the same along time. The function $\hat d_1^L(t)$ can be seen as a variance, this is why it is larger near 0 and 1 where there are less observations. The function $\hat d_2^{L,L_{\max}}(t)$ is smaller than $\hat d_1^L(t)$ because it controls the remaining rest after the projection. Note that as expected when $L&gt;L^\varepsilon$, $\hat d_2^{L,L_{\max}}(t)$ is close to 0. As explained before, the influence of $L$ is not the same for the two functions. When $L$ increases, $\hat d_1^L(t)$ increases while $\hat d_2^{L,L_{\max}}(t)$ decreases. </span>
<span id="cb19-883"><a href="#cb19-883" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-884"><a href="#cb19-884" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height = 7, fig.width=7}</span></span>
<span id="cb19-885"><a href="#cb19-885" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-Lstar</span></span>
<span id="cb19-886"><a href="#cb19-886" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. For a given dataset, we plot several confidence bands (top row), functions dL (middle row) and dLLmax (bottom row). Bands and functions are estimated with Fourier (left column), Legendre (middle column) and Spline (right column) basis and several dimensions L (3, 5, 11, 15, 21)."</span></span>
<span id="cb19-887"><a href="#cb19-887" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-888"><a href="#cb19-888" aria-hidden="true" tabindex="-1"></a><span class="in">CB2 = function(data, basis, L, Lmax = 30, alpha = 0.05, beta = 0.05){</span></span>
<span id="cb19-889"><a href="#cb19-889" aria-hidden="true" tabindex="-1"></a><span class="in">  ### data: the observations, only the time-points and the individual functions</span></span>
<span id="cb19-890"><a href="#cb19-890" aria-hidden="true" tabindex="-1"></a><span class="in">  ### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb19-891"><a href="#cb19-891" aria-hidden="true" tabindex="-1"></a><span class="in">  ### L: number of functional basis for the signal</span></span>
<span id="cb19-892"><a href="#cb19-892" aria-hidden="true" tabindex="-1"></a><span class="in">  ### alpha: the level for the confidence band</span></span>
<span id="cb19-893"><a href="#cb19-893" aria-hidden="true" tabindex="-1"></a><span class="in">  data.1 = data.2 = data</span></span>
<span id="cb19-894"><a href="#cb19-894" aria-hidden="true" tabindex="-1"></a><span class="in">  ind.1 = sample(1:dim(data$y)[2], dim(data$y)[2]/2)</span></span>
<span id="cb19-895"><a href="#cb19-895" aria-hidden="true" tabindex="-1"></a><span class="in">  data.1$y = data$y[,ind.1]</span></span>
<span id="cb19-896"><a href="#cb19-896" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2$y = data$y[,-ind.1]</span></span>
<span id="cb19-897"><a href="#cb19-897" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-898"><a href="#cb19-898" aria-hidden="true" tabindex="-1"></a><span class="in">  ### d.L.1</span></span>
<span id="cb19-899"><a href="#cb19-899" aria-hidden="true" tabindex="-1"></a><span class="in">  est.1.f = estimator(data.1, basis, L)</span></span>
<span id="cb19-900"><a href="#cb19-900" aria-hidden="true" tabindex="-1"></a><span class="in">  data.1.proj = est.1.f$data.proj</span></span>
<span id="cb19-901"><a href="#cb19-901" aria-hidden="true" tabindex="-1"></a><span class="in">  data.1.scl = data.1.proj</span></span>
<span id="cb19-902"><a href="#cb19-902" aria-hidden="true" tabindex="-1"></a><span class="in">  data.1.scl$y = (data.1.proj$y - est.1.f$f.hat)/sqrt(diag(est.1.f$cov.emp))</span></span>
<span id="cb19-903"><a href="#cb19-903" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L.1 = compute.c.L(data.1.scl, alpha)</span></span>
<span id="cb19-904"><a href="#cb19-904" aria-hidden="true" tabindex="-1"></a><span class="in">  d.L.1 = c.L.1 %*% sqrt(diag(est.1.f$cov.emp)/ncol(data.1.scl$y))</span></span>
<span id="cb19-905"><a href="#cb19-905" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-906"><a href="#cb19-906" aria-hidden="true" tabindex="-1"></a><span class="in">  ### d.L.2</span></span>
<span id="cb19-907"><a href="#cb19-907" aria-hidden="true" tabindex="-1"></a><span class="in">  est.2.f = estimator(data.2, basis, L)</span></span>
<span id="cb19-908"><a href="#cb19-908" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.proj = est.2.f$data.proj</span></span>
<span id="cb19-909"><a href="#cb19-909" aria-hidden="true" tabindex="-1"></a><span class="in">  est.2.f.Lmax = estimator(data.2, basis, Lmax)</span></span>
<span id="cb19-910"><a href="#cb19-910" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.proj.Lmax = est.2.f.Lmax$data.proj</span></span>
<span id="cb19-911"><a href="#cb19-911" aria-hidden="true" tabindex="-1"></a><span class="in">  residuals.L.Lmax = data.2.proj.Lmax$y - data.2.proj$y - (est.2.f.Lmax$f.hat - est.2.f$f.hat) </span></span>
<span id="cb19-912"><a href="#cb19-912" aria-hidden="true" tabindex="-1"></a><span class="in">  cov.emp.rest = crossprod(t(residuals.L.Lmax)) / ncol(residuals.L.Lmax)</span></span>
<span id="cb19-913"><a href="#cb19-913" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.scl = data.2.proj</span></span>
<span id="cb19-914"><a href="#cb19-914" aria-hidden="true" tabindex="-1"></a><span class="in">  data.2.scl$y = residuals.L.Lmax/sqrt(diag(cov.emp.rest))</span></span>
<span id="cb19-915"><a href="#cb19-915" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L.Lmax.2 = compute.c.L(data.2.scl, beta)</span></span>
<span id="cb19-916"><a href="#cb19-916" aria-hidden="true" tabindex="-1"></a><span class="in">  d.L.Lmax.2 = c.L.Lmax.2 %*% sqrt(diag(cov.emp.rest)/ncol(data.2.scl$y))</span></span>
<span id="cb19-917"><a href="#cb19-917" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-918"><a href="#cb19-918" aria-hidden="true" tabindex="-1"></a><span class="in">  f.hat.up = est.2.f.Lmax$f.hat - est.2.f$f.hat + est.1.f$f.hat + d.L.1 + d.L.Lmax.2 </span></span>
<span id="cb19-919"><a href="#cb19-919" aria-hidden="true" tabindex="-1"></a><span class="in">  f.hat.low = est.2.f.Lmax$f.hat - est.2.f$f.hat + est.1.f$f.hat - d.L.1 - d.L.Lmax.2</span></span>
<span id="cb19-920"><a href="#cb19-920" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-921"><a href="#cb19-921" aria-hidden="true" tabindex="-1"></a><span class="in">  return(list(f.hat.up = f.hat.up, f.hat.low = f.hat.low, d.L = d.L.1, d.L.Lmax = d.L.Lmax.2, width = max(abs(f.hat.up-f.hat.low))))</span></span>
<span id="cb19-922"><a href="#cb19-922" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-923"><a href="#cb19-923" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-924"><a href="#cb19-924" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(1)</span></span>
<span id="cb19-925"><a href="#cb19-925" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-926"><a href="#cb19-926" aria-hidden="true" tabindex="-1"></a><span class="in">dfTrue = data.frame(Time = double(),</span></span>
<span id="cb19-927"><a href="#cb19-927" aria-hidden="true" tabindex="-1"></a><span class="in">                    f = double(),</span></span>
<span id="cb19-928"><a href="#cb19-928" aria-hidden="true" tabindex="-1"></a><span class="in">                    basis = character()</span></span>
<span id="cb19-929"><a href="#cb19-929" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb19-930"><a href="#cb19-930" aria-hidden="true" tabindex="-1"></a><span class="in">dfBandup = data.frame(Time = double(),</span></span>
<span id="cb19-931"><a href="#cb19-931" aria-hidden="true" tabindex="-1"></a><span class="in">                      bandup = double(),</span></span>
<span id="cb19-932"><a href="#cb19-932" aria-hidden="true" tabindex="-1"></a><span class="in">                      basis = character(),</span></span>
<span id="cb19-933"><a href="#cb19-933" aria-hidden="true" tabindex="-1"></a><span class="in">                      dimension = character()</span></span>
<span id="cb19-934"><a href="#cb19-934" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb19-935"><a href="#cb19-935" aria-hidden="true" tabindex="-1"></a><span class="in">dfBandlow = data.frame(Time = double(),</span></span>
<span id="cb19-936"><a href="#cb19-936" aria-hidden="true" tabindex="-1"></a><span class="in">                       bandlow = double(),</span></span>
<span id="cb19-937"><a href="#cb19-937" aria-hidden="true" tabindex="-1"></a><span class="in">                       basis = character(),</span></span>
<span id="cb19-938"><a href="#cb19-938" aria-hidden="true" tabindex="-1"></a><span class="in">                       dimension = character()</span></span>
<span id="cb19-939"><a href="#cb19-939" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb19-940"><a href="#cb19-940" aria-hidden="true" tabindex="-1"></a><span class="in">dfdL = data.frame(Time = double(),</span></span>
<span id="cb19-941"><a href="#cb19-941" aria-hidden="true" tabindex="-1"></a><span class="in">                  dLLmax = double(),</span></span>
<span id="cb19-942"><a href="#cb19-942" aria-hidden="true" tabindex="-1"></a><span class="in">                  basis = character(),</span></span>
<span id="cb19-943"><a href="#cb19-943" aria-hidden="true" tabindex="-1"></a><span class="in">                  dimension = character()</span></span>
<span id="cb19-944"><a href="#cb19-944" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb19-945"><a href="#cb19-945" aria-hidden="true" tabindex="-1"></a><span class="in">dfdLLmax = data.frame(Time = double(),</span></span>
<span id="cb19-946"><a href="#cb19-946" aria-hidden="true" tabindex="-1"></a><span class="in">                      dL = double(),</span></span>
<span id="cb19-947"><a href="#cb19-947" aria-hidden="true" tabindex="-1"></a><span class="in">                      basis = character(),</span></span>
<span id="cb19-948"><a href="#cb19-948" aria-hidden="true" tabindex="-1"></a><span class="in">                      dimension = character()</span></span>
<span id="cb19-949"><a href="#cb19-949" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb19-950"><a href="#cb19-950" aria-hidden="true" tabindex="-1"></a><span class="in">vec.L = c(3,5,11,15,21)</span></span>
<span id="cb19-951"><a href="#cb19-951" aria-hidden="true" tabindex="-1"></a><span class="in">for (basis in c("Legendre", "Fourier", "Splines")){</span></span>
<span id="cb19-952"><a href="#cb19-952" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == "Splines"){ data = dgp(n=50,N=40,sd=2*1,L.star=10, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-953"><a href="#cb19-953" aria-hidden="true" tabindex="-1"></a><span class="in">  } else { data = dgp(n=50,N=40,sd=1,L.star=10, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)}</span></span>
<span id="cb19-954"><a href="#cb19-954" aria-hidden="true" tabindex="-1"></a><span class="in">  dfTrue = rbind(dfTrue, data.frame(Time = data$time,</span></span>
<span id="cb19-955"><a href="#cb19-955" aria-hidden="true" tabindex="-1"></a><span class="in">                                    f = data$f.true,</span></span>
<span id="cb19-956"><a href="#cb19-956" aria-hidden="true" tabindex="-1"></a><span class="in">                                    basis = rep(basis, length(data$time))))</span></span>
<span id="cb19-957"><a href="#cb19-957" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-958"><a href="#cb19-958" aria-hidden="true" tabindex="-1"></a><span class="in">  crit.sel = matrix(NA, ncol = 3, nrow = 30)</span></span>
<span id="cb19-959"><a href="#cb19-959" aria-hidden="true" tabindex="-1"></a><span class="in">  for (L in vec.L){</span></span>
<span id="cb19-960"><a href="#cb19-960" aria-hidden="true" tabindex="-1"></a><span class="in">    conf.band.L.star.2 = CB2(data, basis, L, Lmax = 30, alpha = 0.05)</span></span>
<span id="cb19-961"><a href="#cb19-961" aria-hidden="true" tabindex="-1"></a><span class="in">    crit.sel[L,] =c(max(conf.band.L.star.2$d.L), max(conf.band.L.star.2$d.L.Lmax),</span></span>
<span id="cb19-962"><a href="#cb19-962" aria-hidden="true" tabindex="-1"></a><span class="in">                    sum(abs(conf.band.L.star.2$d.L+conf.band.L.star.2$d.L.Lmax)))</span></span>
<span id="cb19-963"><a href="#cb19-963" aria-hidden="true" tabindex="-1"></a><span class="in">    dfBandup = rbind(dfBandup, data.frame(Time = data$time,</span></span>
<span id="cb19-964"><a href="#cb19-964" aria-hidden="true" tabindex="-1"></a><span class="in">                                          bandup = t(conf.band.L.star.2$f.hat.up),</span></span>
<span id="cb19-965"><a href="#cb19-965" aria-hidden="true" tabindex="-1"></a><span class="in">                                          basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-966"><a href="#cb19-966" aria-hidden="true" tabindex="-1"></a><span class="in">                                          dimension = as.factor(rep(L, length(data$time)))))</span></span>
<span id="cb19-967"><a href="#cb19-967" aria-hidden="true" tabindex="-1"></a><span class="in">    dfBandlow = rbind(dfBandlow, data.frame(Time = data$time,</span></span>
<span id="cb19-968"><a href="#cb19-968" aria-hidden="true" tabindex="-1"></a><span class="in">                                            bandlow = t(conf.band.L.star.2$f.hat.low),</span></span>
<span id="cb19-969"><a href="#cb19-969" aria-hidden="true" tabindex="-1"></a><span class="in">                                            basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-970"><a href="#cb19-970" aria-hidden="true" tabindex="-1"></a><span class="in">                                            dimension = as.factor(rep(L, length(data$time)))))</span></span>
<span id="cb19-971"><a href="#cb19-971" aria-hidden="true" tabindex="-1"></a><span class="in">    dfdL = rbind(dfdL, data.frame(Time = data$time,</span></span>
<span id="cb19-972"><a href="#cb19-972" aria-hidden="true" tabindex="-1"></a><span class="in">                                  dL = t(conf.band.L.star.2$d.L),</span></span>
<span id="cb19-973"><a href="#cb19-973" aria-hidden="true" tabindex="-1"></a><span class="in">                                  basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-974"><a href="#cb19-974" aria-hidden="true" tabindex="-1"></a><span class="in">                                  dimension = as.factor(rep(L, length(data$time)))))</span></span>
<span id="cb19-975"><a href="#cb19-975" aria-hidden="true" tabindex="-1"></a><span class="in">    dfdLLmax = rbind(dfdLLmax, data.frame(Time = data$time,</span></span>
<span id="cb19-976"><a href="#cb19-976" aria-hidden="true" tabindex="-1"></a><span class="in">                                          dLLmax = t(conf.band.L.star.2$d.L.Lmax),</span></span>
<span id="cb19-977"><a href="#cb19-977" aria-hidden="true" tabindex="-1"></a><span class="in">                                          basis = rep(basis, length(data$time)),</span></span>
<span id="cb19-978"><a href="#cb19-978" aria-hidden="true" tabindex="-1"></a><span class="in">                                          dimension = as.factor(rep(L, length(data$time)))))</span></span>
<span id="cb19-979"><a href="#cb19-979" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb19-980"><a href="#cb19-980" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-981"><a href="#cb19-981" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-982"><a href="#cb19-982" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-983"><a href="#cb19-983" aria-hidden="true" tabindex="-1"></a><span class="in">p1 &lt;- ggplot()+</span></span>
<span id="cb19-984"><a href="#cb19-984" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfTrue, aes(x = Time, y = f)) +</span></span>
<span id="cb19-985"><a href="#cb19-985" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfBandup, aes(x = Time, y = bandup, group = dimension, color = dimension), linewidth = 0.4) +</span></span>
<span id="cb19-986"><a href="#cb19-986" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfBandlow, aes(x = Time, y = bandlow, group = dimension, color = dimension), linewidth = 0.4) +</span></span>
<span id="cb19-987"><a href="#cb19-987" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~ basis)</span></span>
<span id="cb19-988"><a href="#cb19-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-989"><a href="#cb19-989" aria-hidden="true" tabindex="-1"></a><span class="in">p2 &lt;- ggplot() + </span></span>
<span id="cb19-990"><a href="#cb19-990" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfdL, aes(x = Time, y = dL, group = dimension, color = dimension), linewidth = 0.4) + </span></span>
<span id="cb19-991"><a href="#cb19-991" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid( ~ basis) + ylab("d.L")</span></span>
<span id="cb19-992"><a href="#cb19-992" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-993"><a href="#cb19-993" aria-hidden="true" tabindex="-1"></a><span class="in">p3 &lt;- ggplot() + </span></span>
<span id="cb19-994"><a href="#cb19-994" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfdLLmax, aes(x = Time, y = dLLmax, group = dimension, color = dimension), linewidth = 0.4) + </span></span>
<span id="cb19-995"><a href="#cb19-995" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid( ~ basis) + ylab("d.L.Lmax")</span></span>
<span id="cb19-996"><a href="#cb19-996" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-997"><a href="#cb19-997" aria-hidden="true" tabindex="-1"></a><span class="in">ggarrange(p1, p2, p3, nrow = 3, common.legend = TRUE, legend = "bottom")</span></span>
<span id="cb19-998"><a href="#cb19-998" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-999"><a href="#cb19-999" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1000"><a href="#cb19-1000" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1001"><a href="#cb19-1001" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1002"><a href="#cb19-1002" aria-hidden="true" tabindex="-1"></a>In @tbl-levLstar, we simulate 1000 repeated datasets with the Legendre family and with two sample sizes $n=50$ and $n=150$ and $N=40$. For each dataset, we compute the confidence band defined in @prp-CBf with a theoretical confidence level of $1-\alpha\beta=0.95$ and for different values of $L$. Then the confidence level is approximated as the proportion of confidence bands containing the true function $f$. Remark that when $L&lt;L^{\varepsilon}$, the level is the expected one, that is 0.95. When $L&gt;L^{\varepsilon}$, the level is not more ensured, as explained before. Indeed the term $d^{L,L^{\max}}$ is mainly equal to 0, and the level is close to $1-\alpha$ instead of $1-\alpha\beta$. This is not the case for the band in @sec-bandSun, as this is due to the correction of the bias. </span>
<span id="cb19-1005"><a href="#cb19-1005" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb19-1006"><a href="#cb19-1006" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-levLstar</span></span>
<span id="cb19-1007"><a href="#cb19-1007" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Illustrative example. We display the level of confidence for the proposed confidence band CB2, for several L in rows and several n in columns, N=40, for alpha=0.2 and beta=0.2 (and then in total the confidence band reaches the level 0.95), and considering the Legendre family."</span></span>
<span id="cb19-1008"><a href="#cb19-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1009"><a href="#cb19-1009" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb19-1010"><a href="#cb19-1010" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb19-1011"><a href="#cb19-1011" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb19-1012"><a href="#cb19-1012" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb19-1013"><a href="#cb19-1013" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb19-1014"><a href="#cb19-1014" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb19-1015"><a href="#cb19-1015" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb19-1016"><a href="#cb19-1016" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb19-1017"><a href="#cb19-1017" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> <span class="fu">max</span>(vec.L), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb19-1018"><a href="#cb19-1018" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-1019"><a href="#cb19-1019" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-1020"><a href="#cb19-1020" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb19-1021"><a href="#cb19-1021" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb19-1022"><a href="#cb19-1022" aria-hidden="true" tabindex="-1"></a>      cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb19-1023"><a href="#cb19-1023" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb19-1024"><a href="#cb19-1024" aria-hidden="true" tabindex="-1"></a>        <span class="fu">set.seed</span>(rep)</span>
<span id="cb19-1025"><a href="#cb19-1025" aria-hidden="true" tabindex="-1"></a>        data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">basis =</span> <span class="st">"Legendre"</span>)</span>
<span id="cb19-1026"><a href="#cb19-1026" aria-hidden="true" tabindex="-1"></a>        conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">CB2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.2</span>, <span class="at">beta=</span><span class="fl">0.2</span>)</span>
<span id="cb19-1027"><a href="#cb19-1027" aria-hidden="true" tabindex="-1"></a>        f.true <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> data<span class="sc">$</span>f.true, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1028"><a href="#cb19-1028" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1029"><a href="#cb19-1029" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1030"><a href="#cb19-1030" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb19-1031"><a href="#cb19-1031" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span>} </span>
<span id="cb19-1032"><a href="#cb19-1032" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb19-1033"><a href="#cb19-1033" aria-hidden="true" tabindex="-1"></a>      perf[L,ind.n] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb19-1034"><a href="#cb19-1034" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb19-1035"><a href="#cb19-1035" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-1036"><a href="#cb19-1036" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> perf[vec.L,]</span>
<span id="cb19-1037"><a href="#cb19-1037" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(perf) <span class="ot">=</span> vec.L</span>
<span id="cb19-1038"><a href="#cb19-1038" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(perf) <span class="ot">=</span> vec.n</span>
<span id="cb19-1039"><a href="#cb19-1039" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab2.RData"</span>)</span>
<span id="cb19-1040"><a href="#cb19-1040" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_Tab2.RData'</span>)}</span>
<span id="cb19-1041"><a href="#cb19-1041" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1042"><a href="#cb19-1042" aria-hidden="true" tabindex="-1"></a>perf <span class="sc">%&gt;%</span></span>
<span id="cb19-1043"><a href="#cb19-1043" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-1044"><a href="#cb19-1044" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n"</span> <span class="ot">=</span> <span class="dv">2</span>))</span>
<span id="cb19-1045"><a href="#cb19-1045" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1046"><a href="#cb19-1046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1047"><a href="#cb19-1047" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1048"><a href="#cb19-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1049"><a href="#cb19-1049" aria-hidden="true" tabindex="-1"></a>We illustrate the different terms involved in @eq-def-Lhat. In @fig-dLLmax, we plot for a given dataset, the infinity norm of the width of the band $\hat d^L(t) + \hat d^{L,L_{\max}}(t)$ (top), of $\hat d^L(t)$ (middle) and $\hat d^{L,L_{\max}}(t)$ (bottom) functions obtained with the Fourier (left column), Legendre (middle column) and Spline (right column) basis. As already said, $\|\hat d^L\|_{\infty}$ increases with $L$ while $\|\hat d^{L,L_{\max}}\|_{\infty}$ decreases (and is zero when $L&gt;L^{\varepsilon}$). The width of the band wrt $L$ does not have a $U$-shape, as expected. It is thus difficult to minimize this criterion and the selection of $\hat L$ is thus not stable. But again, whatever the value of $\hat L$, the corresponding band is debiased in the collection. <span class="in">`r colorize("We will see in the next section that its width is smaller than standard approaches.", "red")`</span> </span>
<span id="cb19-1050"><a href="#cb19-1050" aria-hidden="true" tabindex="-1"></a>The performance of the selection is <span class="in">`r colorize("also", "red")`</span> illustrated in the next section. </span>
<span id="cb19-1051"><a href="#cb19-1051" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1052"><a href="#cb19-1052" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "50%", fig.width=7}</span></span>
<span id="cb19-1053"><a href="#cb19-1053" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-dLLmax</span></span>
<span id="cb19-1054"><a href="#cb19-1054" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. For a given dataset, we calculate the norm of the width of the confidence band (top), of the dL function (middle) and the dLLmax function (bottom), for several dimensions L and for Fourier (left column), Legendre (middle column) and Splines (right column) basis." </span></span>
<span id="cb19-1055"><a href="#cb19-1055" aria-hidden="true" tabindex="-1"></a><span class="in">#| </span></span>
<span id="cb19-1056"><a href="#cb19-1056" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(1)</span></span>
<span id="cb19-1057"><a href="#cb19-1057" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1058"><a href="#cb19-1058" aria-hidden="true" tabindex="-1"></a><span class="in">df = data.frame(Norm = double(),</span></span>
<span id="cb19-1059"><a href="#cb19-1059" aria-hidden="true" tabindex="-1"></a><span class="in">                type = character(),</span></span>
<span id="cb19-1060"><a href="#cb19-1060" aria-hidden="true" tabindex="-1"></a><span class="in">                basis = character(),</span></span>
<span id="cb19-1061"><a href="#cb19-1061" aria-hidden="true" tabindex="-1"></a><span class="in">                dimension = integer()</span></span>
<span id="cb19-1062"><a href="#cb19-1062" aria-hidden="true" tabindex="-1"></a><span class="in">)</span></span>
<span id="cb19-1063"><a href="#cb19-1063" aria-hidden="true" tabindex="-1"></a><span class="in">L.max = 30</span></span>
<span id="cb19-1064"><a href="#cb19-1064" aria-hidden="true" tabindex="-1"></a><span class="in">for (basis in c("Legendre", "Fourier", "Splines")){</span></span>
<span id="cb19-1065"><a href="#cb19-1065" aria-hidden="true" tabindex="-1"></a><span class="in">  vec.L = seq(3,29, by=1)</span></span>
<span id="cb19-1066"><a href="#cb19-1066" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == 'Fourier'){ vec.L = seq(3,29, by=2)}</span></span>
<span id="cb19-1067"><a href="#cb19-1067" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == "Splines"){   data = dgp(n=50,N=40, basis = basis, sd = 2)</span></span>
<span id="cb19-1068"><a href="#cb19-1068" aria-hidden="true" tabindex="-1"></a><span class="in">  } else data = dgp(n=50,N=40, basis = basis)</span></span>
<span id="cb19-1069"><a href="#cb19-1069" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1070"><a href="#cb19-1070" aria-hidden="true" tabindex="-1"></a><span class="in">  length.band = d.L = d.L.Lmax = NULL</span></span>
<span id="cb19-1071"><a href="#cb19-1071" aria-hidden="true" tabindex="-1"></a><span class="in">  for (L in vec.L){</span></span>
<span id="cb19-1072"><a href="#cb19-1072" aria-hidden="true" tabindex="-1"></a><span class="in">    conf.band.L.star.2 = CB2(data, basis, L, Lmax = L.max, alpha = sqrt(0.05), beta = sqrt(0.05))</span></span>
<span id="cb19-1073"><a href="#cb19-1073" aria-hidden="true" tabindex="-1"></a><span class="in">    length.band = c(length.band, conf.band.L.star.2$width)</span></span>
<span id="cb19-1074"><a href="#cb19-1074" aria-hidden="true" tabindex="-1"></a><span class="in">    d.L = c(d.L, max(conf.band.L.star.2$d.L))</span></span>
<span id="cb19-1075"><a href="#cb19-1075" aria-hidden="true" tabindex="-1"></a><span class="in">    d.L.Lmax = c(d.L.Lmax, max(conf.band.L.star.2$d.L.Lmax))</span></span>
<span id="cb19-1076"><a href="#cb19-1076" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1077"><a href="#cb19-1077" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1078"><a href="#cb19-1078" aria-hidden="true" tabindex="-1"></a><span class="in">  df = rbind(df, data.frame (Norm = c(length.band, d.L, d.L.Lmax),</span></span>
<span id="cb19-1079"><a href="#cb19-1079" aria-hidden="true" tabindex="-1"></a><span class="in">                             type = rep(c("Band width norm", "d.L norm", "d.L.Lmax norm"), each = length(vec.L)),</span></span>
<span id="cb19-1080"><a href="#cb19-1080" aria-hidden="true" tabindex="-1"></a><span class="in">                             basis = rep(basis, 3* length(vec.L)),</span></span>
<span id="cb19-1081"><a href="#cb19-1081" aria-hidden="true" tabindex="-1"></a><span class="in">                             dimension = rep(vec.L, 3)))</span></span>
<span id="cb19-1082"><a href="#cb19-1082" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-1083"><a href="#cb19-1083" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1084"><a href="#cb19-1084" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(df, aes(x = dimension, y = Norm, fill = type)) +</span></span>
<span id="cb19-1085"><a href="#cb19-1085" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line() + </span></span>
<span id="cb19-1086"><a href="#cb19-1086" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(type ~ basis, scales = 'free') + xlab("L")</span></span>
<span id="cb19-1087"><a href="#cb19-1087" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1088"><a href="#cb19-1088" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1089"><a href="#cb19-1089" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1090"><a href="#cb19-1090" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model selection criterion {#sec-simumodsel}</span></span>
<span id="cb19-1091"><a href="#cb19-1091" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1092"><a href="#cb19-1092" aria-hidden="true" tabindex="-1"></a>We <span class="in">`r colorize("want to", "red")`</span> evaluate the performance of the <span class="in">`r colorize("two", "red")`</span> selection criteria introduced in this paper.</span>
<span id="cb19-1093"><a href="#cb19-1093" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1094"><a href="#cb19-1094" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1095"><a href="#cb19-1095" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("First, we consider the second approach presented in @sec-modsel. ", "red")`</span></span>
<span id="cb19-1096"><a href="#cb19-1096" aria-hidden="true" tabindex="-1"></a>In @fig-critlast, we illustrate the behavior of the selection criterion introduced in @sec-modsel on simulated data, with $\lambda=1$ for the three basis. We can see that $\tilde L$ is overestimated. When considering nested spaces, it ensures that $\tilde L$ tends to be larger than $L^*$ and thus the confidence band is automatically unbiased.</span>
<span id="cb19-1097"><a href="#cb19-1097" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1098"><a href="#cb19-1098" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1099"><a href="#cb19-1099" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height = 3, fig.width=7}</span></span>
<span id="cb19-1100"><a href="#cb19-1100" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-critlast</span></span>
<span id="cb19-1101"><a href="#cb19-1101" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. For a given simulated dataset, we show the behavior of the criteria as a function of dimension L, for several lambdas, for Fourier (left), Legendre (middle) and Splines (right) basis."</span></span>
<span id="cb19-1102"><a href="#cb19-1102" aria-hidden="true" tabindex="-1"></a><span class="in">#| </span></span>
<span id="cb19-1103"><a href="#cb19-1103" aria-hidden="true" tabindex="-1"></a><span class="in">L.max = 30</span></span>
<span id="cb19-1104"><a href="#cb19-1104" aria-hidden="true" tabindex="-1"></a><span class="in">dfCriterion = data.frame(criterion = double(),</span></span>
<span id="cb19-1105"><a href="#cb19-1105" aria-hidden="true" tabindex="-1"></a><span class="in">                         dimension = integer(),</span></span>
<span id="cb19-1106"><a href="#cb19-1106" aria-hidden="true" tabindex="-1"></a><span class="in">                         basis = character())</span></span>
<span id="cb19-1107"><a href="#cb19-1107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1108"><a href="#cb19-1108" aria-hidden="true" tabindex="-1"></a><span class="in">for (basis in c("Legendre","Fourier", "Splines")){</span></span>
<span id="cb19-1109"><a href="#cb19-1109" aria-hidden="true" tabindex="-1"></a><span class="in">  vec.L = seq(3,29, by=1)</span></span>
<span id="cb19-1110"><a href="#cb19-1110" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == 'Fourier'){ vec.L = seq(3,29, by=2) }</span></span>
<span id="cb19-1111"><a href="#cb19-1111" aria-hidden="true" tabindex="-1"></a><span class="in">  length.band = c.L = c.L.Lmax = c()</span></span>
<span id="cb19-1112"><a href="#cb19-1112" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == "Splines"){  data = dgp(n=50,N=40, basis = basis, L.eps = 28, sd=2)</span></span>
<span id="cb19-1113"><a href="#cb19-1113" aria-hidden="true" tabindex="-1"></a><span class="in">  } else {  data = dgp(n=50,N=40, basis = basis, L.eps = 28, sd = 1)}</span></span>
<span id="cb19-1114"><a href="#cb19-1114" aria-hidden="true" tabindex="-1"></a><span class="in">  conf.band.L.max = CB1(data, basis, L = L.max, alpha = 0.05)</span></span>
<span id="cb19-1115"><a href="#cb19-1115" aria-hidden="true" tabindex="-1"></a><span class="in">  c.Lmax = conf.band.L.max$c.L </span></span>
<span id="cb19-1116"><a href="#cb19-1116" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1117"><a href="#cb19-1117" aria-hidden="true" tabindex="-1"></a><span class="in">  for (L in vec.L){</span></span>
<span id="cb19-1118"><a href="#cb19-1118" aria-hidden="true" tabindex="-1"></a><span class="in">    conf.band.L = CB1(data, basis, L, alpha = (0.05))</span></span>
<span id="cb19-1119"><a href="#cb19-1119" aria-hidden="true" tabindex="-1"></a><span class="in">    length.band[L] = conf.band.L$width</span></span>
<span id="cb19-1120"><a href="#cb19-1120" aria-hidden="true" tabindex="-1"></a><span class="in">    c.L[L] = max(conf.band.L$c.L)</span></span>
<span id="cb19-1121"><a href="#cb19-1121" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1122"><a href="#cb19-1122" aria-hidden="true" tabindex="-1"></a><span class="in">  for (lambda in c(0, 0.5, 1, 2)){</span></span>
<span id="cb19-1123"><a href="#cb19-1123" aria-hidden="true" tabindex="-1"></a><span class="in">    crit = abs(rep(c.Lmax, length(vec.L)) - c.L[vec.L]) + lambda * vec.L/((dim(data$y)[1]))</span></span>
<span id="cb19-1124"><a href="#cb19-1124" aria-hidden="true" tabindex="-1"></a><span class="in">    dfCriterion = rbind(dfCriterion, data.frame(criterion = crit,</span></span>
<span id="cb19-1125"><a href="#cb19-1125" aria-hidden="true" tabindex="-1"></a><span class="in">                                                dimension = vec.L,</span></span>
<span id="cb19-1126"><a href="#cb19-1126" aria-hidden="true" tabindex="-1"></a><span class="in">                                                lambdas = lambda,</span></span>
<span id="cb19-1127"><a href="#cb19-1127" aria-hidden="true" tabindex="-1"></a><span class="in">                                                basis = rep(basis, length(vec.L))))</span></span>
<span id="cb19-1128"><a href="#cb19-1128" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1129"><a href="#cb19-1129" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1130"><a href="#cb19-1130" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-1131"><a href="#cb19-1131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1132"><a href="#cb19-1132" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(dfCriterion, aes(x = dimension, y = criterion, color = lambdas)) + </span></span>
<span id="cb19-1133"><a href="#cb19-1133" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point()+</span></span>
<span id="cb19-1134"><a href="#cb19-1134" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-1135"><a href="#cb19-1135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1136"><a href="#cb19-1136" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1137"><a href="#cb19-1137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1138"><a href="#cb19-1138" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("We compare the two strategies $CB_2$ and $CB_3$ with some standard approaches. More precisely, ", "red")`</span></span>
<span id="cb19-1139"><a href="#cb19-1139" aria-hidden="true" tabindex="-1"></a>we  simulate 100 repeated datasets. The different confidence bands and the norm of their widths are computed for several $L$. We apply the selection criteria and plot the distribution of the estimated dimension in @fig-modelsel, for the three basis families, for several model selection criteria: $\hat L$, $\tilde L$,  cross validation and  hard thresholding. The dimension $\hat L$ is almost always larger than the true $L^*=11$. The fact that it is larger is not a problem because the selected band is unbiased and has the correct level as soon as $L^\varepsilon$ is large. However, the criterion tends to select a band that is (too) smooth.</span>
<span id="cb19-1140"><a href="#cb19-1140" aria-hidden="true" tabindex="-1"></a>We can see that the selected dimension $\tilde{L}$ is smaller in distribution, and closer to the true value than $\hat{L}$. In addition, as we then use the confidence band of @sec-bandSun, the confidence level is guaranteed to be as expected.</span>
<span id="cb19-1141"><a href="#cb19-1141" aria-hidden="true" tabindex="-1"></a>The model selected by  cross validation is rather good, for all the  basis considered. On the other hand, the model selected by  hard thresholding is not good,  particularly for a non orthonormal basis, which makes sense in relation to  @prp-proj. </span>
<span id="cb19-1142"><a href="#cb19-1142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1143"><a href="#cb19-1143" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height = 7, fig.width=7}</span></span>
<span id="cb19-1144"><a href="#cb19-1144" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-levLstar2</span></span>
<span id="cb19-1145"><a href="#cb19-1145" aria-hidden="true" tabindex="-1"></a><span class="in">#| tbl-cap: "Illustrative example. We display the level of confidence over 100 repetitions for the proposed confidence band CB3, for several model selection criterion in rows and several basis in columns, for alpha=0.05."</span></span>
<span id="cb19-1146"><a href="#cb19-1146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1147"><a href="#cb19-1147" aria-hidden="true" tabindex="-1"></a><span class="in">#| </span></span>
<span id="cb19-1148"><a href="#cb19-1148" aria-hidden="true" tabindex="-1"></a><span class="in">run = FALSE</span></span>
<span id="cb19-1149"><a href="#cb19-1149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1150"><a href="#cb19-1150" aria-hidden="true" tabindex="-1"></a><span class="in">if (run == TRUE){</span></span>
<span id="cb19-1151"><a href="#cb19-1151" aria-hidden="true" tabindex="-1"></a><span class="in">  repet = 100</span></span>
<span id="cb19-1152"><a href="#cb19-1152" aria-hidden="true" tabindex="-1"></a><span class="in">  length.CBL.CV = length.CBL.L0 = c(NA)</span></span>
<span id="cb19-1153"><a href="#cb19-1153" aria-hidden="true" tabindex="-1"></a><span class="in">  dfLengthSelect.CV = data.frame(length = double(), basis = character())</span></span>
<span id="cb19-1154"><a href="#cb19-1154" aria-hidden="true" tabindex="-1"></a><span class="in">  dfLhatSelect.CV = dfLhatSelect.L0 = data.frame(Lhat = double(), L = integer(), basis = character())</span></span>
<span id="cb19-1155"><a href="#cb19-1155" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1156"><a href="#cb19-1156" aria-hidden="true" tabindex="-1"></a><span class="in">  dfBandWidth = data.frame(Band.width = double(),</span></span>
<span id="cb19-1157"><a href="#cb19-1157" aria-hidden="true" tabindex="-1"></a><span class="in">                           basis = character(),</span></span>
<span id="cb19-1158"><a href="#cb19-1158" aria-hidden="true" tabindex="-1"></a><span class="in">                           dimension = integer())</span></span>
<span id="cb19-1159"><a href="#cb19-1159" aria-hidden="true" tabindex="-1"></a><span class="in">  dfLhat = data.frame(Lhat = double(), L = integer(), basis = character())</span></span>
<span id="cb19-1160"><a href="#cb19-1160" aria-hidden="true" tabindex="-1"></a><span class="in">  ind.basis = 0</span></span>
<span id="cb19-1161"><a href="#cb19-1161" aria-hidden="true" tabindex="-1"></a><span class="in">  cpt = matrix(0, nrow = 6, ncol = 3)</span></span>
<span id="cb19-1162"><a href="#cb19-1162" aria-hidden="true" tabindex="-1"></a><span class="in">  for (basis in c("Legendre", "Fourier", "Splines")){</span></span>
<span id="cb19-1163"><a href="#cb19-1163" aria-hidden="true" tabindex="-1"></a><span class="in">    ind.basis = ind.basis + 1</span></span>
<span id="cb19-1164"><a href="#cb19-1164" aria-hidden="true" tabindex="-1"></a><span class="in">    vec.L = seq(3,29, by=1)</span></span>
<span id="cb19-1165"><a href="#cb19-1165" aria-hidden="true" tabindex="-1"></a><span class="in">    mod.sel = mod.sel.L0 = mod.sel.CV = coeff.L0 = err = c()</span></span>
<span id="cb19-1166"><a href="#cb19-1166" aria-hidden="true" tabindex="-1"></a><span class="in">    if (basis == 'Fourier'){ vec.L = seq(3,29, by=2)}</span></span>
<span id="cb19-1167"><a href="#cb19-1167" aria-hidden="true" tabindex="-1"></a><span class="in">    mod.sel = matrix(NA, nrow = repet, ncol = 5)</span></span>
<span id="cb19-1168"><a href="#cb19-1168" aria-hidden="true" tabindex="-1"></a><span class="in">    L.mod.sel = c.L = c()</span></span>
<span id="cb19-1169"><a href="#cb19-1169" aria-hidden="true" tabindex="-1"></a><span class="in">    Lmax = 30</span></span>
<span id="cb19-1170"><a href="#cb19-1170" aria-hidden="true" tabindex="-1"></a><span class="in">    ind = c()</span></span>
<span id="cb19-1171"><a href="#cb19-1171" aria-hidden="true" tabindex="-1"></a><span class="in">    for (rep in 1:repet){print(rep)</span></span>
<span id="cb19-1172"><a href="#cb19-1172" aria-hidden="true" tabindex="-1"></a><span class="in">      set.seed(rep)</span></span>
<span id="cb19-1173"><a href="#cb19-1173" aria-hidden="true" tabindex="-1"></a><span class="in">      if (basis == "Splines"){      data = dgp(n=50, N=40, basis = basis, sd = 2)</span></span>
<span id="cb19-1174"><a href="#cb19-1174" aria-hidden="true" tabindex="-1"></a><span class="in">      } else  {data = dgp(n=50, N=40, basis = basis)}</span></span>
<span id="cb19-1175"><a href="#cb19-1175" aria-hidden="true" tabindex="-1"></a><span class="in">      length.band = NULL</span></span>
<span id="cb19-1176"><a href="#cb19-1176" aria-hidden="true" tabindex="-1"></a><span class="in">      data.train = data.test = data</span></span>
<span id="cb19-1177"><a href="#cb19-1177" aria-hidden="true" tabindex="-1"></a><span class="in">      data.train$y = data$y[, 1:(dim(data$y)[2]/2)]</span></span>
<span id="cb19-1178"><a href="#cb19-1178" aria-hidden="true" tabindex="-1"></a><span class="in">      data.test$y = data$y[,(dim(data$y)[2]/2+1) : (dim(data$y)[2])]</span></span>
<span id="cb19-1179"><a href="#cb19-1179" aria-hidden="true" tabindex="-1"></a><span class="in">      tot.VC &lt;- rep(1:10, each = dim(data.train$y)[2] / 10)</span></span>
<span id="cb19-1180"><a href="#cb19-1180" aria-hidden="true" tabindex="-1"></a><span class="in">      err &lt;- sapply(vec.L, function(L) {</span></span>
<span id="cb19-1181"><a href="#cb19-1181" aria-hidden="true" tabindex="-1"></a><span class="in">        mean(sapply(1:10, function(VC) {</span></span>
<span id="cb19-1182"><a href="#cb19-1182" aria-hidden="true" tabindex="-1"></a><span class="in">          train &lt;- data.train</span></span>
<span id="cb19-1183"><a href="#cb19-1183" aria-hidden="true" tabindex="-1"></a><span class="in">          train$y &lt;- train$y[,-which(tot.VC == VC)]</span></span>
<span id="cb19-1184"><a href="#cb19-1184" aria-hidden="true" tabindex="-1"></a><span class="in">          test &lt;- data.train</span></span>
<span id="cb19-1185"><a href="#cb19-1185" aria-hidden="true" tabindex="-1"></a><span class="in">          test$y &lt;- test$y[, which(tot.VC == VC)]</span></span>
<span id="cb19-1186"><a href="#cb19-1186" aria-hidden="true" tabindex="-1"></a><span class="in">          est.L &lt;- estimator(train, basis, L)</span></span>
<span id="cb19-1187"><a href="#cb19-1187" aria-hidden="true" tabindex="-1"></a><span class="in">          sqrt(mean((test$y - est.L$f.hat)^2))</span></span>
<span id="cb19-1188"><a href="#cb19-1188" aria-hidden="true" tabindex="-1"></a><span class="in">        }))</span></span>
<span id="cb19-1189"><a href="#cb19-1189" aria-hidden="true" tabindex="-1"></a><span class="in">      })</span></span>
<span id="cb19-1190"><a href="#cb19-1190" aria-hidden="true" tabindex="-1"></a><span class="in">      for (L in vec.L){</span></span>
<span id="cb19-1191"><a href="#cb19-1191" aria-hidden="true" tabindex="-1"></a><span class="in">        CB2.L = CB2(data, basis = basis, L, Lmax = 30, alpha = sqrt(0.05), beta = sqrt(0.05))</span></span>
<span id="cb19-1192"><a href="#cb19-1192" aria-hidden="true" tabindex="-1"></a><span class="in">        length.band = c(length.band, CB2.L$width)</span></span>
<span id="cb19-1193"><a href="#cb19-1193" aria-hidden="true" tabindex="-1"></a><span class="in">        conf.band.L = CB1(data, basis, L, alpha = (0.05))</span></span>
<span id="cb19-1194"><a href="#cb19-1194" aria-hidden="true" tabindex="-1"></a><span class="in">        c.L[L] = max(conf.band.L$c.L)</span></span>
<span id="cb19-1195"><a href="#cb19-1195" aria-hidden="true" tabindex="-1"></a><span class="in">        est.L = estimator(data.train, basis, L)</span></span>
<span id="cb19-1196"><a href="#cb19-1196" aria-hidden="true" tabindex="-1"></a><span class="in">        coeff.L0[L] = sum(abs(est.L$mu.hat) &gt; 0.1)</span></span>
<span id="cb19-1197"><a href="#cb19-1197" aria-hidden="true" tabindex="-1"></a><span class="in">      }</span></span>
<span id="cb19-1198"><a href="#cb19-1198" aria-hidden="true" tabindex="-1"></a><span class="in">      mod.sel[rep,1:2] = c(min(length.band), vec.L[which.min(length.band)])</span></span>
<span id="cb19-1199"><a href="#cb19-1199" aria-hidden="true" tabindex="-1"></a><span class="in">      CB2.Lhat = CB2(data, basis = basis, mod.sel[rep,2], Lmax = 30, alpha = sqrt(0.05), beta = sqrt(0.05))</span></span>
<span id="cb19-1200"><a href="#cb19-1200" aria-hidden="true" tabindex="-1"></a><span class="in">      </span></span>
<span id="cb19-1201"><a href="#cb19-1201" aria-hidden="true" tabindex="-1"></a><span class="in">      conf.band.L.max = CB1(data, basis, L = Lmax, alpha = 0.05)</span></span>
<span id="cb19-1202"><a href="#cb19-1202" aria-hidden="true" tabindex="-1"></a><span class="in">      c.Lmax = conf.band.L.max$c.L </span></span>
<span id="cb19-1203"><a href="#cb19-1203" aria-hidden="true" tabindex="-1"></a><span class="in">      mod.sel[rep,3] = conf.band.L.max$width</span></span>
<span id="cb19-1204"><a href="#cb19-1204" aria-hidden="true" tabindex="-1"></a><span class="in">      conf.band.L.star = CB1(data, basis, L = 11, alpha = 0.05)</span></span>
<span id="cb19-1205"><a href="#cb19-1205" aria-hidden="true" tabindex="-1"></a><span class="in">      mod.sel[rep,4] = conf.band.L.star$width</span></span>
<span id="cb19-1206"><a href="#cb19-1206" aria-hidden="true" tabindex="-1"></a><span class="in">      </span></span>
<span id="cb19-1207"><a href="#cb19-1207" aria-hidden="true" tabindex="-1"></a><span class="in">      lambda = 1</span></span>
<span id="cb19-1208"><a href="#cb19-1208" aria-hidden="true" tabindex="-1"></a><span class="in">      crit = abs(rep(c.Lmax, length(vec.L)) - c.L[vec.L]) + lambda * vec.L/((dim(data$y)[1]))</span></span>
<span id="cb19-1209"><a href="#cb19-1209" aria-hidden="true" tabindex="-1"></a><span class="in">      L.mod.sel[rep] = vec.L[which.min(crit)]</span></span>
<span id="cb19-1210"><a href="#cb19-1210" aria-hidden="true" tabindex="-1"></a><span class="in">      CB3 = CB1(data, basis, L = L.mod.sel[rep], alpha = 0.05)</span></span>
<span id="cb19-1211"><a href="#cb19-1211" aria-hidden="true" tabindex="-1"></a><span class="in">      mod.sel[rep,5] = CB3$width</span></span>
<span id="cb19-1212"><a href="#cb19-1212" aria-hidden="true" tabindex="-1"></a><span class="in">      </span></span>
<span id="cb19-1213"><a href="#cb19-1213" aria-hidden="true" tabindex="-1"></a><span class="in">      mod.sel.CV[rep] = vec.L[which.min(err)]</span></span>
<span id="cb19-1214"><a href="#cb19-1214" aria-hidden="true" tabindex="-1"></a><span class="in">      conf.band.CV = CB1(data.test, basis, mod.sel.CV[rep], alpha = (0.05))</span></span>
<span id="cb19-1215"><a href="#cb19-1215" aria-hidden="true" tabindex="-1"></a><span class="in">      length.CBL.CV[rep] = conf.band.CV$width</span></span>
<span id="cb19-1216"><a href="#cb19-1216" aria-hidden="true" tabindex="-1"></a><span class="in">      mod.sel.L0[rep] = max(coeff.L0, na.rm=TRUE)</span></span>
<span id="cb19-1217"><a href="#cb19-1217" aria-hidden="true" tabindex="-1"></a><span class="in">      conf.band.L0 = CB1(data.test, basis, mod.sel.L0[rep], alpha = (0.05))</span></span>
<span id="cb19-1218"><a href="#cb19-1218" aria-hidden="true" tabindex="-1"></a><span class="in">      length.CBL.L0[rep] = conf.band.L0$width</span></span>
<span id="cb19-1219"><a href="#cb19-1219" aria-hidden="true" tabindex="-1"></a><span class="in">      </span></span>
<span id="cb19-1220"><a href="#cb19-1220" aria-hidden="true" tabindex="-1"></a><span class="in">      ## coverage</span></span>
<span id="cb19-1221"><a href="#cb19-1221" aria-hidden="true" tabindex="-1"></a><span class="in">      n.test = 5000</span></span>
<span id="cb19-1222"><a href="#cb19-1222" aria-hidden="true" tabindex="-1"></a><span class="in">      time = seq(min(data$time), max(data$time), length.out = n.test)</span></span>
<span id="cb19-1223"><a href="#cb19-1223" aria-hidden="true" tabindex="-1"></a><span class="in">      f.true = stats::spline(x = data$time, y = data$f.true, xout = time, method = "natural")$y</span></span>
<span id="cb19-1224"><a href="#cb19-1224" aria-hidden="true" tabindex="-1"></a><span class="in">      models = list(CB2.Lhat, conf.band.L.max, conf.band.L.star, CB3, conf.band.CV, conf.band.L0)</span></span>
<span id="cb19-1225"><a href="#cb19-1225" aria-hidden="true" tabindex="-1"></a><span class="in">      for (mod in 1:6){</span></span>
<span id="cb19-1226"><a href="#cb19-1226" aria-hidden="true" tabindex="-1"></a><span class="in">        f.hat.up = stats::spline(x = data$time, y = models[[mod]]$f.hat.up, xout = time, method = "natural")$y</span></span>
<span id="cb19-1227"><a href="#cb19-1227" aria-hidden="true" tabindex="-1"></a><span class="in">        f.hat.low = stats::spline(x = data$time, y = models[[mod]]$f.hat.low, xout = time, method = "natural")$y</span></span>
<span id="cb19-1228"><a href="#cb19-1228" aria-hidden="true" tabindex="-1"></a><span class="in">        if (sum(f.true&lt; f.hat.up)+sum(f.true&gt; f.hat.low) == 2*n.test){cpt[mod,ind.basis] = cpt[mod,ind.basis] +1</span></span>
<span id="cb19-1229"><a href="#cb19-1229" aria-hidden="true" tabindex="-1"></a><span class="in">        } else { if(mod == 4){ind = c(ind, rep)}}</span></span>
<span id="cb19-1230"><a href="#cb19-1230" aria-hidden="true" tabindex="-1"></a><span class="in">      }</span></span>
<span id="cb19-1231"><a href="#cb19-1231" aria-hidden="true" tabindex="-1"></a><span class="in">      </span></span>
<span id="cb19-1232"><a href="#cb19-1232" aria-hidden="true" tabindex="-1"></a><span class="in">      </span></span>
<span id="cb19-1233"><a href="#cb19-1233" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb19-1234"><a href="#cb19-1234" aria-hidden="true" tabindex="-1"></a><span class="in">    dfBandWidth = rbind(dfBandWidth, data.frame(Band.width = c(mod.sel[ ,1], mod.sel[ ,3], mod.sel[ ,4], mod.sel[ ,5], length.CBL.CV, length.CBL.L0),</span></span>
<span id="cb19-1235"><a href="#cb19-1235" aria-hidden="true" tabindex="-1"></a><span class="in">                                                basis = rep(basis, repet*6), dimension = rep(c("Lhat", "Lmax", "Lstar","Ltilde", "L.CV", "L.L0"), </span></span>
<span id="cb19-1236"><a href="#cb19-1236" aria-hidden="true" tabindex="-1"></a><span class="in">                                                                                             each = repet))) </span></span>
<span id="cb19-1237"><a href="#cb19-1237" aria-hidden="true" tabindex="-1"></a><span class="in">    dfLhat = rbind(dfLhat, data.frame(</span></span>
<span id="cb19-1238"><a href="#cb19-1238" aria-hidden="true" tabindex="-1"></a><span class="in">      L = vec.L,</span></span>
<span id="cb19-1239"><a href="#cb19-1239" aria-hidden="true" tabindex="-1"></a><span class="in">      Lhat = matrix(table(factor(mod.sel[,2], levels = vec.L))),</span></span>
<span id="cb19-1240"><a href="#cb19-1240" aria-hidden="true" tabindex="-1"></a><span class="in">      Lhat.CV = matrix(table(factor(mod.sel.CV, levels = vec.L))),      </span></span>
<span id="cb19-1241"><a href="#cb19-1241" aria-hidden="true" tabindex="-1"></a><span class="in">      Lhat.L0 = matrix(table(factor(mod.sel.L0, levels = vec.L))),</span></span>
<span id="cb19-1242"><a href="#cb19-1242" aria-hidden="true" tabindex="-1"></a><span class="in">      L.tilde = matrix(table(factor(L.mod.sel, levels = vec.L))),</span></span>
<span id="cb19-1243"><a href="#cb19-1243" aria-hidden="true" tabindex="-1"></a><span class="in">      basis = rep(basis, length(vec.L))))</span></span>
<span id="cb19-1244"><a href="#cb19-1244" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb19-1245"><a href="#cb19-1245" aria-hidden="true" tabindex="-1"></a><span class="in">    </span></span>
<span id="cb19-1246"><a href="#cb19-1246" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1247"><a href="#cb19-1247" aria-hidden="true" tabindex="-1"></a><span class="in">  cpt = cpt/repet</span></span>
<span id="cb19-1248"><a href="#cb19-1248" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1249"><a href="#cb19-1249" aria-hidden="true" tabindex="-1"></a><span class="in">  save(cpt, file = "Res_Tab4.RData")</span></span>
<span id="cb19-1250"><a href="#cb19-1250" aria-hidden="true" tabindex="-1"></a><span class="in">  save(dfBandWidth, file = "Res_Tab3_BandWidth.RData")</span></span>
<span id="cb19-1251"><a href="#cb19-1251" aria-hidden="true" tabindex="-1"></a><span class="in">  save(dfLhat, file = "Res_Tab3_Lhat.RData")</span></span>
<span id="cb19-1252"><a href="#cb19-1252" aria-hidden="true" tabindex="-1"></a><span class="in">} else {</span></span>
<span id="cb19-1253"><a href="#cb19-1253" aria-hidden="true" tabindex="-1"></a><span class="in">  load('Res_Tab4.RData')}</span></span>
<span id="cb19-1254"><a href="#cb19-1254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1255"><a href="#cb19-1255" aria-hidden="true" tabindex="-1"></a><span class="in">row.names(cpt) = c("L hat", "Lmax", "Lstar", "Ltilde", "L.CV", "L.L0")</span></span>
<span id="cb19-1256"><a href="#cb19-1256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1257"><a href="#cb19-1257" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1258"><a href="#cb19-1258" aria-hidden="true" tabindex="-1"></a><span class="in">cpt %&gt;%</span></span>
<span id="cb19-1259"><a href="#cb19-1259" aria-hidden="true" tabindex="-1"></a><span class="in">  kable("latex", booktabs = TRUE) %&gt;%</span></span>
<span id="cb19-1260"><a href="#cb19-1260" aria-hidden="true" tabindex="-1"></a><span class="in">  add_header_above(c("model" = 1, "Legendre" = 1, "Fourier" = 1, "Splines" = 1))</span></span>
<span id="cb19-1261"><a href="#cb19-1261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1262"><a href="#cb19-1262" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height = 7, fig.width=7}</span></span>
<span id="cb19-1263"><a href="#cb19-1263" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-modelsel</span></span>
<span id="cb19-1264"><a href="#cb19-1264" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example with $N=40$. From 100 datasets, we calculate the distribution of the estimated dimension L, for four model selection criteria: from top to bottom, the debiased band proposed in CB2 with  Lhat, the band CB3 with  Ltilde, the cross validation and hard thresholding methods.  The true dimension is $L^* = 11$. "</span></span>
<span id="cb19-1265"><a href="#cb19-1265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1266"><a href="#cb19-1266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1267"><a href="#cb19-1267" aria-hidden="true" tabindex="-1"></a><span class="in">load('Res_Tab3_Lhat.RData')</span></span>
<span id="cb19-1268"><a href="#cb19-1268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1269"><a href="#cb19-1269" aria-hidden="true" tabindex="-1"></a><span class="in">p1 &lt;- ggplot(data = dfLhat, aes(x = L, y = Lhat)) +</span></span>
<span id="cb19-1270"><a href="#cb19-1270" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(stat ="identity")+</span></span>
<span id="cb19-1271"><a href="#cb19-1271" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-1272"><a href="#cb19-1272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1273"><a href="#cb19-1273" aria-hidden="true" tabindex="-1"></a><span class="in">p2 &lt;- ggplot(data = dfLhat, aes(x = L, y = L.tilde)) +</span></span>
<span id="cb19-1274"><a href="#cb19-1274" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(stat ="identity")+</span></span>
<span id="cb19-1275"><a href="#cb19-1275" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-1276"><a href="#cb19-1276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1277"><a href="#cb19-1277" aria-hidden="true" tabindex="-1"></a><span class="in">p3 &lt;- ggplot(data = dfLhat, aes(x = L, y = Lhat.CV)) +</span></span>
<span id="cb19-1278"><a href="#cb19-1278" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(stat ="identity")+</span></span>
<span id="cb19-1279"><a href="#cb19-1279" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-1280"><a href="#cb19-1280" aria-hidden="true" tabindex="-1"></a><span class="in">p4 &lt;- ggplot(data = dfLhat, aes(x = L, y = Lhat.L0)) +</span></span>
<span id="cb19-1281"><a href="#cb19-1281" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_bar(stat ="identity")+</span></span>
<span id="cb19-1282"><a href="#cb19-1282" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~basis)</span></span>
<span id="cb19-1283"><a href="#cb19-1283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1284"><a href="#cb19-1284" aria-hidden="true" tabindex="-1"></a><span class="in">library(gridExtra)</span></span>
<span id="cb19-1285"><a href="#cb19-1285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1286"><a href="#cb19-1286" aria-hidden="true" tabindex="-1"></a><span class="in">grid.arrange(p1, p2, p3, p4, nrow = 4)</span></span>
<span id="cb19-1287"><a href="#cb19-1287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1288"><a href="#cb19-1288" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1289"><a href="#cb19-1289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1290"><a href="#cb19-1290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1291"><a href="#cb19-1291" aria-hidden="true" tabindex="-1"></a>The reformulation of the band around $\underline{\hat f}_2^{ L_{\max}, L^*}$ is close to the band presented in @sec-bandSun for $L=L_{\max}$, that is a band centered around $\underline{\hat f}^{ L_{\max}, L^*}$. A natural question is to understand what is the gain by doing so instead of using the band from @sec-bandSun with $L=L_{\max}$, namely the band $\left [\underline{\hat f}^{ L_{\max}, L^*}(t)-\hat d^{L_{\max}}(t); \underline{\hat f}^{ L_{\max}, L^*}(t)+\hat d^{L_{\max}}(t)\right]$. To do that, we have to understand the behavior of the different terms. As it is difficult to compare theoretically the width of the two bands, we compare them using simulations. </span>
<span id="cb19-1292"><a href="#cb19-1292" aria-hidden="true" tabindex="-1"></a>For 100 repeated datasets, we compute several  confidence bands:  the  $CB_1$ band constructed in @sec-bandSun with $L_{\max}$, the  $CB_{2}$ band defined in @prp-CBf with $\hat L$,  the  $CB_{3}$ band defined in @sec-modsel with $\tilde L$ and the ideal (and not accessible) band constructed in @sec-bandSun with the true $L^*$. In @fig-width-2, we present  boxplots of the norms of the band width with $\hat L$,  $L_{\max}$, $L^*$  and $\tilde{L}$. </span>
<span id="cb19-1293"><a href="#cb19-1293" aria-hidden="true" tabindex="-1"></a>The width of the confidence band with the true $L^*$ is smaller, which is expected but unfortunately not achievable.  The width of the confidence band $CB_1$  is smaller than that of the band $CB_2$. This can be explained by the fact that we estimate two different quantities, on smaller datasets, for more conservative levels ($1-\alpha$ and $1-\beta$ respectively) in order to finally achieve the confidence level of $1-\alpha\beta$. This also explains why the cross validation and hard-thresholding methods, which also divide the sample into two parts, do not give good results either.  The model given by the heuristic model selection criterion $\tilde crit$ achieves good performance. </span>
<span id="cb19-1294"><a href="#cb19-1294" aria-hidden="true" tabindex="-1"></a>Note that the width of the selected model $\tilde L$ is better than the width of the confidence band with a large level $L_{\max}$, which one should have used to avoid model selection. </span>
<span id="cb19-1295"><a href="#cb19-1295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1296"><a href="#cb19-1296" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb19-1297"><a href="#cb19-1297" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-width-2</span></span>
<span id="cb19-1298"><a href="#cb19-1298" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. We display within boxplots the confidence band's width over 100 repetitions for the dimension selected by the several criterion introduced in this paper, for Fourier (left), Legendre (middle) and Splines (right) basis."</span></span>
<span id="cb19-1299"><a href="#cb19-1299" aria-hidden="true" tabindex="-1"></a><span class="in">#| </span></span>
<span id="cb19-1300"><a href="#cb19-1300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1301"><a href="#cb19-1301" aria-hidden="true" tabindex="-1"></a><span class="in">load('Res_Tab3_BandWidth.RData')</span></span>
<span id="cb19-1302"><a href="#cb19-1302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1303"><a href="#cb19-1303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1304"><a href="#cb19-1304" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(dfBandWidth, aes(x = dimension, y = Band.width)) + </span></span>
<span id="cb19-1305"><a href="#cb19-1305" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_boxplot() + </span></span>
<span id="cb19-1306"><a href="#cb19-1306" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~basis, scales = "free_y")</span></span>
<span id="cb19-1307"><a href="#cb19-1307" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1308"><a href="#cb19-1308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1309"><a href="#cb19-1309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1310"><a href="#cb19-1310" aria-hidden="true" tabindex="-1"></a><span class="fu">## Generalization out of the model {#sec-gen}</span></span>
<span id="cb19-1311"><a href="#cb19-1311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1312"><a href="#cb19-1312" aria-hidden="true" tabindex="-1"></a>We now illustrate the behaviour of the bands when the basis used for estimation is poorly specified. We simulate 1000 data sets with a spline basis and estimate the confidence bands with the Fourier and Legendre basis, for different values of $n$ and $N$. The coverage rates are presented in @tbl-levelL-2. The Fourier basis does not give a correct rate. On the other hand, the Legendre basis gives very satisfactory coverage rates for $L&gt;20$.  </span>
<span id="cb19-1313"><a href="#cb19-1313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1314"><a href="#cb19-1314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1315"><a href="#cb19-1315" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1318"><a href="#cb19-1318" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb19-1319"><a href="#cb19-1319" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-levelL-2</span></span>
<span id="cb19-1320"><a href="#cb19-1320" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Illustrative example. The confidence level of the confidence band is evaluated from 1000 repetitions. Data is generated using a Splines basis, and confidence bands are calculated with the Fourier (a) and Legendre (b) families, for several L in rows and several n and N in columns."</span></span>
<span id="cb19-1321"><a href="#cb19-1321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1322"><a href="#cb19-1322" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb19-1323"><a href="#cb19-1323" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb19-1324"><a href="#cb19-1324" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb19-1325"><a href="#cb19-1325" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>, <span class="dv">31</span>, <span class="dv">35</span>)</span>
<span id="cb19-1326"><a href="#cb19-1326" aria-hidden="true" tabindex="-1"></a>vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb19-1327"><a href="#cb19-1327" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb19-1328"><a href="#cb19-1328" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb19-1329"><a href="#cb19-1329" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb19-1330"><a href="#cb19-1330" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb19-1331"><a href="#cb19-1331" aria-hidden="true" tabindex="-1"></a>  vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">40</span>)</span>
<span id="cb19-1332"><a href="#cb19-1332" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb19-1333"><a href="#cb19-1333" aria-hidden="true" tabindex="-1"></a>  basis<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'Fourier'</span>, <span class="st">'Legendre'</span>)</span>
<span id="cb19-1334"><a href="#cb19-1334" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb19-1335"><a href="#cb19-1335" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="fu">max</span>(vec.L),<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>))</span>
<span id="cb19-1336"><a href="#cb19-1336" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb19-1337"><a href="#cb19-1337" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb19-1338"><a href="#cb19-1338" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (ind.N <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.N)){</span>
<span id="cb19-1339"><a href="#cb19-1339" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (ind.basis <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb19-1340"><a href="#cb19-1340" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb19-1341"><a href="#cb19-1341" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb19-1342"><a href="#cb19-1342" aria-hidden="true" tabindex="-1"></a>            <span class="fu">set.seed</span>(rep)</span>
<span id="cb19-1343"><a href="#cb19-1343" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){</span>
<span id="cb19-1344"><a href="#cb19-1344" aria-hidden="true" tabindex="-1"></a>              data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis, <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb19-1345"><a href="#cb19-1345" aria-hidden="true" tabindex="-1"></a>            } <span class="cf">else</span> {data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis)}</span>
<span id="cb19-1346"><a href="#cb19-1346" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb19-1347"><a href="#cb19-1347" aria-hidden="true" tabindex="-1"></a>            conf.band <span class="ot">=</span> <span class="fu">CB1</span>(data, basis<span class="fl">.2</span>[ind.basis], L)</span>
<span id="cb19-1348"><a href="#cb19-1348" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb19-1349"><a href="#cb19-1349" aria-hidden="true" tabindex="-1"></a>              <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb19-1350"><a href="#cb19-1350" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb19-1351"><a href="#cb19-1351" aria-hidden="true" tabindex="-1"></a>            B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb19-1352"><a href="#cb19-1352" aria-hidden="true" tabindex="-1"></a>            B <span class="ot">=</span> <span class="fu">func.basis</span>(time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb19-1353"><a href="#cb19-1353" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb19-1354"><a href="#cb19-1354" aria-hidden="true" tabindex="-1"></a>            f.true <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb19-1355"><a href="#cb19-1355" aria-hidden="true" tabindex="-1"></a>            f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1356"><a href="#cb19-1356" aria-hidden="true" tabindex="-1"></a>            f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1357"><a href="#cb19-1357" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb19-1358"><a href="#cb19-1358" aria-hidden="true" tabindex="-1"></a>              cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span></span>
<span id="cb19-1359"><a href="#cb19-1359" aria-hidden="true" tabindex="-1"></a>            } </span>
<span id="cb19-1360"><a href="#cb19-1360" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb19-1361"><a href="#cb19-1361" aria-hidden="true" tabindex="-1"></a>          perf[L,ind.n, ind.N, ind.basis] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb19-1362"><a href="#cb19-1362" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb19-1363"><a href="#cb19-1363" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb19-1364"><a href="#cb19-1364" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb19-1365"><a href="#cb19-1365" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-1366"><a href="#cb19-1366" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-1367"><a href="#cb19-1367" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab_other.RData"</span>)</span>
<span id="cb19-1368"><a href="#cb19-1368" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"Res_Tab_other.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb19-1369"><a href="#cb19-1369" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">1</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">1</span>])</span>
<span id="cb19-1370"><a href="#cb19-1370" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.Fourier) <span class="ot">=</span> vec.L</span>
<span id="cb19-1371"><a href="#cb19-1371" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(perf.Fourier) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">" 50/10"</span>, <span class="st">"150/10"</span>, <span class="st">"50/40"</span>, <span class="st">"150/40"</span>)</span>
<span id="cb19-1372"><a href="#cb19-1372" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1373"><a href="#cb19-1373" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="sc">%&gt;%</span></span>
<span id="cb19-1374"><a href="#cb19-1374" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-1375"><a href="#cb19-1375" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">4</span>))</span>
<span id="cb19-1376"><a href="#cb19-1376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1377"><a href="#cb19-1377" aria-hidden="true" tabindex="-1"></a>pref.Legendre <span class="ot">=</span> <span class="fu">cbind</span>(perf[vec.L,,<span class="dv">1</span>,<span class="dv">2</span>],perf[vec.L,,<span class="dv">2</span>,<span class="dv">2</span>])</span>
<span id="cb19-1378"><a href="#cb19-1378" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(pref.Legendre) <span class="ot">=</span> vec.L</span>
<span id="cb19-1379"><a href="#cb19-1379" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(pref.Legendre) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">" 50/10"</span>, <span class="st">"150/10"</span>, <span class="st">"50/40"</span>, <span class="st">"150/40"</span>)</span>
<span id="cb19-1380"><a href="#cb19-1380" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1381"><a href="#cb19-1381" aria-hidden="true" tabindex="-1"></a>pref.Legendre <span class="sc">%&gt;%</span></span>
<span id="cb19-1382"><a href="#cb19-1382" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-1383"><a href="#cb19-1383" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n/N"</span> <span class="ot">=</span> <span class="dv">4</span>))</span>
<span id="cb19-1384"><a href="#cb19-1384" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1385"><a href="#cb19-1385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1386"><a href="#cb19-1386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1387"><a href="#cb19-1387" aria-hidden="true" tabindex="-1"></a>Next, we illustrate the $\tilde L$ dimension selection method and compare it to the cross-validation method.  @tbl-levelL-3 presents the coverage rates of the corresponding confidence bands estimated with the Fourier and Legendre basis, in the case $N=40$ and $n=150$. Once again, we see that the Fourier basis does not give good results, either by cross-validation or by $\tilde L$. On the other hand, with the Legendre basis, the $\tilde L$ method gives a satisfactory coverage rate, even if it is underestimated, whereas the cross-validation method is very poor. </span>
<span id="cb19-1388"><a href="#cb19-1388" aria-hidden="true" tabindex="-1"></a>Moreover, the widths of the confidence bands selected with $\tilde L$ and by cross validation are represented by boxplot in @fig-width-3. It can be seen that the cross-validation approach provides wider bands, even though their confidence level is not guaranteed. The method proposed in this paper provides a narrower band with a correct level of confidence. We thus recommend to use the Legendre family with the criteria $\tilde L$. </span>
<span id="cb19-1389"><a href="#cb19-1389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1390"><a href="#cb19-1390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1393"><a href="#cb19-1393" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb19-1394"><a href="#cb19-1394" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-levelL-3</span></span>
<span id="cb19-1395"><a href="#cb19-1395" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Illustrative example. The confidence level of the confidence band is evaluated from 100 repetitions. Data is generated using a Splines basis, and confidence bands are calculated with the Fourier (a) and Legendre (b) families, for several model selection criterion in rows, L in rows and several n and N in columns."</span></span>
<span id="cb19-1396"><a href="#cb19-1396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1397"><a href="#cb19-1397" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb19-1398"><a href="#cb19-1398" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(kableExtra)</span>
<span id="cb19-1399"><a href="#cb19-1399" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb19-1400"><a href="#cb19-1400" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>, <span class="dv">31</span>, <span class="dv">35</span>)</span>
<span id="cb19-1401"><a href="#cb19-1401" aria-hidden="true" tabindex="-1"></a>vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb19-1402"><a href="#cb19-1402" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb19-1403"><a href="#cb19-1403" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb19-1404"><a href="#cb19-1404" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb19-1405"><a href="#cb19-1405" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">150</span>) </span>
<span id="cb19-1406"><a href="#cb19-1406" aria-hidden="true" tabindex="-1"></a>  vec.N <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">40</span>)</span>
<span id="cb19-1407"><a href="#cb19-1407" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb19-1408"><a href="#cb19-1408" aria-hidden="true" tabindex="-1"></a>  basis<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'Fourier'</span>, <span class="st">'Legendre'</span>)</span>
<span id="cb19-1409"><a href="#cb19-1409" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb19-1410"><a href="#cb19-1410" aria-hidden="true" tabindex="-1"></a>  perf.sel <span class="ot">=</span> <span class="fu">array</span>(<span class="dv">0</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb19-1411"><a href="#cb19-1411" aria-hidden="true" tabindex="-1"></a>  err <span class="ot">=</span> coeff.L0 <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb19-1412"><a href="#cb19-1412" aria-hidden="true" tabindex="-1"></a>  L.mod.sel <span class="ot">=</span> mod.sel.CV <span class="ot">=</span> length.CBL.CV <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb19-1413"><a href="#cb19-1413" aria-hidden="true" tabindex="-1"></a>  mod.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> nb.repeat, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb19-1414"><a href="#cb19-1414" aria-hidden="true" tabindex="-1"></a>  width <span class="ot">=</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim=</span><span class="fu">c</span>(<span class="dv">2</span>, nb.repeat))</span>
<span id="cb19-1415"><a href="#cb19-1415" aria-hidden="true" tabindex="-1"></a>  dfBandWidth <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">double</span>(),</span>
<span id="cb19-1416"><a href="#cb19-1416" aria-hidden="true" tabindex="-1"></a>                           <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb19-1417"><a href="#cb19-1417" aria-hidden="true" tabindex="-1"></a>                           <span class="at">dimension =</span> <span class="fu">integer</span>())</span>
<span id="cb19-1418"><a href="#cb19-1418" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb19-1419"><a href="#cb19-1419" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (ind.N <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.N)){</span>
<span id="cb19-1420"><a href="#cb19-1420" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (ind.basis <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb19-1421"><a href="#cb19-1421" aria-hidden="true" tabindex="-1"></a>        cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb19-1422"><a href="#cb19-1422" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb19-1423"><a href="#cb19-1423" aria-hidden="true" tabindex="-1"></a>          <span class="fu">set.seed</span>(rep)</span>
<span id="cb19-1424"><a href="#cb19-1424" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">"Splines"</span>){</span>
<span id="cb19-1425"><a href="#cb19-1425" aria-hidden="true" tabindex="-1"></a>            data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis, <span class="at">sd =</span> <span class="dv">2</span>)</span>
<span id="cb19-1426"><a href="#cb19-1426" aria-hidden="true" tabindex="-1"></a>          } <span class="cf">else</span> {data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">N =</span> vec.N[ind.N], <span class="at">basis =</span> basis)}</span>
<span id="cb19-1427"><a href="#cb19-1427" aria-hidden="true" tabindex="-1"></a>          data.train <span class="ot">=</span> data</span>
<span id="cb19-1428"><a href="#cb19-1428" aria-hidden="true" tabindex="-1"></a>          data.train<span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[, <span class="dv">1</span><span class="sc">:</span>(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>)]</span>
<span id="cb19-1429"><a href="#cb19-1429" aria-hidden="true" tabindex="-1"></a>          data.test <span class="ot">=</span> data</span>
<span id="cb19-1430"><a href="#cb19-1430" aria-hidden="true" tabindex="-1"></a>          data.test<span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>) <span class="sc">:</span> (<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>])]</span>
<span id="cb19-1431"><a href="#cb19-1431" aria-hidden="true" tabindex="-1"></a>          tot.VC <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">each =</span> <span class="fu">dim</span>(data.train<span class="sc">$</span>y)[<span class="dv">2</span>] <span class="sc">/</span> <span class="dv">10</span>)</span>
<span id="cb19-1432"><a href="#cb19-1432" aria-hidden="true" tabindex="-1"></a>          err <span class="ot">&lt;-</span> <span class="fu">sapply</span>(vec.L, <span class="cf">function</span>(L) {</span>
<span id="cb19-1433"><a href="#cb19-1433" aria-hidden="true" tabindex="-1"></a>            <span class="fu">mean</span>(<span class="fu">sapply</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="cf">function</span>(VC) {</span>
<span id="cb19-1434"><a href="#cb19-1434" aria-hidden="true" tabindex="-1"></a>              train <span class="ot">&lt;-</span> data.train</span>
<span id="cb19-1435"><a href="#cb19-1435" aria-hidden="true" tabindex="-1"></a>              train<span class="sc">$</span>y <span class="ot">&lt;-</span> train<span class="sc">$</span>y[,<span class="sc">-</span><span class="fu">which</span>(tot.VC <span class="sc">==</span> VC)]</span>
<span id="cb19-1436"><a href="#cb19-1436" aria-hidden="true" tabindex="-1"></a>              test <span class="ot">&lt;-</span> data.train</span>
<span id="cb19-1437"><a href="#cb19-1437" aria-hidden="true" tabindex="-1"></a>              test<span class="sc">$</span>y <span class="ot">&lt;-</span> test<span class="sc">$</span>y[, <span class="fu">which</span>(tot.VC <span class="sc">==</span> VC)]</span>
<span id="cb19-1438"><a href="#cb19-1438" aria-hidden="true" tabindex="-1"></a>              est.L <span class="ot">&lt;-</span> <span class="fu">estimator</span>(train, basis, L)</span>
<span id="cb19-1439"><a href="#cb19-1439" aria-hidden="true" tabindex="-1"></a>              <span class="fu">sqrt</span>(<span class="fu">mean</span>((test<span class="sc">$</span>y <span class="sc">-</span> est.L<span class="sc">$</span>f.hat)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb19-1440"><a href="#cb19-1440" aria-hidden="true" tabindex="-1"></a>            }))</span>
<span id="cb19-1441"><a href="#cb19-1441" aria-hidden="true" tabindex="-1"></a>          })</span>
<span id="cb19-1442"><a href="#cb19-1442" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb19-1443"><a href="#cb19-1443" aria-hidden="true" tabindex="-1"></a>            CB2.L <span class="ot">=</span> <span class="fu">CB2</span>(data, <span class="at">basis =</span> basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb19-1444"><a href="#cb19-1444" aria-hidden="true" tabindex="-1"></a>            length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, CB2.L<span class="sc">$</span>width)</span>
<span id="cb19-1445"><a href="#cb19-1445" aria-hidden="true" tabindex="-1"></a>            conf.band.L <span class="ot">=</span> <span class="fu">CB1</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb19-1446"><a href="#cb19-1446" aria-hidden="true" tabindex="-1"></a>            c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb19-1447"><a href="#cb19-1447" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb19-1448"><a href="#cb19-1448" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1449"><a href="#cb19-1449" aria-hidden="true" tabindex="-1"></a>          mod.sel[rep,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">min</span>(length.band), vec.L[<span class="fu">which.min</span>(length.band)])</span>
<span id="cb19-1450"><a href="#cb19-1450" aria-hidden="true" tabindex="-1"></a>          lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb19-1451"><a href="#cb19-1451" aria-hidden="true" tabindex="-1"></a>          crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb19-1452"><a href="#cb19-1452" aria-hidden="true" tabindex="-1"></a>          L.mod.sel[rep] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb19-1453"><a href="#cb19-1453" aria-hidden="true" tabindex="-1"></a>          CB3 <span class="ot">=</span> <span class="fu">CB1</span>(data, <span class="at">basis =</span> basis<span class="fl">.2</span>[ind.basis], <span class="at">L =</span> L.mod.sel[rep], <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb19-1454"><a href="#cb19-1454" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1455"><a href="#cb19-1455" aria-hidden="true" tabindex="-1"></a>          mod.sel.CV[rep] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(err)]</span>
<span id="cb19-1456"><a href="#cb19-1456" aria-hidden="true" tabindex="-1"></a>          conf.band.CV <span class="ot">=</span> <span class="fu">CB1</span>(data.test, <span class="at">basis =</span> basis<span class="fl">.2</span>[ind.basis], mod.sel.CV[rep], <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb19-1457"><a href="#cb19-1457" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1458"><a href="#cb19-1458" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1459"><a href="#cb19-1459" aria-hidden="true" tabindex="-1"></a>          <span class="do">## coverage</span></span>
<span id="cb19-1460"><a href="#cb19-1460" aria-hidden="true" tabindex="-1"></a>          n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb19-1461"><a href="#cb19-1461" aria-hidden="true" tabindex="-1"></a>          time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb19-1462"><a href="#cb19-1462" aria-hidden="true" tabindex="-1"></a>          B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb19-1463"><a href="#cb19-1463" aria-hidden="true" tabindex="-1"></a>          B <span class="ot">=</span> <span class="fu">func.basis</span>(time, <span class="at">L =</span> <span class="dv">11</span>, basis)</span>
<span id="cb19-1464"><a href="#cb19-1464" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1465"><a href="#cb19-1465" aria-hidden="true" tabindex="-1"></a>          f.true <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb19-1466"><a href="#cb19-1466" aria-hidden="true" tabindex="-1"></a>          models <span class="ot">=</span> <span class="fu">list</span>(CB3, conf.band.CV)</span>
<span id="cb19-1467"><a href="#cb19-1467" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1468"><a href="#cb19-1468" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1469"><a href="#cb19-1469" aria-hidden="true" tabindex="-1"></a>          width[<span class="dv">1</span>,rep] <span class="ot">=</span> CB3<span class="sc">$</span>width</span>
<span id="cb19-1470"><a href="#cb19-1470" aria-hidden="true" tabindex="-1"></a>          width[<span class="dv">2</span>,rep] <span class="ot">=</span> conf.band.CV<span class="sc">$</span>width</span>
<span id="cb19-1471"><a href="#cb19-1471" aria-hidden="true" tabindex="-1"></a>          </span>
<span id="cb19-1472"><a href="#cb19-1472" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (mod <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>){</span>
<span id="cb19-1473"><a href="#cb19-1473" aria-hidden="true" tabindex="-1"></a>            f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> models[[mod]]<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1474"><a href="#cb19-1474" aria-hidden="true" tabindex="-1"></a>            f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> models[[mod]]<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb19-1475"><a href="#cb19-1475" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){perf.sel[mod,ind.n, ind.N, ind.basis] <span class="ot">=</span> perf.sel[mod,ind.n, ind.N, ind.basis] <span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb19-1476"><a href="#cb19-1476" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb19-1477"><a href="#cb19-1477" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb19-1478"><a href="#cb19-1478" aria-hidden="true" tabindex="-1"></a>        dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">c</span>(width[<span class="dv">1</span>,], width[<span class="dv">2</span>,]),</span>
<span id="cb19-1479"><a href="#cb19-1479" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis<span class="fl">.2</span>[ind.basis], nb.repeat<span class="sc">*</span><span class="dv">2</span>), <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L tilde"</span>, <span class="st">"L.CV"</span>), </span>
<span id="cb19-1480"><a href="#cb19-1480" aria-hidden="true" tabindex="-1"></a>                                                                                             <span class="at">each =</span> nb.repeat))) </span>
<span id="cb19-1481"><a href="#cb19-1481" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb19-1482"><a href="#cb19-1482" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb19-1483"><a href="#cb19-1483" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-1484"><a href="#cb19-1484" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb19-1485"><a href="#cb19-1485" aria-hidden="true" tabindex="-1"></a>  perf.sel <span class="ot">=</span> perf.sel <span class="sc">/</span> nb.repeat  </span>
<span id="cb19-1486"><a href="#cb19-1486" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb19-1487"><a href="#cb19-1487" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf.sel, <span class="at">file =</span> <span class="st">"Res_Tab_other_2.RData"</span>)</span>
<span id="cb19-1488"><a href="#cb19-1488" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab_other_2_width.RData"</span>)</span>
<span id="cb19-1489"><a href="#cb19-1489" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"Res_Tab_other_2.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb19-1490"><a href="#cb19-1490" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="ot">=</span> <span class="fu">matrix</span>(perf.sel[,,,<span class="dv">1</span>], <span class="at">nrow=</span><span class="dv">2</span>, <span class="at">ncol=</span><span class="dv">1</span>)</span>
<span id="cb19-1491"><a href="#cb19-1491" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(perf.Fourier) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'L tilde'</span>, <span class="st">'L.CV'</span>)</span>
<span id="cb19-1492"><a href="#cb19-1492" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1493"><a href="#cb19-1493" aria-hidden="true" tabindex="-1"></a>perf.Fourier <span class="sc">%&gt;%</span></span>
<span id="cb19-1494"><a href="#cb19-1494" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-1495"><a href="#cb19-1495" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n=150, N=40"</span> <span class="ot">=</span> <span class="dv">1</span>))</span>
<span id="cb19-1496"><a href="#cb19-1496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1497"><a href="#cb19-1497" aria-hidden="true" tabindex="-1"></a>pref.Splines <span class="ot">=</span> <span class="fu">matrix</span>(perf.sel[,,<span class="dv">1</span>,<span class="dv">2</span>], <span class="at">nrow=</span><span class="dv">2</span>, <span class="at">ncol=</span><span class="dv">1</span>)</span>
<span id="cb19-1498"><a href="#cb19-1498" aria-hidden="true" tabindex="-1"></a><span class="fu">rownames</span>(pref.Splines) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">'L tilde'</span>, <span class="st">'L.CV'</span>)</span>
<span id="cb19-1499"><a href="#cb19-1499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1500"><a href="#cb19-1500" aria-hidden="true" tabindex="-1"></a>pref.Splines <span class="sc">%&gt;%</span></span>
<span id="cb19-1501"><a href="#cb19-1501" aria-hidden="true" tabindex="-1"></a>  <span class="fu">kable</span>(<span class="st">"latex"</span>, <span class="at">booktabs =</span> <span class="cn">TRUE</span>) <span class="sc">%&gt;%</span></span>
<span id="cb19-1502"><a href="#cb19-1502" aria-hidden="true" tabindex="-1"></a>  <span class="fu">add_header_above</span>(<span class="fu">c</span>(<span class="st">"L"</span> <span class="ot">=</span> <span class="dv">1</span>, <span class="st">"n=150, N=40"</span> <span class="ot">=</span> <span class="dv">1</span>))</span>
<span id="cb19-1503"><a href="#cb19-1503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1504"><a href="#cb19-1504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1505"><a href="#cb19-1505" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1506"><a href="#cb19-1506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1507"><a href="#cb19-1507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1508"><a href="#cb19-1508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1509"><a href="#cb19-1509" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb19-1510"><a href="#cb19-1510" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-width-3</span></span>
<span id="cb19-1511"><a href="#cb19-1511" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. The confidence level of the confidence band is evaluated from 100 repetitions. Data is generated using a Splines basis, and confidence bands are calculated with the Fourier (a) and Legendre (b) families, for several model selection criterion in rows, L in rows and several n and N in columns."</span></span>
<span id="cb19-1512"><a href="#cb19-1512" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1513"><a href="#cb19-1513" aria-hidden="true" tabindex="-1"></a><span class="in">load("Res_Tab_other_2_width.RData")</span></span>
<span id="cb19-1514"><a href="#cb19-1514" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(dfBandWidth, aes(x = dimension, y = Band.width)) + </span></span>
<span id="cb19-1515"><a href="#cb19-1515" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_boxplot() + </span></span>
<span id="cb19-1516"><a href="#cb19-1516" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap(~basis, scales = "free_y")</span></span>
<span id="cb19-1517"><a href="#cb19-1517" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1518"><a href="#cb19-1518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1519"><a href="#cb19-1519" aria-hidden="true" tabindex="-1"></a><span class="fu"># Real data analysis {#sec-realdata}</span></span>
<span id="cb19-1520"><a href="#cb19-1520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1521"><a href="#cb19-1521" aria-hidden="true" tabindex="-1"></a>In this section, we illustrate the proposed method on the Berkeley Growth Study data. </span>
<span id="cb19-1522"><a href="#cb19-1522" aria-hidden="true" tabindex="-1"></a>It consists of the heights in centimeters of 39 boys at 31 ages from 1 to 18. </span>
<span id="cb19-1523"><a href="#cb19-1523" aria-hidden="true" tabindex="-1"></a>We approximate these curves by the 3 basis Legendre, Splines and Fourier.</span>
<span id="cb19-1524"><a href="#cb19-1524" aria-hidden="true" tabindex="-1"></a>We select the level of each basis using the method introduced in @sec-modsel. </span>
<span id="cb19-1525"><a href="#cb19-1525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1526"><a href="#cb19-1526" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb19-1527"><a href="#cb19-1527" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-realdata</span></span>
<span id="cb19-1528"><a href="#cb19-1528" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Real data analysis example. We display the confidence bands for Fourier (left), Legendre (middle) and Splines (right) basis on the Berkeley Growth Study data. Black curves correspond to the confidence bands with $L_{max}$, while colored one are the confidence bands CBE. "</span></span>
<span id="cb19-1529"><a href="#cb19-1529" aria-hidden="true" tabindex="-1"></a><span class="in">#| </span></span>
<span id="cb19-1530"><a href="#cb19-1530" aria-hidden="true" tabindex="-1"></a><span class="in">data(growth)</span></span>
<span id="cb19-1531"><a href="#cb19-1531" aria-hidden="true" tabindex="-1"></a><span class="in">data = list()</span></span>
<span id="cb19-1532"><a href="#cb19-1532" aria-hidden="true" tabindex="-1"></a><span class="in">data$time = (growth$age - min(growth$age))/(max(growth$age) - min(growth$age))</span></span>
<span id="cb19-1533"><a href="#cb19-1533" aria-hidden="true" tabindex="-1"></a><span class="in">data$y = growth$hgtm</span></span>
<span id="cb19-1534"><a href="#cb19-1534" aria-hidden="true" tabindex="-1"></a><span class="in">L.max = 25</span></span>
<span id="cb19-1535"><a href="#cb19-1535" aria-hidden="true" tabindex="-1"></a><span class="in">vec.L = 3:24</span></span>
<span id="cb19-1536"><a href="#cb19-1536" aria-hidden="true" tabindex="-1"></a><span class="in">alpha = 0.2</span></span>
<span id="cb19-1537"><a href="#cb19-1537" aria-hidden="true" tabindex="-1"></a><span class="in">dfBandlow = dfBandup = df.max = res_growth = c()</span></span>
<span id="cb19-1538"><a href="#cb19-1538" aria-hidden="true" tabindex="-1"></a><span class="in">for (basis in c("Legendre", "Splines", "Fourier")){</span></span>
<span id="cb19-1539"><a href="#cb19-1539" aria-hidden="true" tabindex="-1"></a><span class="in">  mod.sel= c()</span></span>
<span id="cb19-1540"><a href="#cb19-1540" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == 'Fourier'){vec.L = seq(3,24, by=2)}</span></span>
<span id="cb19-1541"><a href="#cb19-1541" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L = c.L.Lmax = c()</span></span>
<span id="cb19-1542"><a href="#cb19-1542" aria-hidden="true" tabindex="-1"></a><span class="in">  conf.band.L.max = CB1(data, basis, L = L.max, alpha = alpha)</span></span>
<span id="cb19-1543"><a href="#cb19-1543" aria-hidden="true" tabindex="-1"></a><span class="in">  c.L.Lmax = max(conf.band.L.max$c.L)</span></span>
<span id="cb19-1544"><a href="#cb19-1544" aria-hidden="true" tabindex="-1"></a><span class="in">  df.max = rbind(df.max, data.frame(Time = growth$age, </span></span>
<span id="cb19-1545"><a href="#cb19-1545" aria-hidden="true" tabindex="-1"></a><span class="in">                                    band.up = t(conf.band.L.max$f.hat.up),</span></span>
<span id="cb19-1546"><a href="#cb19-1546" aria-hidden="true" tabindex="-1"></a><span class="in">                                    band.low = t(conf.band.L.max$f.hat.low),</span></span>
<span id="cb19-1547"><a href="#cb19-1547" aria-hidden="true" tabindex="-1"></a><span class="in">                                    basis = rep(basis, length(data$time))))</span></span>
<span id="cb19-1548"><a href="#cb19-1548" aria-hidden="true" tabindex="-1"></a><span class="in">  for (L in vec.L){</span></span>
<span id="cb19-1549"><a href="#cb19-1549" aria-hidden="true" tabindex="-1"></a><span class="in">    conf.band.L = CB1(data, basis, L, alpha = (alpha))</span></span>
<span id="cb19-1550"><a href="#cb19-1550" aria-hidden="true" tabindex="-1"></a><span class="in">    c.L[L] = max(conf.band.L$c.L)</span></span>
<span id="cb19-1551"><a href="#cb19-1551" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1552"><a href="#cb19-1552" aria-hidden="true" tabindex="-1"></a><span class="in">  lambda = 1</span></span>
<span id="cb19-1553"><a href="#cb19-1553" aria-hidden="true" tabindex="-1"></a><span class="in">  crit = abs(rep(c.Lmax, length(vec.L)) - c.L[vec.L]) + lambda * vec.L/((dim(data$y)[1]))</span></span>
<span id="cb19-1554"><a href="#cb19-1554" aria-hidden="true" tabindex="-1"></a><span class="in">  mod.sel = vec.L[which.min(crit)]</span></span>
<span id="cb19-1555"><a href="#cb19-1555" aria-hidden="true" tabindex="-1"></a><span class="in">  #print(paste0('model selected:', mod.sel))</span></span>
<span id="cb19-1556"><a href="#cb19-1556" aria-hidden="true" tabindex="-1"></a><span class="in">  conf.band.L.star.2 = CB1(data, basis, mod.sel, alpha = alpha)</span></span>
<span id="cb19-1557"><a href="#cb19-1557" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1558"><a href="#cb19-1558" aria-hidden="true" tabindex="-1"></a><span class="in">  dfBandup = rbind(dfBandup, data.frame(Time = growth$age,</span></span>
<span id="cb19-1559"><a href="#cb19-1559" aria-hidden="true" tabindex="-1"></a><span class="in">                                        bandup = t(conf.band.L.star.2$f.hat.up),</span></span>
<span id="cb19-1560"><a href="#cb19-1560" aria-hidden="true" tabindex="-1"></a><span class="in">                                        basis = rep(basis, length(data$time))))</span></span>
<span id="cb19-1561"><a href="#cb19-1561" aria-hidden="true" tabindex="-1"></a><span class="in">  dfBandlow = rbind(dfBandlow, data.frame(Time = growth$age,</span></span>
<span id="cb19-1562"><a href="#cb19-1562" aria-hidden="true" tabindex="-1"></a><span class="in">                                          bandlow = t(conf.band.L.star.2$f.hat.low),</span></span>
<span id="cb19-1563"><a href="#cb19-1563" aria-hidden="true" tabindex="-1"></a><span class="in">                                          basis = rep(basis, length(data$time))))</span></span>
<span id="cb19-1564"><a href="#cb19-1564" aria-hidden="true" tabindex="-1"></a><span class="in">  #print(paste0('length L sel:', conf.band.L.star.2$c.L))</span></span>
<span id="cb19-1565"><a href="#cb19-1565" aria-hidden="true" tabindex="-1"></a><span class="in">  </span></span>
<span id="cb19-1566"><a href="#cb19-1566" aria-hidden="true" tabindex="-1"></a><span class="in">  res_growth = round(cbind(res_growth, c(conf.band.L.max$c.L, conf.band.L.star.2$c.L, mod.sel)),2)</span></span>
<span id="cb19-1567"><a href="#cb19-1567" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-1568"><a href="#cb19-1568" aria-hidden="true" tabindex="-1"></a><span class="in">colnames(res_growth) = c("Legendre", "Splines", "Fourier")</span></span>
<span id="cb19-1569"><a href="#cb19-1569" aria-hidden="true" tabindex="-1"></a><span class="in">row.names(res_growth) = c("Width Lmax", "Width selected", "Model selected")</span></span>
<span id="cb19-1570"><a href="#cb19-1570" aria-hidden="true" tabindex="-1"></a><span class="in">df.data = data.frame(Time = rep(growth$age,dim(data$y)[2]), f = c(data$y), ind = rep(1:(dim(data$y)[2]), each = dim(data$y)[1]))</span></span>
<span id="cb19-1571"><a href="#cb19-1571" aria-hidden="true" tabindex="-1"></a><span class="in">p1 &lt;- ggplot()+ geom_line(data=df.data, aes(x=Time, y =f, group=ind), color = "lightgrey",linewidth= 0.5)+</span></span>
<span id="cb19-1572"><a href="#cb19-1572" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfBandup, aes(x = Time, y = bandup,col = basis, group = basis), linewidth = 0.4) +</span></span>
<span id="cb19-1573"><a href="#cb19-1573" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = dfBandlow, aes(x = Time, y = bandlow,col = basis, group = basis), linewidth = 0.4) + </span></span>
<span id="cb19-1574"><a href="#cb19-1574" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = df.max, aes(x=Time, y = band.up, group=basis), linewidth = 0.4) + </span></span>
<span id="cb19-1575"><a href="#cb19-1575" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_line(data = df.max, aes(x=Time, y = band.low, group=basis), linewidth = 0.4) +</span></span>
<span id="cb19-1576"><a href="#cb19-1576" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(~ basis)</span></span>
<span id="cb19-1577"><a href="#cb19-1577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1578"><a href="#cb19-1578" aria-hidden="true" tabindex="-1"></a><span class="in">p1</span></span>
<span id="cb19-1579"><a href="#cb19-1579" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1580"><a href="#cb19-1580" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1581"><a href="#cb19-1581" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb19-1582"><a href="#cb19-1582" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: tbl-realdata</span></span>
<span id="cb19-1583"><a href="#cb19-1583" aria-hidden="true" tabindex="-1"></a><span class="in">#| tbl-cap: "Real data analysis example, Berkeley Growth Study data. We display the width of the confidence bands for Fourier, Legendre and Splines basis for the confidence band of @sec-bandSun with Lmax and the confidence band of @sec-modsel. We also precise the dimension of the selected model."</span></span>
<span id="cb19-1584"><a href="#cb19-1584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1585"><a href="#cb19-1585" aria-hidden="true" tabindex="-1"></a><span class="in">res_growth %&gt;% </span></span>
<span id="cb19-1586"><a href="#cb19-1586" aria-hidden="true" tabindex="-1"></a><span class="in">  kable("latex", booktabs = TRUE) %&gt;%</span></span>
<span id="cb19-1587"><a href="#cb19-1587" aria-hidden="true" tabindex="-1"></a><span class="in">  add_header_above(c(" " = 1, "Basis" = 3))</span></span>
<span id="cb19-1588"><a href="#cb19-1588" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1589"><a href="#cb19-1589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1590"><a href="#cb19-1590" aria-hidden="true" tabindex="-1"></a>In @fig-realdata, we display the confidence bands associated <span class="in">`r colorize("with", "red")`</span> <span class="co">&lt;!--to!--&gt;</span> @sec-bandSun in black and <span class="in">`r colorize("those", "red")`</span> <span class="co">&lt;!--the one!--&gt;</span> associated <span class="in">`r colorize("with", "red")`</span> <span class="co">&lt;!--to!--&gt;</span> @sec-modsel, for the three basis. As the data is not periodic, the Fourier basis is meaningless, <span class="in">`r colorize("as is", "red")`</span> <span class="co">&lt;!--and so is!--&gt;</span> the associated confidence band, whatever the dimension considered. Splines and Legendre basis give similar confidence bands. </span>
<span id="cb19-1591"><a href="#cb19-1591" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("By", "red")`</span> <span class="co">&lt;!--When!--&gt;</span> analyzing the width of the bands in @tbl-realdata, compared <span class="in">`r colorize("to that", "red")`</span> <span class="co">&lt;!--with the one!--&gt;</span> obtained with $L_{\max}$, we <span class="in">`r colorize("find", "red")`</span> <span class="co">&lt;!--see!--&gt;</span> that they are less smooth but also smaller, and from our empirical study we guess that it makes a trade-off between bias and variance. </span>
<span id="cb19-1592"><a href="#cb19-1592" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1593"><a href="#cb19-1593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1594"><a href="#cb19-1594" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusion {#sec-conc}</span></span>
<span id="cb19-1595"><a href="#cb19-1595" aria-hidden="true" tabindex="-1"></a>This paper <span class="in">`r colorize("deals with", "red")`</span>  <span class="co">&lt;!--discusses!--&gt;</span> the construction of confidence bands when considering a <span class="in">`r colorize("functional model.", "red")`</span> <span class="co">&lt;!--linear model over a functional family.!--&gt;</span> Depending on the nature of the family (an orthogonal or orthonormal basis, or simply a vector space), <span class="in">`r colorize("the", "red")`</span> theoretical guarantees of the linear estimator are <span class="in">`r colorize("recalled", "red")`</span> <span class="co">&lt;!--reminded!--&gt;</span> and illustrated. </span>
<span id="cb19-1596"><a href="#cb19-1596" aria-hidden="true" tabindex="-1"></a>Several confidence bands are then proposed. <span class="co">&lt;!--Throughout the paper,!--&gt;</span> <span class="in">`r colorize("An", "red")`</span> extensive experimental study on Fourier, Legendre and Spline basis <span class="co">&lt;!--have!--&gt;</span> illustrate<span class="in">`r colorize("s", "red")`</span> the theoretical and methodological propositions, and a real data study is proposed to conclude the paper. </span>
<span id="cb19-1597"><a href="#cb19-1597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1598"><a href="#cb19-1598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1599"><a href="#cb19-1599" aria-hidden="true" tabindex="-1"></a>First, when considering a functional family with fixed dimension, we discuss the confidence band derived from @sun1994. It is biased if the dimension is not high enough to approximate well the true function.</span>
<span id="cb19-1600"><a href="#cb19-1600" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("We then propose a", "red")`</span> new confidence band <span class="co">&lt;!--is proposed!--&gt;</span> that corrects this bias. To do this, the bias is estimated and the additional randomness is controlled. A selection criterion is proposed to select the best dimension. </span>
<span id="cb19-1601"><a href="#cb19-1601" aria-hidden="true" tabindex="-1"></a>Unfortunately, the two <span class="in">`r colorize("types", "red")`</span> <span class="co">&lt;!--kinds!--&gt;</span> of randomness <span class="in">`r colorize("lead", "red")`</span>  <span class="co">&lt;!--are leading!--&gt;</span> to a wider confidence band, and this result is <span class="in">`r colorize("therefore no", "red")`</span>  <span class="co">&lt;!--then not!--&gt;</span> more interesting than the naive one, which consists of taking the largest possible dimension $L_{\max}$. </span>
<span id="cb19-1602"><a href="#cb19-1602" aria-hidden="true" tabindex="-1"></a>Finally, a heuristic selection criterion is proposed to select the dimension on the first confidence band, <span class="in">`r colorize("which has not corrected", "red")`</span>  <span class="co">&lt;!--that did not correct!--&gt;</span> the bias. It takes into account the bias as well as the variance, to select a moderate dimension. <span class="in">`r colorize("Numerical experiments show that this criterion, combined with the Legendre basis, achieve the best performance when considering the confidence level and the width of the corresponding simultaneous confidence band. ", "red")`</span></span>
<span id="cb19-1603"><a href="#cb19-1603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1604"><a href="#cb19-1604" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1605"><a href="#cb19-1605" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--The last selection criterion is heuristic, `r colorize("and includes terms that are intuitive.", "red")` while each term is intuitive.!--&gt;</span> </span>
<span id="cb19-1606"><a href="#cb19-1606" aria-hidden="true" tabindex="-1"></a>An interesting next step, but out of the scope of this paper, <span class="in">`r colorize("is", "red")`</span> <span class="co">&lt;!--consists of!--&gt;</span> a theoretical study of this criterion. <span class="in">`r colorize("To our knowledge, there are no results concerning the", "red")`</span> <span class="co">&lt;!--No result, to our knowledge, exist for!--&gt;</span>  confidence band with the supremum norm. The euclidean norm <span class="in">`r colorize("has been extensively studied,",  "red")`</span> <span class="co">&lt;!--is well-studied in general,!--&gt;</span> but is not of interest here, where we want to ensure that the tube is valid as a whole. The supremum norm, on <span class="in">`r colorize("the other hand,", "red")`</span> <span class="co">&lt;!--its side,!--&gt;</span> is difficult to study theoretically. <span class="in">`r colorize("Futhermore, a", "red")`</span> <span class="co">&lt;!--A!--&gt;</span> keypoint here <span class="co">&lt;!--also!--&gt;</span> is the randomness of the criterion, <span class="in">`r colorize("which must also", "red")`</span> <span class="co">&lt;!--that has also to!--&gt;</span> be taken into account, through an oracle inequality for example. </span>
<span id="cb19-1607"><a href="#cb19-1607" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1608"><a href="#cb19-1608" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb19-1609"><a href="#cb19-1609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1610"><a href="#cb19-1610" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb19-1611"><a href="#cb19-1611" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-1612"><a href="#cb19-1612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1613"><a href="#cb19-1613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1614"><a href="#cb19-1614" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix: proofs</span></span>
<span id="cb19-1615"><a href="#cb19-1615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1616"><a href="#cb19-1616" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of @prp-error </span></span>
<span id="cb19-1617"><a href="#cb19-1617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1618"><a href="#cb19-1618" aria-hidden="true" tabindex="-1"></a>Let us prove the first point.</span>
<span id="cb19-1619"><a href="#cb19-1619" aria-hidden="true" tabindex="-1"></a>We have </span>
<span id="cb19-1620"><a href="#cb19-1620" aria-hidden="true" tabindex="-1"></a>$$ \mathbb{E}(\hat{\underline{\mu}}^{L,L^\star}) = (\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbb{E}(\mathbf{y}) =(\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbf{B}_{L^*}\mu^{L^*}=:\underline{\mu}^{L,L^\star}.$$</span>
<span id="cb19-1621"><a href="#cb19-1621" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1622"><a href="#cb19-1622" aria-hidden="true" tabindex="-1"></a>The theory of the linear model gives that the variance of $\hat{\underline{\mu}}^L$ is equal to</span>
<span id="cb19-1623"><a href="#cb19-1623" aria-hidden="true" tabindex="-1"></a>$\sigma^2 (\mathbf{B}^T\mathbf{B})^{-1} \mathbf{B}^T\Sigma \mathbf{B}(\mathbf{B}^T\mathbf{B})^{-1}$</span>
<span id="cb19-1624"><a href="#cb19-1624" aria-hidden="true" tabindex="-1"></a>with $\Sigma=Diag(\Sigma_1, \ldots, \Sigma_N)$ the $nN \times nN$ covariance matrix of $\mathbf{y}$. </span>
<span id="cb19-1625"><a href="#cb19-1625" aria-hidden="true" tabindex="-1"></a>So finally, we have </span>
<span id="cb19-1626"><a href="#cb19-1626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1627"><a href="#cb19-1627" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-1628"><a href="#cb19-1628" aria-hidden="true" tabindex="-1"></a>\hat{\underline{\mu}}^{L,L^\star}</span>
<span id="cb19-1629"><a href="#cb19-1629" aria-hidden="true" tabindex="-1"></a>\sim \mathcal{N}\left(\underline{\mu}^{L,L^\star}, \sigma^2\Sigma_{B}^{L, L^ \varepsilon}</span>
<span id="cb19-1630"><a href="#cb19-1630" aria-hidden="true" tabindex="-1"></a>\right).</span>
<span id="cb19-1631"><a href="#cb19-1631" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-1632"><a href="#cb19-1632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1633"><a href="#cb19-1633" aria-hidden="true" tabindex="-1"></a>Now we can easily deduce the distribution of $\hat{\underline{f}}^{L,L^*}(t)$,</span>
<span id="cb19-1634"><a href="#cb19-1634" aria-hidden="true" tabindex="-1"></a>for each $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$:</span>
<span id="cb19-1635"><a href="#cb19-1635" aria-hidden="true" tabindex="-1"></a>$$\hat{\underline{f}}^{L,L^*}(t)- \mathbf f^{L,L^*}(t) \sim \mathcal{N}\left(0, \sigma^2 B(t)\Sigma_{B}^{L, L^\varepsilon} B(t)^T\right).$$</span>
<span id="cb19-1636"><a href="#cb19-1636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1637"><a href="#cb19-1637" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1638"><a href="#cb19-1638" aria-hidden="true" tabindex="-1"></a><span class="in">`r colorize("To prove that", "red")`</span> $(\hat{\underline{f}}^{L, L^*}-f^{L,L^*})()$ `r colorize("is a Gaussian process, we consider any finite sequence of times", "red")`, $(t_1, \ldots, t_d)\in [0,1]$. `r colorize("The sequence", "red")` $(\hat{\underline{f}}^{L, L^*}(t_1)-f^{L,L^*}(t_1), \ldots, \hat{\underline{f}}^{L, L^*}(t_d)-f^{L,L^*}(t_d))$ `r colorize("is Gaussian, centered and the covariance is equal to", "red")` $cov(\hat{\underline{f}}^{L, L^*}(t_1)-f^{L,L^*}(t_1), \hat{\underline{f}}^{L, L^*}(t_2)-f^{L,L^*}(t_2)) = \sigma^2 B(t_1)\Sigma_{B}^{L, L^\varepsilon} B(t_2)^T$. <span class="in">`r colorize("Thus the process is Gaussian.", "red")`</span></span>
<span id="cb19-1639"><a href="#cb19-1639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1640"><a href="#cb19-1640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1641"><a href="#cb19-1641" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of @thm-CB_Liebl_asymptotic</span></span>
<span id="cb19-1642"><a href="#cb19-1642" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1643"><a href="#cb19-1643" aria-hidden="true" tabindex="-1"></a>We have </span>
<span id="cb19-1644"><a href="#cb19-1644" aria-hidden="true" tabindex="-1"></a>$$P(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-\underline{f}^{L, L^*}(t)+ \underline{f}^{L, L^*}(t)- f^{L,L^*}(t)| \leq \hat d^L(t))$$</span>
<span id="cb19-1645"><a href="#cb19-1645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1646"><a href="#cb19-1646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1647"><a href="#cb19-1647" aria-hidden="true" tabindex="-1"></a>Set Assumption 1 and Assumption 3 and a probability $\alpha\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Then, we have, </span>
<span id="cb19-1648"><a href="#cb19-1648" aria-hidden="true" tabindex="-1"></a>$$\lim_{n \rightarrow +\infty} P(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = 1-\alpha$$</span>
<span id="cb19-1649"><a href="#cb19-1649" aria-hidden="true" tabindex="-1"></a>with $\hat d^L(t) = \hat c^L \sqrt{\hat C_L(t,t)/N}$ and $\hat c^L$ defined as the solution of @eq-cL.</span>
<span id="cb19-1650"><a href="#cb19-1650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1651"><a href="#cb19-1651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1652"><a href="#cb19-1652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1653"><a href="#cb19-1653" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of @prp-CBf</span></span>
<span id="cb19-1654"><a href="#cb19-1654" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1655"><a href="#cb19-1655" aria-hidden="true" tabindex="-1"></a>To simplify the notations, let us denote $a(t) = \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t)$ and $b(t) = \underline{f}^{L_{\max},L^*}(t)- \underline{f}^{L,L^*}(t)-(\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L,L^*}(t))$. </span>
<span id="cb19-1656"><a href="#cb19-1656" aria-hidden="true" tabindex="-1"></a>We have</span>
<span id="cb19-1657"><a href="#cb19-1657" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb19-1658"><a href="#cb19-1658" aria-hidden="true" tabindex="-1"></a>P\left( \exists t |a(t)+b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right) &amp;\leq </span>
<span id="cb19-1659"><a href="#cb19-1659" aria-hidden="true" tabindex="-1"></a>P\left( \exists t |a(t)|+|b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right)<span class="sc">\\</span></span>
<span id="cb19-1660"><a href="#cb19-1660" aria-hidden="true" tabindex="-1"></a>&amp;= P\left( \exists t |a(t)| \geq \hat d_1^L(t) \right)P\left( \exists t |b(t)|\geq \hat d_2^{L,L_{\max}}(t)\right) = \alpha\beta.</span>
<span id="cb19-1661"><a href="#cb19-1661" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb19-1662"><a href="#cb19-1662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1663"><a href="#cb19-1663" aria-hidden="true" tabindex="-1"></a>The last equality holds thanks to the independence of the two sub-samples. </span>
<span id="cb19-1664"><a href="#cb19-1664" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1665"><a href="#cb19-1665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1666"><a href="#cb19-1666" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix: more experiments</span></span>
<span id="cb19-1667"><a href="#cb19-1667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1668"><a href="#cb19-1668" aria-hidden="true" tabindex="-1"></a>@prp-proj and @prp-proj2 are illustrated in @fig-coefficients. The true dimension is $L^*=11$. Three families are considered, Fourier, Legendre and Splines. The plots display the absolute difference between the coefficients $\mu_\ell^{L^*}$ and the projected coefficients $\underline{\mu}^{L,L^*}$, for different $\ell$ in x-axis and for different values of $L$ and $n$ in the y-axis, namely a case with $L&lt;L^*$ and two values of $n$: $L=7, n=20$ and $L=7, n=100$; and a case with $L&gt;L^*$ and two values of $n$: $L=15, n=20$ and $L=15, n=100$. The absolute difference is represented as a gradient of color, this gradient being adapted to each functional family. We can see that as Legendre (resp. Fourier) are orthonormal (resp. orthogonal) families, the differences are close to $0$ when $L=15$, whatever the values of $n$. When $L&lt;L^*$, the difference is close to $0$ when $n$ is large. </span>
<span id="cb19-1669"><a href="#cb19-1669" aria-hidden="true" tabindex="-1"></a>This property does not hold for the spline family, which is not orthogonal. </span>
<span id="cb19-1670"><a href="#cb19-1670" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1671"><a href="#cb19-1671" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height=5, fig.width=7}</span></span>
<span id="cb19-1672"><a href="#cb19-1672" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: fig-coefficients</span></span>
<span id="cb19-1673"><a href="#cb19-1673" aria-hidden="true" tabindex="-1"></a><span class="in">#| fig-cap: "Illustrative example. The true dimension is 11, we generate the coefficients with three families, Fourier (which is orthogonal), Legendre (which is orthonormal) and the splines (which are not orthogonal wrt the standard scalar product). In the y-axis, two dimensions of the family (7 or 15) and two numbers of timepoints (20 or 100) are compared. We plot in x-axis the value of the absolute difference between the true coefficients and their approximations for the first 7 coefficients of the basis. The color scale is adapted to each functional basis. "</span></span>
<span id="cb19-1674"><a href="#cb19-1674" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1675"><a href="#cb19-1675" aria-hidden="true" tabindex="-1"></a><span class="in">set.seed(1)</span></span>
<span id="cb19-1676"><a href="#cb19-1676" aria-hidden="true" tabindex="-1"></a><span class="in">library(RColorBrewer)</span></span>
<span id="cb19-1677"><a href="#cb19-1677" aria-hidden="true" tabindex="-1"></a><span class="in">cols = brewer.pal(9, "BuPu")</span></span>
<span id="cb19-1678"><a href="#cb19-1678" aria-hidden="true" tabindex="-1"></a><span class="in">pal &lt;- colorRampPalette(cols)</span></span>
<span id="cb19-1679"><a href="#cb19-1679" aria-hidden="true" tabindex="-1"></a><span class="in">L.star = 10</span></span>
<span id="cb19-1680"><a href="#cb19-1680" aria-hidden="true" tabindex="-1"></a><span class="in">Time = seq(data$time[1], data$time[length(data$time)], length.out = 100)</span></span>
<span id="cb19-1681"><a href="#cb19-1681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1682"><a href="#cb19-1682" aria-hidden="true" tabindex="-1"></a><span class="in">L.star = 11</span></span>
<span id="cb19-1683"><a href="#cb19-1683" aria-hidden="true" tabindex="-1"></a><span class="in">vec.L = c(7,15)</span></span>
<span id="cb19-1684"><a href="#cb19-1684" aria-hidden="true" tabindex="-1"></a><span class="in">par(mfrow=c(3,1))</span></span>
<span id="cb19-1685"><a href="#cb19-1685" aria-hidden="true" tabindex="-1"></a><span class="in">for (basis in c("Fourier", "Legendre", "Splines")){</span></span>
<span id="cb19-1686"><a href="#cb19-1686" aria-hidden="true" tabindex="-1"></a><span class="in">  if (basis == "Splines"){</span></span>
<span id="cb19-1687"><a href="#cb19-1687" aria-hidden="true" tabindex="-1"></a><span class="in">    data = dgp(n=20,N=40,sd=2*1,L.star=L.star, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-1688"><a href="#cb19-1688" aria-hidden="true" tabindex="-1"></a><span class="in">  } else { data = dgp(n=20,N=40,sd=1,L.star=L.star, L.eps = 20, alpha.mu = NULL, basis = basis, f.true = NULL)</span></span>
<span id="cb19-1689"><a href="#cb19-1689" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1690"><a href="#cb19-1690" aria-hidden="true" tabindex="-1"></a><span class="in">  alpha.tot = c()</span></span>
<span id="cb19-1691"><a href="#cb19-1691" aria-hidden="true" tabindex="-1"></a><span class="in">  for (L in vec.L){</span></span>
<span id="cb19-1692"><a href="#cb19-1692" aria-hidden="true" tabindex="-1"></a><span class="in">    set.seed(1)</span></span>
<span id="cb19-1693"><a href="#cb19-1693" aria-hidden="true" tabindex="-1"></a><span class="in">    B = func.basis(data$time, L, basis)</span></span>
<span id="cb19-1694"><a href="#cb19-1694" aria-hidden="true" tabindex="-1"></a><span class="in">    B.n.large = func.basis(Time, L, basis)</span></span>
<span id="cb19-1695"><a href="#cb19-1695" aria-hidden="true" tabindex="-1"></a><span class="in">    B.Lstar.n.large = func.basis(Time, L.star, basis)</span></span>
<span id="cb19-1696"><a href="#cb19-1696" aria-hidden="true" tabindex="-1"></a><span class="in">    alpha.true.L = solve(t(B) %*% B) %*% t(B) %*% data$f.true</span></span>
<span id="cb19-1697"><a href="#cb19-1697" aria-hidden="true" tabindex="-1"></a><span class="in">    alpha.true.L.n.large = solve(t(B.n.large) %*% B.n.large) %*% t(B.n.large) %*% B.Lstar.n.large %*% data$alpha.mu</span></span>
<span id="cb19-1698"><a href="#cb19-1698" aria-hidden="true" tabindex="-1"></a><span class="in">    alpha.tot = cbind(alpha.tot, alpha.true.L[1:min(c(L.star, vec.L))]-data$alpha.mu[1:min(c(L.star, vec.L))], alpha.true.L.n.large[1:min(c(L.star, vec.L))] - data$alpha.mu[1:min(c(L.star, vec.L))])</span></span>
<span id="cb19-1699"><a href="#cb19-1699" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb19-1700"><a href="#cb19-1700" aria-hidden="true" tabindex="-1"></a><span class="in">  image.plot(abs(alpha.tot), main = paste0(basis, "'s basis"), col = pal(20), yaxt="n", xaxt = "n", xlab = "index of the basis" )</span></span>
<span id="cb19-1701"><a href="#cb19-1701" aria-hidden="true" tabindex="-1"></a><span class="in">  axis(2, at = seq(0, 1, length = ncol(alpha.tot)), labels = c("L=7, n=20", "L=7, n=100", "L=15, n=20", "L=15, n=100"), las = 2, cex.axis = 0.6)</span></span>
<span id="cb19-1702"><a href="#cb19-1702" aria-hidden="true" tabindex="-1"></a><span class="in">  axis(1, at = seq(0,1,length.out = 7), labels = c("1", "2", "3", "4", "5", "6", "7"))</span></span>
<span id="cb19-1703"><a href="#cb19-1703" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb19-1704"><a href="#cb19-1704" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-1705"><a href="#cb19-1705" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-1706"><a href="#cb19-1706" aria-hidden="true" tabindex="-1"></a> </span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
    <script type="text/javascript">
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let pseudocodeOptions = {
          indentSize: el.dataset.indentSize || "1.2em",
          commentDelimiter: el.dataset.commentDelimiter || "//",
          lineNumber: el.dataset.lineNumber === "true" ? true : false,
          lineNumberPunc: el.dataset.lineNumberPunc || ":",
          noEnd: el.dataset.noEnd === "true" ? true : false,
          titlePrefix: el.dataset.captionPrefix || "Algorithm"
        };
        pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
      });
    })(document);
    (function(d) {
      d.querySelectorAll(".pseudocode-container").forEach(function(el) {
        let captionSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
        if (captionSpan !== null) {
          let captionPrefix = el.dataset.captionPrefix + " ";
          let captionNumber = "";
          if (el.dataset.pseudocodeNumber) {
            captionNumber = el.dataset.pseudocodeNumber + " ";
            if (el.dataset.chapterLevel) {
              captionNumber = el.dataset.chapterLevel + "." + captionNumber;
            }
          }
          captionSpan.innerHTML = captionPrefix + captionNumber;
        }
      });
    })(document);
    </script>
  




</body></html>