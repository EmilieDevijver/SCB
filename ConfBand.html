<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emilie Devijver">
<meta name="author" content="Adeline Samson">
<meta name="dcterms.date" content="2024-05-27">
<meta name="keywords" content="functional data, repeated data, confidence band, Kac-Rice formulae, bias, dimension selection">

<title>Should we correct the bias in Confidence Bands for Repeated Functional Data?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="ConfBand_files/libs/clipboard/clipboard.min.js"></script>
<script src="ConfBand_files/libs/quarto-html/quarto.js"></script>
<script src="ConfBand_files/libs/quarto-html/popper.min.js"></script>
<script src="ConfBand_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="ConfBand_files/libs/quarto-html/anchor.min.js"></script>
<link href="ConfBand_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="ConfBand_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="ConfBand_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="ConfBand_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="ConfBand_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; Should we correct the bias in Confidence Bands for Repeated Functional Data?</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://lig-aptikal.imag.fr/~devijvee/">Emilie Devijver</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  CNRS, Univ. Grenoble Alpes, Grenoble INP, LIG, 38000 Grenoble, France
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://adeline.e-samson.org">Adeline Samson</a> 
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  Univ. Grenoble Alpes, CNRS, Grenoble INP, LJK, 38000 Grenoble, France
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">May 27, 2024</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">May 27, 2024</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">functional data, repeated data, confidence band, Kac-Rice formulae, bias, dimension selection</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>While confidence intervals for finite quantities are well-established, constructing confidence bands for objects of infinite dimension, such as functions, poses challenges. In this paper, we explore the concept of parametric confidence bands for functional data with an orthonormal basis. Specifically, we revisit the method proposed by Sun and Loader, which yields confidence bands for the projection of the regression function in a fixed-dimensional space. This approach can introduce bias in the confidence bands when the dimension of the basis is misspecified. Leveraging this insight, we introduce a corrected, unbiased confidence band. Surprisingly, our corrected band tends to be wider than what a naive approach would suggest. To address this, we propose a model selection criterion that allows for data-driven estimation of the basis dimension, balancing the trade-off between bias and variance. Throughout the paper, we illustrate these strategies using an extensive simulation study. We conclude with an application to real data.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-model" id="toc-sec-model" class="nav-link" data-scroll-target="#sec-model"><span class="header-section-number">2</span> Statistical Model</a>
  <ul class="collapse">
  <li><a href="#sec-functional_model" id="toc-sec-functional_model" class="nav-link" data-scroll-target="#sec-functional_model"><span class="header-section-number">2.1</span> Functional regression model</a></li>
  <li><a href="#sec-projection_model" id="toc-sec-projection_model" class="nav-link" data-scroll-target="#sec-projection_model"><span class="header-section-number">2.2</span> Approximation of the model on a finite family</a></li>
  <li><a href="#sec-estim" id="toc-sec-estim" class="nav-link" data-scroll-target="#sec-estim"><span class="header-section-number">2.3</span> Estimator</a>
  <ul class="collapse">
  <li><a href="#estimation-of-the-regression-function" id="toc-estimation-of-the-regression-function" class="nav-link" data-scroll-target="#estimation-of-the-regression-function"><span class="header-section-number">2.3.1</span> Estimation of the regression function</a></li>
  <li><a href="#statistics" id="toc-statistics" class="nav-link" data-scroll-target="#statistics"><span class="header-section-number">2.3.2</span> Statistics</a></li>
  <li><a href="#bias" id="toc-bias" class="nav-link" data-scroll-target="#bias"><span class="header-section-number">2.3.3</span> Bias</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-bandSun" id="toc-sec-bandSun" class="nav-link" data-scroll-target="#sec-bandSun"><span class="header-section-number">3</span> Confidence Bands of <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span> for a fixed <span class="math inline">L</span></a>
  <ul class="collapse">
  <li><a href="#sec-bandSun2" id="toc-sec-bandSun2" class="nav-link" data-scroll-target="#sec-bandSun2"><span class="header-section-number">3.1</span> Confidence band for <span class="math inline">\underline{f}^{L,L^*}</span></a></li>
  <li><a href="#sec-bandfLLstar" id="toc-sec-bandfLLstar" class="nav-link" data-scroll-target="#sec-bandfLLstar"><span class="header-section-number">3.2</span> Asymptotic confidence band for <span class="math inline">f^{L,L^*}</span></a></li>
  </ul></li>
  <li><a href="#sec-band2" id="toc-sec-band2" class="nav-link" data-scroll-target="#sec-band2"><span class="header-section-number">4</span> Confidence Band of <span class="math inline">f^{L^*}</span> by correcting the bias</a>
  <ul class="collapse">
  <li><a href="#sec-construction2" id="toc-sec-construction2" class="nav-link" data-scroll-target="#sec-construction2"><span class="header-section-number">4.1</span> Construction of the band of <span class="math inline">f^{L^*}</span> for a given <span class="math inline">L</span></a></li>
  <li><a href="#sec-SelectionL2" id="toc-sec-SelectionL2" class="nav-link" data-scroll-target="#sec-SelectionL2"><span class="header-section-number">4.2</span> Influence of <span class="math inline">L</span></a></li>
  <li><a href="#sec-comparisonBands" id="toc-sec-comparisonBands" class="nav-link" data-scroll-target="#sec-comparisonBands"><span class="header-section-number">4.3</span> Comparison with the confidence bands of Section&nbsp;3</a></li>
  </ul></li>
  <li><a href="#sec-modsel" id="toc-sec-modsel" class="nav-link" data-scroll-target="#sec-modsel"><span class="header-section-number">5</span> Selection criteria of the best confidence band accounting for the bias</a></li>
  <li><a href="#real-data-analysis" id="toc-real-data-analysis" class="nav-link" data-scroll-target="#real-data-analysis"><span class="header-section-number">6</span> Real data analysis</a></li>
  <li><a href="#sec-conc" id="toc-sec-conc" class="nav-link" data-scroll-target="#sec-conc"><span class="header-section-number">7</span> Conclusion</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#appendix-proofs" id="toc-appendix-proofs" class="nav-link" data-scroll-target="#appendix-proofs"><span class="header-section-number">8</span> Appendix: proofs</a>
  <ul class="collapse">
  <li><a href="#proof-of-proposition-prp-error" id="toc-proof-of-proposition-prp-error" class="nav-link" data-scroll-target="#proof-of-proposition-prp-error"><span class="header-section-number">8.1</span> Proof of Proposition Proposition&nbsp;3</a></li>
  <li><a href="#proof-of-theorem-thm-cb_liebl_asymptotic" id="toc-proof-of-theorem-thm-cb_liebl_asymptotic" class="nav-link" data-scroll-target="#proof-of-theorem-thm-cb_liebl_asymptotic"><span class="header-section-number">8.2</span> Proof of Theorem Theorem&nbsp;2</a></li>
  <li><a href="#proof-of-prp-cbf" id="toc-proof-of-prp-cbf" class="nav-link" data-scroll-target="#proof-of-prp-cbf"><span class="header-section-number">8.3</span> Proof of Proposition&nbsp;5</a></li>
  </ul></li>
  <li><a href="#sec:band1" id="toc-sec:band1" class="nav-link" data-scroll-target="#sec\:band1"><span class="header-section-number">9</span> Heuristics of bounding separately the infinity norms of the term and the term</a>
  <ul class="collapse">
  <li><a href="#sec-BiasLstar" id="toc-sec-BiasLstar" class="nav-link" data-scroll-target="#sec-BiasLstar"><span class="header-section-number">9.1</span> Bound of the term.</a></li>
  <li><a href="#sec-ApproxLstar" id="toc-sec-ApproxLstar" class="nav-link" data-scroll-target="#sec-ApproxLstar"><span class="header-section-number">9.2</span> Bound of the term.</a></li>
  <li><a href="#sec-BandLstar" id="toc-sec-BandLstar" class="nav-link" data-scroll-target="#sec-BandLstar"><span class="header-section-number">9.3</span> Confidence band of <span class="math inline">\underline{f}^{L^*}</span> for a given <span class="math inline">L</span></a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="ConfBand.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Functional data analysis is widely used for handling complex data with smooth shapes, finding applications in diverse fields such as neuroscience (e.g., EEG data, ), psychology (e.g., mouse-tracking data, <span class="citation" data-cites="Quinton-2017-escon">Quinton et al. (<a href="#ref-Quinton-2017-escon" role="doc-biblioref">2017</a>)</span>), and sensor data from daily-life activities (<span class="citation" data-cites="jacques2022">Jacques and Samardžić (<a href="#ref-jacques2022" role="doc-biblioref">2022</a>)</span>).</p>
<p>We consider multiple independent observations of the same function, yielding noisy functional data. To analyze such data, a common approach, typically in the parametric setting, involves projecting the data onto a functional space defined by a family of functions (<span class="citation" data-cites="LI2022104806">Li, Qiu, and Xu (<a href="#ref-LI2022104806" role="doc-biblioref">2022</a>)</span>, <span class="citation" data-cites="kokoszka2017introduction">Kokoszka and Reimherr (<a href="#ref-kokoszka2017introduction" role="doc-biblioref">2017</a>)</span>). When the family serves as an orthonormal basis, e.g., Legendre (with the standard scalar product) or Fourier (with another scalar product), the projection is clearly understood, but widely used families such as splines are not orthonormal for the standard scalar product. Leveraging an approximate functional space offers a key advantage: it simplifies the inference problem to estimating coefficients, for example through methods like least squares or maximum likelihood estimation. Subsequently, the function is estimated as the mean of the functional data following projection onto the functional basis.</p>
<p>Measuring the uncertainty of an estimator is usually done using confidence intervals. In this paper, our focus lies specifically on providing a simultaneous confidence band for the function means, rather than point-wise confidence intervals. This task presents several challenges: the confidence band must effectively control the simultaneous functional type-I error rate, as opposed to point-wise rates; it must strike a balance between being sufficiently conservative to maintain a confidence level while not being overly so as to render it meaningless; and the method used to construct this confidence band should be computationally feasible for practical application.</p>
<p>Several developments have already been proposed to answer these questions. First, consider the case with only one individual (no repetition) but with many time points. Some methods study the asymptotic distribution of the infinity norm between the true function and its estimator. The asymptotic in the number of time points is studied in <span class="citation" data-cites="Hall1991">Hall (<a href="#ref-Hall1991" role="doc-biblioref">1991</a>)</span>, <span class="citation" data-cites="Claeskens2003">Claeskens and Van Keilegom (<a href="#ref-Claeskens2003" role="doc-biblioref">2003</a>)</span>. This approach works only for large datasets in time and is likely to be too conservative otherwise. For small samples, bootstrap methods have been developed to compute the confidence band (<span class="citation" data-cites="Neumann1998">Neumann and Polzehl (<a href="#ref-Neumann1998" role="doc-biblioref">1998</a>)</span>, <span class="citation" data-cites="Claeskens2003">Claeskens and Van Keilegom (<a href="#ref-Claeskens2003" role="doc-biblioref">2003</a>)</span>), but with a high computational cost. Another approach is to construct confidence bands based on the volume of the tube formula. <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> studied the tail probabilities of suprema of Gaussian random processes. This approach is based on an unbiased linear estimator of the regression function. <span class="citation" data-cites="Zhou1998">Zhou, Shen, and Wolfe (<a href="#ref-Zhou1998" role="doc-biblioref">1998</a>)</span> used the volume-of-tube formula for estimation by regression splines. <span class="citation" data-cites="Krivobokova2010">Krivobokova, Kneib, and Claeskens (<a href="#ref-Krivobokova2010" role="doc-biblioref">2010</a>)</span> used this method for the construction of confidence bands by penalized spline estimators. They proposed to mix Bayesian and frequentist approaches, to get the good properties from the Bayesian world but reducing the variability to be less conservative using the frequentist approach. The bias is considered through spline modeling, assuming sufficient knots are considered. <span class="citation" data-cites="Liebl2019">Liebl and Reimherr (<a href="#ref-Liebl2019" role="doc-biblioref">2019</a>)</span> have proposed a method based on random field theory and the volume-of-tube formula. They provide a band with locally varying widths using an unbiased estimator. Their method does not require the estimation of the full covariance function of the estimator, but only its diagonal. This reduces the computational time. From a practical viewpoint, <span class="citation" data-cites="CB_survivalAnalysis2022">Sachs, Brand, and Gabriel (<a href="#ref-CB_survivalAnalysis2022" role="doc-biblioref">2022</a>)</span> introduce a package to popularize simultaneous confidence bands, in the context of survival analysis.</p>
<p>Some papers, like ours, rely on several observations of the same function. <span class="citation" data-cites="bunea2011">Bunea, Ivanescu, and Wegkamp (<a href="#ref-bunea2011" role="doc-biblioref">2011</a>)</span> propose a threshold-type estimator and derive error bounds and simultaneous confidence bands, having an unbiased estimator. <span class="citation" data-cites="TELSCHOW202270">Telschow and Schwartzman (<a href="#ref-TELSCHOW202270" role="doc-biblioref">2022</a>)</span> propose a simultaneous confidence band based on the Gaussian kinematic formula. Again, it assumes access to an unbiased estimator of the function of interest. Note that recent extensions have been proposed, to nonstationary random field in <span class="citation" data-cites="Telschow2023">Telschow et al. (<a href="#ref-Telschow2023" role="doc-biblioref">2023</a>)</span> and based on conformal prediction in <span class="citation" data-cites="conformalPrediction2022">Diquigiovanni, Fontana, and Vantini (<a href="#ref-conformalPrediction2022" role="doc-biblioref">2022</a>)</span>. These extensions are out of the scope of this paper, focusing on the simple functional case.</p>
<p>One limitation of all those approaches is that they do not generally take into account the bias of the functional estimator. <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> proposed a bias correction for a particular class of functions but left the smoothing parameter choice open, leading to an unusable estimator. In the nonparametric framework, the bias is approximated using the estimator of the second derivative of the underlying mean function (<span class="citation" data-cites="Xia1998">Xia (<a href="#ref-Xia1998" role="doc-biblioref">1998</a>)</span>). But in general, there is a lack of discussion on how to handle the bias of the functional estimator, even in the simple case of a functional space of finite dimension.</p>
<p>The objective of this paper is to address the bias problem in confidence band construction for a general function, utilizing a finite functional orthonormal family. Our contributions are as follows:</p>
<ul>
<li>we disentangle the bias issue by explicitly defining the parameter of interest within the approach of <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span>;</li>
<li>we propose a bias correction method in a new confidence band for the function of interest;</li>
<li>we illustrate this confidence band, concluding on the conservatism of the procedure;</li>
<li>finally, we propose a method for selecting the dimension of the approximation space, treating it as a model selection problem, with a trade-off between conservatism and confidence level assurance.</li>
</ul>
<p>Note that while the model selection paradigm has been extensively studied in the literature, in multivariate statistics or functional data analysis (e.g., <span class="citation" data-cites="GoeppSubmitted">Goepp, Bouaziz, and Nuel (<a href="#ref-GoeppSubmitted" role="doc-biblioref">Submitted</a>)</span>, <span class="citation" data-cites="ANEIROS2022104871">Aneiros, Novo, and Vieu (<a href="#ref-ANEIROS2022104871" role="doc-biblioref">2022</a>)</span>, <span class="citation" data-cites="BASNA2022104868">Basna, Nassar, and Podgórski (<a href="#ref-BASNA2022104868" role="doc-biblioref">2022</a>)</span>), it has not been explored in the context of confidence band construction.</p>
<p>The paper is organized as follows: <a href="#sec-model">Section&nbsp;2</a> introduces the functional regression model, the considered functional family and the corresponding approximate regression models, as well as an estimator defined in the finite space, along with descriptions of the error terms. In <a href="#sec-bandSun">Section&nbsp;3</a>, we propose a confidence band for the approximate regression function in the space of finite dimension, where the dimension is fixed. <a href="#sec-band2">Section&nbsp;4</a> proposes a strategy to construct a confidence band for the true function. This last confidence band being too conservative, <a href="#sec-modsel">Section&nbsp;5</a> introduces a model selection criterion to select the best confidence band, doing a trade-off between conservatism and confidence level assurance. <a href="#sec-conc">Section&nbsp;7</a> ends the paper by a conclusion and discussion of perspectives. The different estimation procedures are illustrated throughout the sections.</p>
</section>
<section id="sec-model" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Statistical Model</h1>
<p>In this paper, we consider time series as discrete measurements of functional curves. We first present the general functional regression model (<a href="#sec-functional_model">Section&nbsp;2.1</a>) where the regression function belongs to a finite functional family of dimension <span class="math inline">L^*</span>. In practice, this dimension <span class="math inline">L^*</span> is unknown and we will work on functional space of dimension <span class="math inline">L</span>. The regression model on the finite family of functions is presented in <a href="#sec-projection_model">Section&nbsp;2.2</a>, and an estimator is proposed in <a href="#sec-estim">Section&nbsp;2.3</a>, with a description of the error terms.</p>
<section id="sec-functional_model" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-functional_model"><span class="header-section-number">2.1</span> Functional regression model</h2>
<p>Let <span class="math inline">y_{ij}</span> be the measure at fixed time <span class="math inline">t_{j} \in [a,b]</span> for individual <span class="math inline">i=1, \ldots, N</span>, with <span class="math inline">j=1, \ldots, n</span>. We restrict ourselves to <span class="math inline">[a,b] = [0,1]</span>, without loss of generality. We assume these observations are discrete-time measurements of individual curves, which are independent and noisy realisations of a common function <span class="math inline">f</span> that belongs to a functional space. Thus for each individual <span class="math inline">i</span>, we consider the following functional regression model <span class="math display">\begin{equation*}
y_{ij} = f(t_{j}) + \varepsilon_{ij},
\end{equation*}</span> where <span class="math inline">\varepsilon_{i.}=(\varepsilon_{i1}, \ldots, \varepsilon_{in})</span> is the noise representing the individual functional variation around <span class="math inline">f</span>. We assume that the <span class="math inline">\varepsilon_{i}</span> are independent. Their distribution is detailed below.</p>
<p>For each individual <span class="math inline">i=1, \ldots, N</span>, we denote <span class="math inline">y_{i.}=(y_{i1}, \ldots, y_{in})</span> the <span class="math inline">n\times 1</span> vector of observations, <span class="math inline">t_{.}=(t_{1}, \ldots, t_{n})</span> the <span class="math inline">n \times 1</span> vector of observation times and <span class="math inline">f(t_{.})=(f(t_{1}), \ldots, f(t_{n}))</span> the <span class="math inline">n \times 1</span> vector of the function <span class="math inline">f</span> evaluated in <span class="math inline">t_{.}</span>. We also denote <span class="math inline">\mathbf{y} = (y_{1.}, \ldots, y_{N.})</span> the whole matrix of observations.</p>
<p>Let us introduce the functional space <span class="math inline">\mathcal{S}^{L^*} = Vect((t \mapsto B_\ell^{L^*}(t))_{1\leq \ell \leq L^*})</span> with <span class="math inline">L^*</span> functions <span class="math inline">(B_\ell^{L^*})_{1\leq \ell \leq L^*}</span> assumed to be linearly independent. Then, for any <span class="math inline">f \in \mathcal{S}^{L^*}</span>, there exists a unique vector of coefficients <span class="math inline">(\mu_{\ell}^{L^*})_{1\leq \ell \leq L^*}</span> such that, for all <span class="math inline">t</span>, <span class="math inline">f(t) = \sum_{\ell =1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t)</span>. The regression function <span class="math inline">f</span> verifies the following assumption:</p>
<div id="def-ass-regression_finite" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1 </strong></span>The function <span class="math inline">f</span> belongs to the space <span class="math inline">\mathcal{S}^{L^*}</span> of dimension <span class="math inline">L^*</span>. It is denoted <span class="math inline">{f}^{L^*}</span> and defined as: <span class="math display">f(t) = {f}^{L^*}(t) = \sum_{\ell = 1}^{L^*} \mu_\ell^{L^*} B^{L^*}_\ell(t). </span></p>
</div>
<p>Many functional spaces are available in the literature, as Splines, Fourier or Legendre families. Let us consider the space <span class="math inline">L^2([0,1])</span> with its standard scalar product <span class="math inline">&lt;f_1,f_2&gt; = \int_0^1 |f_1(t)f_2(t)|dt</span>, for <span class="math inline">f_1,f_2 \in L^2([0,1])</span>. We introduce the following assumption:</p>
<div id="def-ass-orth" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 2 </strong></span>The functional family <span class="math inline">(t \mapsto B^{L^*}_\ell(t))_{1\leq \ell\leq L^*}</span> is orthonormal with respect to the standard scalar product <span class="math inline">&lt;.,.&gt;</span>.</p>
</div>
<p>Note that if <a href="#def-ass-orth">Definition&nbsp;2</a> holds, one get <span class="math inline">\mu_\ell^{L^*} = &lt;{f}^{L^*},B^{L^*}_\ell&gt;</span> for <span class="math inline">\ell = 1,\ldots, L^*</span>. The Legendre family is orthonormal, the Fourier family is orthogonal for the standard scalar product (but not orthonormal), and the B-splines family is not orthogonal.</p>
<p>We also consider a functional noise through the following assumption.</p>
<div id="def-ass-noise-spline" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 3 </strong></span>The sequence <span class="math inline">\varepsilon_{i}</span> is functional and belongs to the functional space <span class="math inline">\mathcal{S}^{L^\varepsilon}</span> of dimension <span class="math inline">L^\varepsilon</span>. Then, there exists a sequence of coefficients <span class="math inline">(c_{i\ell})_{1\leq \ell\leq L^\varepsilon}</span> such that <span class="math display">\varepsilon_{ij} = \sum_{\ell = 1}^{L^\varepsilon} c_{i\ell} B_\ell^{L^\varepsilon}(t_{j}).</span> We also assume that the coefficients are Gaussian: for all <span class="math inline">i=1,\ldots, N</span> and <span class="math inline">\ell=1, \ldots, L^\varepsilon</span>, <span class="math display">c_{i \ell} \sim_{iid} \mathcal{N}(0,\sigma^2).</span></p>
</div>
<p><a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-noise-spline">Definition&nbsp;3</a> imply that each curve <span class="math inline">y_i</span> belongs to a finite family: for <span class="math inline">j=1,\ldots,n</span>, <span class="math display"> y_{ij} = \sum_{\ell=1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t_{j}) + \sum_{\ell=1}^{L^\varepsilon} c_{i\ell} B_\ell^{L^\varepsilon}(t_{j}). </span></p>
<p>As the observations are recorded at discrete time points <span class="math inline">(t_j)_{1\leq j \leq n}</span>, we introduce the family of functions evaluated at the discrete times of observations. For <span class="math inline">L\in \mathbb{N}</span>, let us denote <span class="math inline">\mathbf{B}^L</span> the matrix of <span class="math inline">n\times L</span> with coefficient in row <span class="math inline">j</span> and column <span class="math inline">\ell</span> equal to <span class="math inline">B^L_\ell(t_{j})</span>.</p>
<p>Let us introduce <span class="math inline">c_{i.}=(c_{i1}, \ldots, c_{iL^\varepsilon})</span> the <span class="math inline">L^\varepsilon \times 1</span> vector. Then <span class="math inline">\varepsilon_{i.} = \mathbf{B}^{L^\varepsilon} c_{i.}</span>. The vectors <span class="math inline">y_{i.} \in \mathbb{R}^n</span> are thus independent and <span class="math inline">y_i\sim \mathcal{N}_n(f(t_{.}), \sigma^2 \Sigma^{L^\varepsilon})</span> with <span class="math inline">\Sigma^{L^\varepsilon} = \mathbf{B}^{L^\varepsilon} (\mathbf{B}^{L^\varepsilon})^T</span>.</p>
<p>To illustrate the model, we simulate a regression functional model with <span class="math inline">n=50</span> points per individual and <span class="math inline">N=40</span> individuals. In <a href="#fig-BasisModel">Figure&nbsp;1</a>, the function <span class="math inline">f</span> (red curve) belongs to the Fourier (resp. Legendre and Spline) family with <span class="math inline">L^*=10</span> and the noisy observations <span class="math inline">y_{ij}</span> (black curves) have a functional noise in dimension <span class="math inline">L^{\varepsilon}=20</span>, also in the Fourier (resp. Legendre and Spline) family on the left plot (resp. middle and right).</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fda)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(orthopolynom)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(wavelets)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(basefun)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fields)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggpubr)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>func.basis <span class="ot">=</span> <span class="cf">function</span>(time, L, basis){</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Splines'</span>){</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">bsplineS</span>(time,<span class="at">breaks =</span> <span class="fu">seq</span>(<span class="fu">min</span>(time), <span class="fu">max</span>(time), <span class="at">length.out =</span> L<span class="dv">-1</span>), <span class="at">norder =</span> <span class="dv">3</span>, <span class="dv">0</span>) </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">fourier</span>(time,<span class="at">nbasis =</span> L) </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Legendre'</span>){</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">Legendre_basis</span>(<span class="fu">numeric_var</span>(<span class="st">"x"</span>, <span class="at">support =</span> <span class="fu">c</span>(<span class="fu">min</span>(time), <span class="fu">max</span>(time))), </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                       <span class="at">order =</span> L<span class="dv">-1</span>)(time)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(B)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>dgp <span class="ot">=</span> <span class="cf">function</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> <span class="st">'Fourier'</span>, <span class="at">f.true =</span> <span class="cn">NULL</span>){ </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="do">### n: number of timepoints</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span class="do">### N: number of individuals</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="do">### sd: noise level (standard deviation)</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L.eps: number of functional basis for the noise</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha.mu: vector of coefficients</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Legendre', 'Fourier', 'Splines'</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="do">### f.true: if one wants to fix the true function</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out =</span> n)</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L.star<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L.star <span class="ot">=</span> L.star<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L.eps<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L.eps <span class="ot">=</span> L.eps<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(f.true)){</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="do">### Create the functional basis </span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L.star, basis)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="do">### Generate randomly coefficients, if needed</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(alpha.mu)){</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>      alpha.mu <span class="ot">=</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">5</span><span class="sc">:-</span><span class="dv">2</span>, <span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>),<span class="at">size=</span>L.star,<span class="at">replace=</span><span class="cn">TRUE</span>)} </span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>      alpha.mu <span class="ot">=</span> alpha.mu <span class="sc">/</span> <span class="dv">3</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>      sd <span class="ot">=</span> sd<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow =</span> N, <span class="at">ncol =</span> n)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    f.true <span class="ot">=</span> B <span class="sc">%*%</span> alpha.mu</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>  B.eps <span class="ot">=</span> <span class="fu">func.basis</span>(time, L.eps, basis)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow =</span> N, <span class="at">ncol =</span> n)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    y[i,] <span class="ot">=</span> f.true <span class="sc">+</span> B.eps <span class="sc">%*%</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(L.eps, <span class="dv">0</span>, sd))</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">y =</span> <span class="fu">t</span>(y), <span class="at">alpha.mu =</span> alpha.mu, <span class="at">time =</span> time, <span class="at">L.star=</span>L.star, <span class="at">f.true =</span> f.true))</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>n<span class="ot">=</span><span class="dv">50</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>N<span class="ot">=</span><span class="dv">40</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>sd<span class="ot">=</span><span class="dv">1</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>L.star<span class="ot">=</span><span class="dv">11</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>L.eps <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>alpha.mu <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>dfLegendre <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>                         <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>f.true),</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>                         <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Fourier"</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>dfFourier <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>f.true),</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>dfSplines <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y,data<span class="sc">$</span>f.true),</span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">rbind</span>(dfLegendre, dfFourier, dfSplines)</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> df, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">color =</span> type, <span class="at">group =</span> ind)) <span class="sc">+</span> </span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_colour_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"obs"</span> <span class="ot">=</span> <span class="st">"lightgrey"</span>,<span class="st">"True"</span> <span class="ot">=</span> <span class="st">"red"</span>)) <span class="sc">+</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-BasisModel" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-BasisModel-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Illustrative example. We generate a regression functional model in the Fourier (left), Legendre (middle) and Splines (right) families. The red curve corresponds to the true function, and the gray curves correspond to noisy observations.</figcaption>
</figure>
</div>
</div>
</div>
<p>The objective of this paper is to construct a tight confidence bound for <span class="math inline">f^{L^*}</span> using data <span class="math inline">(y_{ij})_{ij}</span>. The main challenge is that the true dimension <span class="math inline">L^*</span> is unknown. In the rest of the paper, we will work with a collection of models defined on a finite family of dimension <span class="math inline">L</span> with <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span>, <span class="math inline">L_{\max}</span> being chosen to be sufficiently large by the user, expecting that <span class="math inline">L^*\leq L_{\max}</span>. Then we will propose different strategies to choose the best bandwidths among the different collections.</p>
<p>First, in <a href="#sec-projection_model">Section&nbsp;2.2</a> and <a href="#sec-estim">Section&nbsp;2.3</a>, we define for a fixed <span class="math inline">L</span> the corresponding regression model and its estimator. Then <a href="#sec-bandSun">Section&nbsp;3</a>, <a href="#sec-band2">Section&nbsp;4</a> and <a href="#sec-modsel">Section&nbsp;5</a> will introduce the different bandwidths.</p>
</section>
<section id="sec-projection_model" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-projection_model"><span class="header-section-number">2.2</span> Approximation of the model on a finite family</h2>
<p>Let <span class="math inline">f^{L^*} \in \mathcal{S}^{L^*}</span> with <span class="math inline">L^*</span> unknown, and consider the space <span class="math inline">\mathcal{S}^L</span> for <span class="math inline">L\in \{1, \ldots, L_{\max}\}</span> fixed. As <span class="math inline">\mathcal{S}^L</span> is a family of linearly independent functions, there always exists a unique vector <span class="math inline">\mu^{L,L^*}</span> of coefficients defining <span class="math inline">f^{L,L^*}(t) = \sum_{\ell_=1}^L \mu_\ell^{L,L^*} B_\ell^L(t)=B^L(t) \mu^{L,L^*}</span> such that <span class="math display">f^{L,L^*} = \arg\min_{f \in \mathcal{S}^L}\{\|f^{L^*} - f\|_2^2\},</span> and if the family is orthonormal (<a href="#def-ass-orth">Definition&nbsp;2</a>), it corresponds to the projected coefficients <span class="math inline">\mu_{\ell}^{L,L^*}</span>: <span class="math display">\mu_{\ell}^{L,L^*} :=&lt;f^{L^*}, B_\ell^L&gt;.</span></p>
<p>We can prove the following property:</p>
<div id="prp-proj" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1 </strong></span>Under <a href="#def-ass-regression_finite">Definition&nbsp;1</a>, <span class="math display">f^{L^*,L^*} = f^{L^*}.</span> Moreover, if <a href="#def-ass-orth">Definition&nbsp;2</a> also holds, the projection coefficients verify <span class="math display">\mu_{\ell}^{L,L^*} = \mu_\ell^{L^*} \quad{ for }\; \ell =1, \ldots, \min(L, L^{*}).</span></p>
</div>
<p>In practice, data are observed at discrete time, we consider the operator <span class="math inline">\mathbf{P}^L</span> defined as the matrix <span class="math inline">\mathbf{P}^L = ((\mathbf{B}^L)^T \mathbf{B}^L)^{-1} (\mathbf{B}^L)^T</span> of size <span class="math inline">L\times n</span> (this operator is a bit more complex when the functional family is not orthonormal wrt the standard scalar product). Then we define the coefficients <span class="math inline">\underline{\mu}^{L,L^*}</span> which are the coefficients of <span class="math inline">{\mu}^{L,L^*}</span> approximated on the vector space, denoted <span class="math inline">\mathbf{S}^L</span>, defined by the matrix <span class="math inline">\mathbf{B}^L</span>. <span class="math display">\underline{\mu}^{L,L^*} := \mathbf{P}^L \mathbf{B}^{L^*}\mu^{L^*}.</span></p>
<p>The corresponding finite approximated regression function is denoted <span class="math inline">\underline{f}^{L,L^*}</span> and is defined, for all <span class="math inline">t\in [0,1]</span>, as <span class="math display">\underline{f}^{L,L^*}(t) = B^L(t) \underline{\mu}^{L,L^*}.</span></p>
<p>We can prove the following properties linking <span class="math inline">L, L^*</span> and the number of timepoints <span class="math inline">n</span>:</p>
<div id="prp-proj2" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 2 </strong></span>Under <a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-orth">Definition&nbsp;2</a>,</p>
<ul>
<li>When <span class="math inline">L\geq L^*</span>, <span class="math inline">\mathbf{P}^L \mathbf{B}^{L^*}</span> has <span class="math inline">L^*</span> diagonal elements equal to 1 and other non-diagonal elements close to 0. The first <span class="math inline">L^*</span> elements of <span class="math inline">\underline{\mu}^{L,L^*}</span> are equal to <span class="math inline">\mu^{L^*}</span> when <span class="math inline">n&gt;L</span>.</li>
<li>When <span class="math inline">L&lt;L^*</span>, <span class="math inline">\mathbf{P}^L\mathbf{B}^{L^*}</span> has <span class="math inline">L</span> diagonal elements equal to 1. The first <span class="math inline">L</span> elements of <span class="math inline">\underline{\mu}^{L,L^*}</span> are different to <span class="math inline">\mu_\ell^{L^*}</span>. When <span class="math inline">n\rightarrow\infty</span>, <span class="math inline">\underline{\mu}_\ell^{L,L^*}\rightarrow \mu_\ell^{L^*}</span> for <span class="math inline">\ell = 1,\ldots, \min(L,L^*)</span>.</li>
<li>If <span class="math inline">n&gt;L^*</span>, then <span class="math inline">f^{L^*} = f^{L^*,L^*} = \underline{f}^{L^*,L^*}</span>.</li>
</ul>
</div>
<p>These properties are illustrated in <a href="#fig-coefficients">Figure&nbsp;2</a>. The true dimension is <span class="math inline">L^*=11</span>. Three families are considered, Fourier, Legendre and Splines. The plots display the absolute difference between the coefficients <span class="math inline">\mu_\ell^{L^*}</span> and the projected coefficients <span class="math inline">\underline{\mu}^{L,L^*}</span>, for different <span class="math inline">\ell</span> in x-axis and for different values of <span class="math inline">L</span> and <span class="math inline">n</span> of the y-axis, namely a case with <span class="math inline">L&lt;L^*</span> and two values of <span class="math inline">n</span>: <span class="math inline">L=7, n=20</span> and <span class="math inline">L=7, n=100</span>; and a case with <span class="math inline">L&gt;L^*</span> and two values of <span class="math inline">n</span>: <span class="math inline">L=15, n=20</span> and <span class="math inline">L=15, n=100</span>. The absolute difference is represented as a gradient of color, this gradient being adapted for each functional family. We can see that as Legendre (resp. Fourier) are orthonormal (resp. orthogonal) families, the differences are close to <span class="math inline">0</span> when <span class="math inline">L=15</span>, whatever the values of <span class="math inline">n</span>. When <span class="math inline">L&lt;L^*</span>, the difference is close to <span class="math inline">0</span> when <span class="math inline">n</span> is large. This property does not hold for the spline family, which is not orthogonal.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RColorBrewer)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">=</span> <span class="fu">brewer.pal</span>(<span class="dv">9</span>, <span class="st">"BuPu"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>pal <span class="ot">&lt;-</span> <span class="fu">colorRampPalette</span>(cols)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>L.star <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>Time <span class="ot">=</span> <span class="fu">seq</span>(data<span class="sc">$</span>time[<span class="dv">1</span>], data<span class="sc">$</span>time[<span class="fu">length</span>(data<span class="sc">$</span>time)], <span class="at">length.out =</span> <span class="dv">100</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>L.star <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">7</span>,<span class="dv">15</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Fourier"</span>, <span class="st">"Legendre"</span>,  <span class="st">"Splines"</span>)){</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">20</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  alpha.tot <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    B.n.large <span class="ot">=</span> <span class="fu">func.basis</span>(Time, L, basis)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    B.Lstar.n.large <span class="ot">=</span> <span class="fu">func.basis</span>(Time, L.star, basis)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    alpha.true.L <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    alpha.true.L.n.large <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.n.large) <span class="sc">%*%</span> B.n.large) <span class="sc">%*%</span> <span class="fu">t</span>(B.n.large) <span class="sc">%*%</span> B.Lstar.n.large <span class="sc">%*%</span> data<span class="sc">$</span>alpha.mu</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    alpha.tot <span class="ot">=</span> <span class="fu">cbind</span>(alpha.tot, alpha.true.L[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))]<span class="sc">-</span>data<span class="sc">$</span>alpha.mu[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))], alpha.true.L.n.large[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))] <span class="sc">-</span> data<span class="sc">$</span>alpha.mu[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))])</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">image.plot</span>(<span class="fu">abs</span>(alpha.tot), <span class="at">main =</span> <span class="fu">paste0</span>(basis, <span class="st">"'s basis"</span>), <span class="at">col =</span> <span class="fu">pal</span>(<span class="dv">20</span>), <span class="at">yaxt=</span><span class="st">"n"</span>, <span class="at">xaxt =</span> <span class="st">"n"</span>, <span class="at">xlab =</span> <span class="st">"index of the basis"</span> )</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">axis</span>(<span class="dv">2</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length =</span> <span class="fu">ncol</span>(alpha.tot)), <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"L=7, n=20"</span>, <span class="st">"L=7, n=100"</span>, <span class="st">"L=15, n=20"</span>, <span class="st">"L=15, n=100"</span>), <span class="at">las =</span> <span class="dv">2</span>, <span class="at">cex.axis =</span> <span class="fl">0.7</span>)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">axis</span>(<span class="dv">1</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">length.out =</span> <span class="dv">7</span>), <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>, <span class="st">"4"</span>, <span class="st">"5"</span>, <span class="st">"6"</span>, <span class="st">"7"</span>))</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-coefficients" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-coefficients-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Illustrative example. The true dimension is 11, we generate the coefficients with three families, Fourier (which is orthogonal), Legendre (which is orthonormal) and the splines (which are not orthogonal wrt the standard scalar product). In the y-axis, two dimensions of the family (7 or 15) and two numbers of timepoints (20 or 100) are compared. We plot in x-axis the value of the absolute difference between the true coefficients and their approximations for the first 7 coefficients of the basis. The color scale is adapted to each functional basis.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-estim" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-estim"><span class="header-section-number">2.3</span> Estimator</h2>
<p>Let <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span>. This section presents the least square estimator of the regression function on the space of dimension <span class="math inline">L</span> defined by the family <span class="math inline">\mathbf{B}^L</span> and discusses its error.</p>
<section id="estimation-of-the-regression-function" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="estimation-of-the-regression-function"><span class="header-section-number">2.3.1</span> Estimation of the regression function</h3>
<p>When considering the estimation of the regression function <span class="math inline">f^{L^*}</span> on the space of dimension <span class="math inline">L</span> defined by the family <span class="math inline">\mathbf{B}^L</span>, we do not directly estimate <span class="math inline">f^{L^*}</span> but its projection on this finite space, which corresponds to the projected function <span class="math inline">\underline{f}^{L,L^*}(t)</span> and its associated coefficients <span class="math inline">(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}</span>.</p>
<div id="def-proj2" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 4 </strong></span>The vector of coefficients <span class="math inline">(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}</span> is estimated by the least square estimator <span class="math inline">\hat{\underline{\mu}}^{L, L^*}</span> defined as: <span class="math display">\begin{align*}
\hat{\underline{\mu}}^{L, L^*}:=\frac1N \sum_{i=1}^N
\mathbf{P}^L y_{i.}.
\end{align*}</span></p>
<p>For a fixed <span class="math inline">t \in [0,1]</span>, the estimator of the function <span class="math inline">\underline{f}^{L,L^*}(t)</span> is defined by:</p>
<p><span id="eq-fhatL"><span class="math display"> \underline{\hat{f}_{}}^{L,L^*}(t) = \sum_{\ell=1}^L \underline{\hat \mu}_\ell^{L,L^*} B^L_\ell(t)= B^L(t)\hat{\underline{\mu}}^{L,L^*}.
\tag{1}</span></span></p>
</div>
<p><a href="#eq-fhatL">Equation&nbsp;1</a> directly implies that the estimator is thus the empirical mean of the functional approximation of each individual vector of observations. Because we work with least squares estimators, we can easily study the error of estimation of <span class="math inline">\hat{\underline{\mu}}^{L, L^*}</span> and <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span>.</p>
<div id="prp-error" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 3 </strong></span>Under <a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-noise-spline">Definition&nbsp;3</a>, we have <span class="math display">\begin{align*}
\hat{\underline{\mu}}^{L, L^*}
&amp;\sim \mathcal{N}_L\left(\underline{\mu}^{L, L^*}, \frac{\sigma^2}N\Sigma_{B}^{L,L^\varepsilon}
\right),
\end{align*}</span> where the <span class="math inline">L\times L</span> covariance matrix <span class="math inline">\Sigma_{B}^{L,L^{\varepsilon}}</span> is defined as <span class="math inline">\Sigma_{B}^{L,L^\varepsilon}:=\mathbf{P}^L \Sigma^{L^\varepsilon} (\mathbf{P}^L)^T</span> with <span class="math inline">\Sigma^{L^\varepsilon}= \mathbf{B}^{L^\varepsilon} (\mathbf{B}^{L^\varepsilon})^T</span>.</p>
<p>Moreover, <span class="math inline">B^L()\mathbf{P}^L y_i</span> is a Gaussian process with mean <span class="math inline">\underline{f}^{L,L^*}()</span> and covariance function <span class="math inline">(s,t) \mapsto \sigma^2 B^L(s) \Sigma_{B}^{L,L^\varepsilon} (B^L(t))^T</span>, and <span class="math inline">(\underline{\hat{f}_{}}^{L,L^*}- \underline{f}^{L,L^*})()</span> is a centered Gaussian process with covariance function <span class="math inline">C^{L,L^*}: (s,t) \mapsto \frac{\sigma^2}N B^L(s) \Sigma_{B}^{L,L^\varepsilon} B^L(t)^T</span>.</p>
</div>
<p>The proof is given in Appendix.</p>
<p><a href="#fig-estimatorL">Figure&nbsp;3</a> displays estimators calculated with different dimensions <span class="math inline">L</span>. Data are generated with <span class="math inline">L^*=11</span>, <span class="math inline">L^\varepsilon=20</span>, <span class="math inline">n=50</span> and <span class="math inline">N=40</span>. The true function and its projection <span class="math inline">\underline f^{L,L^*}</span> are in cyan, and the estimator <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span> is in red. We compute it for the three families, Legendre, Fourier and splines. In all cases, the estimators are very precise when considering the relevant function, but estimating a function of dimension <span class="math inline">L^*</span> with a function of dimension <span class="math inline">L&lt;L^*</span> is not consistent. Note that the performance of the estimator for the spline family is also good, even if the family is not orthonormal, because we work here at the level of the function (and not at the level of the coefficients).</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>estimator <span class="ot">=</span> <span class="cf">function</span>(data, basis, L){</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="do">### Data projection</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  Hi <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>y</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  mu.hat <span class="ot">=</span> <span class="fu">rowMeans</span>(Hi)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  f.hat <span class="ot">=</span> <span class="fu">c</span>(B <span class="sc">%*%</span> mu.hat)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> data</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  data.proj<span class="sc">$</span>y <span class="ot">=</span> B <span class="sc">%*%</span> Hi</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  cov.emp <span class="ot">=</span> <span class="fu">crossprod</span>(<span class="fu">t</span>(data.proj<span class="sc">$</span>y <span class="sc">-</span> f.hat)) <span class="sc">/</span> <span class="fu">ncol</span>(data.proj<span class="sc">$</span>y)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat=</span>f.hat, <span class="at">mu.hat =</span> mu.hat, <span class="at">cov.emp =</span> cov.emp, <span class="at">data.proj =</span> data.proj))</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L=</span><span class="dv">5</span>, basis)</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>f.true.L5 <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">5</span>)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>est11 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">11</span>)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>dfLegendre <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,<span class="dv">4</span>),</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">4</span><span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>                         <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>f.true, <span class="fu">c</span>(f.true.L5), est5<span class="sc">$</span>f.hat, est11<span class="sc">$</span>f.hat),</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>                         <span class="at">L =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L = 11"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 11"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>                         <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"True"</span>, <span class="st">"True"</span>, <span class="st">"Estimated"</span>, <span class="st">"Estimated"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)))</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Fourier"</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L=</span><span class="dv">5</span>, basis)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>f.true.L5 <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">5</span>)</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>est11 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">11</span>)</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>dfFourier <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,<span class="dv">4</span>),</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">4</span><span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>f.true, <span class="fu">c</span>(f.true.L5), est5<span class="sc">$</span>f.hat, est11<span class="sc">$</span>f.hat),</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>                        <span class="at">L =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L = 11"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 11"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"True"</span>, <span class="st">"True"</span>, <span class="st">"Estimated"</span>, <span class="st">"Estimated"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)))</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L=</span><span class="dv">5</span>, basis)</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>f.true.L5 <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">5</span>)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>est11 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">11</span>)</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>dfSplines <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,<span class="dv">4</span>),</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">4</span><span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>f.true, <span class="fu">c</span>(f.true.L5), est5<span class="sc">$</span>f.hat, est11<span class="sc">$</span>f.hat),</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>                        <span class="at">L =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L = 11"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 11"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"True"</span>, <span class="st">"True"</span>, <span class="st">"Estimated"</span>, <span class="st">"Estimated"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)))</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">rbind</span>(dfLegendre, dfFourier, dfSplines)</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> df, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">color =</span> type)) <span class="sc">+</span> </span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">linetype =</span> type), <span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(L<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-estimatorL" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-estimatorL-1.svg" style="height:50.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Illustrative example. For each family (Fourier which is orthogonal, Legendre which is orthonormal and the splines which are not orthogonal wrt the standard scalar product), we consider a function with true dimension 11 (top), and its projection on the space of dimension 5 (bottom), displayed in cyan. The estimators in dimensions 11 and 5 are displayed in red.</figcaption>
</figure>
</div>
</div>
</div>
<p>Even if the estimator <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span> is defined on the functional space associated to <span class="math inline">\mathbf{S}^L</span>, it can also be seen as an estimator of the function <span class="math inline">f^{ L^*}</span> which lies in the space <span class="math inline">\mathcal{S}^{L^*}</span>. In that case, the error includes a functional approximation term due to the approximation of <span class="math inline">f^{ L^*}</span> on the space <span class="math inline">\mathcal{S}^L</span>, which will be nonzero if <span class="math inline">L\neq L^*</span>. It corresponding to the bias of the estimator <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span>, i.e.&nbsp;the difference between its expectation and the true <span class="math inline">f^{ L^*}</span>. Indeed, recalling that <span class="math inline">f^{L^*} = \underline{f}^{L^*,L^*}</span>, the error of estimation can be decomposed into <span id="eq-decomposition"><span class="math display">
\underline{\hat{f}}^{L, L^*}(t) -f^{L^*}(t)
= \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t) + \underline{f}^{L, L^*}(t) - \underline{f}^{L^*,L^*}(t) =: Stat_{L,L^*}(t) + Bias_{L,L^*}(t),
\tag{2}</span></span></p>
<p>The first term <span class="math inline">Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)</span> is the (unrescaled) statistics of the model. The second term <span class="math inline">Bias_{L,L^*}(t) = \mathbb{E}(\underline{\hat{f}}^{L, L^*}(t)) - \underline{f}^{L^*,L^*}(t)</span> is the bias of the estimator <span class="math inline">\underline{\hat{f}}^{L, L^*}(t)</span> when estimating the true function <span class="math inline">\underline{f}^{L^*,L^*}(t)</span>.</p>
<p>Let us remark that this bias is different than the bias of the estimator <span class="math inline">\underline{\hat{f}}^{L, L^*}(t)</span> when estimating the projected function <span class="math inline">\underline{f}^{L,L^*}=f^{ L^*}</span>, which is 0.</p>
<p>The two terms defined in <a href="#eq-decomposition">Equation&nbsp;2</a> are more detailed in the two next subsections.</p>
</section>
<section id="statistics" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="statistics"><span class="header-section-number">2.3.2</span> Statistics</h3>
<p>The statistics of the model, <span class="math inline">t\mapsto Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)</span>, is a random functional quantity which depends on the estimator <span class="math inline">\underline{\hat{f}}^{L, L^*}</span>. From <a href="#prp-error">Proposition&nbsp;3</a>, for any <span class="math inline">t\in [0,1]</span>, we define the centered and rescale statistics <span class="math inline">Z_L(t)</span> such that: <span class="math display">Z_L(t):= \frac{Stat_{L,L^*}(t)}{\sqrt{\text{Var}(Stat_{L,L^*}(t))}}
= \frac{\underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)}{\sqrt{C^{L, L^*}(t,t)}}\sim \mathcal{N}(0,1). </span></p>
<p>The covariance function can be estimated using the observations <span class="math inline">y_{i.}</span> as <span class="math display">\hat C^{L, L^*}(s,t) = \frac1{N-1}\sum_{i=1}^{N} (B^L(s)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(s))(B^L(t)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(t)).</span></p>
</section>
<section id="bias" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="bias"><span class="header-section-number">2.3.3</span> Bias</h3>
<p>The bias is due to the fact that the estimation is potentially performed in a different (finite) space than the space where the true function <span class="math inline">\underline{f}^{L^*,L^*}</span> lives. This is a functional bias, which is not random. It corresponds to the approximation (orthogonal projection if <a href="#def-ass-orth">Definition&nbsp;2</a> holds) of <span class="math inline">f^{L^*}</span> from <span class="math inline">\mathcal{S}^{L^*}</span> to the space <span class="math inline">\mathcal{S}^{L}</span>. It can be written as follows: <span class="math display">Bias_{L,L^*}(t) = B^L(t) \underline{\mu} ^{L,L^*} - B^{L^*}(t) \mu^{L^*}.</span> Thus, we can deduce that when <span class="math inline">L&lt;L^*</span> and if the family is orthonormal (<a href="#def-ass-orth">Definition&nbsp;2</a> holds), <span class="math display">Bias_{L,L^*}(t)= \sum_{\ell=1}^L B_\ell^L(t)\underline{\mu}_\ell^{L,L^*} - \sum_{\ell=1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*} = \sum_{\ell = L+1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*}.</span></p>
<p>From <a href="#prp-error">Proposition&nbsp;3</a>, we can directly deduce the following proposition:</p>
<div id="prp-bias" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 4 </strong></span>Under <a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-noise-spline">Definition&nbsp;3</a>, the mean is, for all <span class="math inline">t\in [0,1]</span>,</p>
<ul>
<li>for <span class="math inline">L&lt;L^*</span>, <span class="math inline">Bias_{L,L^*}(t)\neq 0</span>,</li>
<li>for <span class="math inline">L\geq L^*</span>, <span class="math inline">Bias_{L,L^*}(t) = 0</span>.</li>
</ul>
</div>
<p>In the next section, we explain how to use this property to derive confidence bands of <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span>.</p>
</section>
</section>
</section>
<section id="sec-bandSun" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Confidence Bands of <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span> for a fixed <span class="math inline">L</span></h1>
<p>The objective is to construct a confidence band for the two functions <span class="math inline">\underline{f}^{L, L^*}</span> and <span class="math inline">f^{L, L^*}</span>, based on the observations <span class="math inline">\mathbf{y}</span>, for a given value <span class="math inline">L\in \{L_{\min}, \ldots, L_{\max}\}</span>. The band for <span class="math inline">\underline{f}^{L, L^*}</span> enters the framework proposed by <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> which relies on an unbiased and linear estimator of the function. This is the case for the estimator <span class="math inline">\underline{\hat f}^{L, L^*}</span> which is an unbiased estimator of <span class="math inline">\underline{f}^{L, L^*}</span>. We recall in <a href="#sec-bandSun2">Section&nbsp;3.1</a> the construction of this confidence band which attains a given confidence level in a non-asymptotic setting, that is for a finite number of observations <span class="math inline">n</span> for each individual. Then in <a href="#sec-bandfLLstar">Section&nbsp;3.2</a>, we prove that the confidence band proposed by <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> can be viewed as a confidence band for <span class="math inline">f^{L, L^*}</span> with an asymptotic confidence level, the asymptotic framework being considered when <span class="math inline">n\rightarrow\infty</span>.</p>
<section id="sec-bandSun2" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-bandSun2"><span class="header-section-number">3.1</span> Confidence band for <span class="math inline">\underline{f}^{L,L^*}</span></h2>
<p>Let <span class="math inline">L\in \{1, \ldots, L_{\max}\}</span>. Consider <span class="math inline">1-\alpha</span> as a fixed confidence level. Our aim is to find a function <span class="math inline">d^L()</span> such that <span class="math display">\mathbb{P}\left( \forall t \in [0,1],\; \underline{\hat{f}_{}}^{L,L^*}(t) -d^L(t)\leq \underline{f}^{L,L^*}(t)\leq \underline{\hat{f}_{}}^{L,L^*}(t) +d^L(t)\right) = 1-\alpha.</span> Consider the normalized statistics <span class="math inline">Z_L(t)</span> which is a centered and reduced Gaussian process. We want to find the quantile <span class="math inline">q^L</span> satisfying</p>
<p><span id="eq-qL"><span class="math display">q^L =\arg\min_{q} \left\{ \mathbb{P}\left(\max_{t \in [0,1]} \left|Z_L(t)\right| \leq q \right) = 1 - \alpha\right\}. \tag{3}</span></span></p>
<p>Then we can take <span class="math inline">d^L(t) = q^L \sqrt{C^{L, L^*}(t,t)}</span>. The covariance function <span class="math inline">C^{L, L^*}(t,t)</span> can be replaced by its estimator <span class="math inline">\hat{C}^{L,L^*}(t,t)</span>, making the distribution a Student’s distribution with <span class="math inline">N-1</span> degrees of freedom. Thus, it only requires to be able to compute the critical value <span class="math inline">q^L</span>.</p>
<p>This can be done following <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span> who propose a confidence band for a centered Gaussian process. Their procedure is based on an unbiased linear estimator of the function of interest, which is the case for <span class="math inline">\underline{\hat{f}_{}}^{L,L^*}</span> when we consider a band for <span class="math inline">\underline{f}^{L,L^*}</span>. We recall their result in the following proposition, the computation of the value <span class="math inline">q^L</span> is detailed thereafter.</p>
<div id="thm-sunLoader" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1 (<span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span>) </strong></span>Set <a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-noise-spline">Definition&nbsp;3</a> and a probability <span class="math inline">\alpha\in [0,1]</span>. Then, we have <span class="math display">\mathbb{P}\left(\forall t \in [0,1], \left|\underline{\hat{f}}^{L, L^*}(t)-\underline{f}^{L,L^*}(t)\right| \leq \hat d^L(t)\right) = 1- \alpha</span> with <span class="math display">\begin{align*}
\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N};
\end{align*}</span> and <span class="math inline">\hat q^L</span> defined as the solution of the following equation, seen as a function of <span class="math inline">q^L</span>: <span id="eq-cL"><span class="math display">
\alpha = \mathbb{P}(|t_{N-1}|&gt;q^L) +\frac{\| \tau^L\|_1}{\pi}\left( 1+\frac{(q^L)^2}{N-1}\right)^{-(N-1)/2} ,
\tag{4}</span></span> with <span class="math inline">(\tau^L)^2(t)= \partial_{12} c(t,t) = Var(Z_L(t))'</span> where we denote <span class="math inline">\partial_{12}c(t,t)</span> the partial derivatives of a function <span class="math inline">c(t,s)</span> in the first and second coordinates and then evaluated at <span class="math inline">t=s</span>.</p>
</div>
<p>We can thus deduce a confidence band of level <span class="math inline">1-\alpha</span> for <span class="math inline">\underline{f}^{L,L^*}</span>: <span class="math display">\begin{align*}
CB_1(\underline{f}^{L,L^*})&amp; = \{ \forall t\in [0,1], [\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) ]\}.
\end{align*}</span></p>
<p></p>
<p>The value <span class="math inline">\hat q^L</span> is defined implicitly in <a href="#eq-cL">Equation&nbsp;4</a> which involves the quantity <span class="math inline">t\mapsto \tau^L(t)</span>. <span class="citation" data-cites="Liebl2019">Liebl and Reimherr (<a href="#ref-Liebl2019" role="doc-biblioref">2019</a>)</span> propose to estimate <span class="math inline">\tau^L(t)</span>, for all <span class="math inline">t</span>, by <span class="math display">\begin{align*}
\hat \tau^L(t) &amp;= \left(\widehat{Var}(({U}^{L})'_{1}(t), \ldots, ({U}^{L})'_{N}(t)\right)^{1/2}\\
&amp;= \left(\frac{1}{N-1}\sum_{i=1}^N\left(({U}^{L})'_{i}(t)-\frac1N\sum_{j=1}^N({U}^{L})'_{j}(t)\right)^2\right)^{1/2},
\end{align*}</span> where <span class="math inline">{U}^L_{i}(t) = (P^L y_i(t)-\underline{\hat{f}}^{L, L^*}(t))/(\hat C^{L,L^*}(t))^{1/2}</span> and <span class="math inline">({U}^{L})'_{i}</span> is a smooth version of the differentiated function <span class="math inline">{U}^L_{i}</span>. Then we take the <span class="math inline">L_1</span>-norm of <span class="math inline">\hat \tau^L</span>.</p>
<p>Let us describe the behavior of <span class="math inline">\hat d^L</span>:</p>
<ul>
<li><span class="math inline">\|\hat d^L\|_\infty</span> increases with <span class="math inline">L</span></li>
<li>When the functions <span class="math inline">(B_\ell^L)_{1\leq \ell \leq L}</span> consists in an orthonormal family, <span class="math inline">\|\hat d^L\|_\infty</span> increases with <span class="math inline">L</span> until <span class="math inline">L=L^*</span> and then <span class="math inline">\|\hat d^L\|_\infty</span> is constant with <span class="math inline">L</span>.</li>
</ul>
<p>This band is illustrated on <a href="#fig-bandL">Figure&nbsp;4</a>. It displays on the top row several functional data generated under either the Fourier family (left), Legendre (middle) or Spline (right), on the middle row the confidence bands of <span class="math inline">\underline f^{L,L^*}</span> for different values of <span class="math inline">L=3,5</span> and <span class="math inline">11</span>, and on the bottom row the bound <span class="math inline">\hat d^L</span>. The true functions <span class="math inline">\underline f^{L,L^*}</span> are displayed in cyan and the confidence bands in purple. The bands are very precise for each <span class="math inline">L</span>. The behavior of <span class="math inline">\hat d^L</span> increases with <span class="math inline">L</span>. As <span class="math inline">d^L</span> can be seen as a variance, <span class="math inline">\hat d^L(t)</span> is larger on the boundary of the domain, as there are less observations near 0 and 1.</p>
<p>We also evaluate numerically the levels of the obtained confidence bands. For this, 1000 datasets are simulated, the confidence band is estimated for each of them. The empirical confidence level is then evaluated as the proportion of confidence bands that contain the true function. <a href="#tbl-levelL">Table&nbsp;1</a> presents the empirical confidence levels for different values of <span class="math inline">L</span> and two sample sizes <span class="math inline">n=50</span> and <span class="math inline">n=150</span>, with <span class="math inline">N=40</span>. The level is the expected one whatever the value of <span class="math inline">L</span>, especially when <span class="math inline">L&lt;L^*</span> and <span class="math inline">L&gt;L^*</span> but also when <span class="math inline">L&gt;L^\varepsilon</span>. We will see in the next sections that this will not be the case for the debiased confidence band.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>compute.c.L <span class="ot">=</span> <span class="cf">function</span>(data.scl, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data.scl: the rescaled data </span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  x_approx <span class="ot">=</span> <span class="fu">apply</span>(data.scl<span class="sc">$</span>y, <span class="dv">2</span>,<span class="at">FUN=</span><span class="cf">function</span>(yy){</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    fn <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">splinefun</span>(<span class="at">x =</span> data.scl<span class="sc">$</span>time, <span class="at">y =</span> yy, <span class="at">method =</span> <span class="st">"natural"</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    pracma<span class="sc">::</span><span class="fu">fderiv</span>(<span class="at">f =</span> fn, <span class="at">x =</span> data.scl<span class="sc">$</span>time, <span class="at">n =</span> <span class="dv">1</span>, <span class="at">h =</span> <span class="fl">1e-6</span>, <span class="at">method =</span> <span class="st">"central"</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="fu">ncol</span>(data.scl<span class="sc">$</span>y)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  hat.tau <span class="ot">=</span> <span class="fu">apply</span>(x_approx, <span class="dv">1</span>, stats<span class="sc">::</span>sd) </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  hat.tau[<span class="fu">which</span>(<span class="fu">is.na</span>(hat.tau))] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  tau_01     <span class="ot">=</span> (hat.tau)[<span class="sc">-</span><span class="dv">1</span>]<span class="sc">%*%</span><span class="fu">diff</span>(data.scl<span class="sc">$</span>time)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  myfun      <span class="ot">=</span> <span class="cf">function</span>(c){stats<span class="sc">::</span><span class="fu">pt</span>(c, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>, <span class="at">df =</span> N<span class="dv">-1</span>) <span class="sc">+</span> tau_01 <span class="sc">*</span> </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span> <span class="sc">+</span> c<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>(N<span class="dv">-1</span>))<span class="sc">^</span>(<span class="sc">-</span>(N<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>)<span class="sc">/</span>(<span class="dv">2</span> <span class="sc">*</span> pi) <span class="sc">-</span> alpha<span class="sc">/</span><span class="dv">2</span>}</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  c.L       <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">uniroot</span>(<span class="at">f =</span> myfun,<span class="at">interval =</span> <span class="fu">c</span>(.<span class="dv">5</span>,<span class="dv">8</span>))<span class="sc">$</span>root</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(c.L)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>  est <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est<span class="sc">$</span>data.proj</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est<span class="sc">$</span>cov.emp))</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est<span class="sc">$</span>f.hat <span class="sc">+</span> d.L</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est<span class="sc">$</span>f.hat <span class="sc">-</span> d.L</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">d.L =</span> d.L, <span class="at">c.L =</span> c.L))</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>d.L.Lmax <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax=</span><span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, alpha)</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(c.L.Lmax<span class="fl">.2</span>)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>dfObs <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                   <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                   <span class="at">ind =</span> <span class="fu">integer</span>())</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>dfTrue <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                    <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                    <span class="at">f =</span> <span class="fu">double</span>())</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>dfTrueProjected <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                             <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                             <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                             <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>dfBand <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                     <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                     <span class="at">flow =</span> <span class="fu">double</span>(),</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                     <span class="at">fup =</span> <span class="fu">double</span>(),</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                     <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>dfdL <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                   <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>                   <span class="at">dL =</span> <span class="fu">double</span>(),</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>                   <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="dv">40</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span>N,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>  dfObs <span class="ot">=</span> <span class="fu">rbind</span>(dfObs,<span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time, N),</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(<span class="fu">c</span>(data<span class="sc">$</span>y))),</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y),</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>N, <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>  dfTrue <span class="ot">=</span> <span class="fu">rbind</span>(dfTrue,<span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">f =</span> data<span class="sc">$</span>f.true))</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    conf.band <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    dfBand <span class="ot">=</span> <span class="fu">rbind</span>(dfBand, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">flow =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>f.hat.low), </span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">fup =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>f.hat.up), </span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    dfTrueProjected <span class="ot">=</span> <span class="fu">rbind</span>(dfTrueProjected, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">f =</span> <span class="fu">c</span>(f.true.L), </span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">dimension =</span> <span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    dfdL <span class="ot">=</span> <span class="fu">rbind</span>(dfdL, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dL =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>d.L),</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L,<span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfObs, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">group =</span> ind), <span class="at">linewidth =</span> <span class="fl">0.1</span>, <span class="at">color =</span> <span class="st">"grey"</span>) <span class="sc">+</span></span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrue, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f), <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span> </span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBand, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> flow, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBand, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> fup, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.8</span>) <span class="sc">+</span> </span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrueProjected, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">group =</span> dimension), <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">linewidth =</span> <span class="fl">0.2</span>)<span class="sc">+</span> </span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"confidence band"</span>)</span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdL, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dL, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension)) <span class="sc">+</span></span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a><span class="fu">ggarrange</span>(p1, p2, p3, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">common.legend =</span> <span class="cn">TRUE</span>, <span class="at">legend =</span> <span class="st">"bottom"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-bandL" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-bandL-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Illustrative example. For the three families, resp. Fourier, Legendre and the splines, we display on the top row the observed functional data, on the middle row the confidence bands for different values of L (3, 5 and 11), and on the bottom row the bound dL.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> <span class="fu">max</span>(vec.L), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>      cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">set.seed</span>(rep)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">basis =</span> basis)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        conf.band <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L, basis)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true.L<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true.L<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span>} </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>      perf[L,ind.n] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> perf[vec.L,]</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(perf) <span class="ot">=</span> vec.L</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(perf) <span class="ot">=</span> vec.n</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"res_Tab1.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(perf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="tbl-levelL" class="anchored">
<table class="table table-sm table-striped small">
<caption>Table&nbsp;1: Illustrative example. The confidence level of the confidence band is evaluated from 1000 repetitions. Confidence bands are calculated with the Legendre family, for several L in rows and several n in columns.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">50</th>
<th style="text-align: right;">150</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: right;">0.972</td>
<td style="text-align: right;">0.957</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: right;">0.950</td>
<td style="text-align: right;">0.950</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: right;">0.944</td>
<td style="text-align: right;">0.952</td>
</tr>
<tr class="even">
<td style="text-align: left;">15</td>
<td style="text-align: right;">0.968</td>
<td style="text-align: right;">0.945</td>
</tr>
<tr class="odd">
<td style="text-align: left;">21</td>
<td style="text-align: right;">0.938</td>
<td style="text-align: right;">0.943</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
<section id="sec-bandfLLstar" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-bandfLLstar"><span class="header-section-number">3.2</span> Asymptotic confidence band for <span class="math inline">f^{L,L^*}</span></h2>
<p>Note that if one works in the asymptotic framework <span class="math inline">n\rightarrow\infty</span>, the previous definition of <span class="math inline">\hat d^L</span> induces a natural asymptotic confidence band for the function <span class="math inline">f^{L,L^*}</span>. Indeed, we can prove that</p>
<div id="thm-CB_Liebl_asymptotic" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2 </strong></span>Set <a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-noise-spline">Definition&nbsp;3</a> and a probability <span class="math inline">\alpha\in [0,1]</span>. Then, we have, <span class="math display">\lim_{n \rightarrow +\infty} \mathbb{P}\left(\forall t \in [0,1], |\underline{\hat{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)\right) = 1-\alpha,</span> with <span class="math inline">\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N}</span> and <span class="math inline">\hat q^L</span> defined as the solution of <a href="#eq-cL">Equation&nbsp;4</a>.</p>
</div>
<p>The proof is given in Appendix.</p>
<p>Then a confidence band for <span class="math inline">f^{L,L^*}</span> at the asymptotic confidence level <span class="math inline">1-\alpha</span> for a large number of observations <span class="math inline">n</span> is given by <span class="math display">\begin{align*}
CB(f^{L,L^*})&amp; = \{ \forall t\in [0,1], [\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) ]\}.
\end{align*}</span></p>
<p>We do not provide any illustration of this property, as it would be similar than the previous ones. Indeed, we notice that the asymptotic is achieved even when <span class="math inline">n</span> is small on our examples.</p>
</section>
</section>
<section id="sec-band2" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Confidence Band of <span class="math inline">f^{L^*}</span> by correcting the bias</h1>
<p>The function of interest is <span class="math inline">f^{L^*}=\underline{f}^{L^*, L^*}</span>, rather than <span class="math inline">\underline{f}^{L,L^*}</span>. Therefore, our aim is to construct a confidence bound for <span class="math inline">f^{L^*}</span>. However, an unbiased estimator of <span class="math inline">f^{L^*}</span> is unavailable by definition, since the true dimension <span class="math inline">L^*</span> is unknown. Instead, we propose to work with the estimator <span class="math inline">\underline{\hat f}^{L,L^*}</span> and to debias the corresponding confidence band.</p>
<p>To achieve this, we use the decomposition outlined in <a href="#eq-decomposition">Equation&nbsp;2</a> between the bias term and the statistical term. The idea is to bound the infinity norm of these two terms. A first strategy consists in bounding each term separately and then summing the two bounds to construct the confidence band. However, this approach tends to produce a band that is too large and conservative. The reason is that applying the infinite norms on each term before bounding them does not take into account the functional nature of the two terms. This approach is presented in details in Appendix.</p>
<p>A second strategy consists in keeping the functional aspect by bounding the infinity norm of the sum of the functional two terms. This approach is detailed in this section.</p>
<p>In <a href="#sec-construction2">Section&nbsp;4.1</a>, we first rewrite the band as a band around <span class="math inline">\underline{f}^{L,L^*}(t)</span>. We then use a first subsample <span class="math inline">\mathbf{y}^1</span> to estimate the bound as defined in <a href="#sec-bandSun">Section&nbsp;3</a>. A second subsample <span class="math inline">\mathbf{y}^2</span> is used to estimate the bias term (without the infinite norm). This yields a pointwise correction of the bias, and the final confidence band is centered around <span class="math inline">\underline{\hat{f}}^{L_{\max},L^*}</span>. This procedure provides a collection of confidence bands, for <span class="math inline">L=L_{\min}, \ldots, L_{\max}</span>, each achieving a given confidence level but with varying width. Then, in <a href="#sec-SelectionL2">Section&nbsp;4.2</a>, we propose a criterion to select the “best” band by minimizing its width.</p>
<section id="sec-construction2" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sec-construction2"><span class="header-section-number">4.1</span> Construction of the band of <span class="math inline">f^{L^*}</span> for a given <span class="math inline">L</span></h2>
<p>We introduce two independent sub-samples <span class="math inline">\mathbf{y}^1</span> and <span class="math inline">\mathbf{y}^2</span> of <span class="math inline">\mathbf{y}</span> of length <span class="math inline">n_1</span> and <span class="math inline">n_2</span> such that <span class="math inline">n_1+n_2=n</span>. </p>
<p>We use the first sub-sample <span class="math inline">\mathbf{y}^1</span> to calculate <span class="math inline">\underline{\hat{f}_1}^{L,L^*}(t)</span>, an estimator of <span class="math inline">\underline{f}^{L,L^*}(t)</span> and a functional bound denoted <span class="math inline">\hat d_1^L</span> that controls the bias term <span class="math inline">\underline{f}^{L,L^*}(t)-\underline{\hat{f}_1}^{L,L^*}(t)</span>. This bound is defined in <a href="#sec-bandSun">Section&nbsp;3</a> applied on <span class="math inline">\mathbf{y}^1</span>, for a given level <span class="math inline">\alpha</span>, such that:</p>
<p><span id="eq-def-dL1"><span class="math display">
\mathbb{P}\left(\forall t\in[0,1], -\hat d_1^L(t) \leq \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t) \leq \hat d_1^L(t)\right) = 1-\alpha.
\tag{5}</span></span></p>
<p>Then, we need to control the bias <span class="math inline">Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t)-f^{L^*}(t)</span>. Recall than when <span class="math inline">L_{\max}</span> is large enough and <span class="math inline">n&gt; L_{\max}</span>, <span class="math inline">f^{L^*} = \underline{f}^{L_{\max},L^*}</span>. Therefore, we want to control the <span class="math inline">Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}(t)</span>. It would be tempting to replace <span class="math inline">Bias_{L,L^*}(t)</span> by its estimation based on the second sample <span class="math inline">\mathbf{y}^2</span>. But this would introduce an estimation error that we also need to control, in the same spirit than what is done in <span class="citation" data-cites="PCO">(<a href="#ref-PCO" role="doc-biblioref"><strong>PCO?</strong></a>)</span>. We can use again <a href="#sec-bandSun">Section&nbsp;3</a> to compute the function <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> on the sample <span class="math inline">\mathbf{y}^2</span>, and the functional estimators <span class="math inline">\underline{\hat{f}}_2^{L,L^*}(t)</span> and <span class="math inline">\underline{\hat f}_2^{L_{\max}, L^*}(t)</span> of <span class="math inline">\underline{f}^{L,L^*}(t)</span> and <span class="math inline">\underline{ f}^{L_{\max}, L^*}(t)</span>, respectively. This allows to construct the following band for <span class="math inline">\underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}</span> for a confidence level <span class="math inline">1-\beta</span>,</p>
<p><span id="eq-def-dL2"><span class="math display">
\mathbb{P}\left(\forall t\in[0,1], - \hat d_2^{L,L_{\max}}(t) \leq \underline{ f}^{L_{\max}, L^*}(t)- \underline{ f}^{L, L^*}(t) - (\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t)) \leq \hat d_2^{L,L_{\max}}(t)\right) = 1-\beta.
\tag{6}</span></span></p>
<p>Combining <a href="#eq-def-dL1">Equation&nbsp;5</a> and <a href="#eq-def-dL2">Equation&nbsp;6</a>, we can provide a debiased confidence band of <span class="math inline">f^{L^*}(t)</span>.</p>
<div id="prp-CBf" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 5 </strong></span>Let us define <span class="math display">\begin{align*}
\hat\theta_1^L(t) &amp;:= -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t) \\
\hat\theta_2^L(t)&amp;:= \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t) - \underline{\hat f}_2^{L, L^*}(t),
\end{align*}</span> where <span class="math inline">\hat d_1^L(t)</span> is defined on sample <span class="math inline">\mathbf{y}^1</span> by <a href="#eq-def-dL1">Equation&nbsp;5</a> for a level <span class="math inline">\alpha</span> and <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> is defined on sample <span class="math inline">\mathbf{y}^2</span> by <a href="#eq-def-dL2">Equation&nbsp;6</a> for a level <span class="math inline">\beta</span>. Then we have <span class="math display">\begin{align*}
\mathbb{P}\left(\forall t \in [0,1], \quad \hat \theta_1^L(t) \leq f^{L^*}(t)- \underline{\hat f}_1^{L, L^*}(t)\leq \hat\theta_2^L(t)\right)\geq 1-\alpha\beta.
\end{align*}</span></p>
</div>
<p>The proof is given in Appendix.</p>
<p>This defines a confidence band which can be defined either around <span class="math inline">\underline{\hat{f}_{1}}^{L,L^*}</span>: <span class="math display">\begin{align*}
CB_2(\underline{f}^{L^*})=\{\forall t\in[0,1], [\underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_1^{ L}(t) \, ;\, \underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_2^{ L}(t) ] \}
\end{align*}</span> or around <span class="math inline">\underline{\hat f}_2^{ L_{\max}, L^*}</span>: <span class="math display">\begin{align*}
CB_2(\underline{f}^{L^*})=\{\forall t\in[0,1], [\underline{\hat f}_2^{ L_{\max}, L^*}(t) + \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f}_2^{ L, L^*}(t) -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t) \, ;\, \underline{\hat f}_2^{ L_{\max}, L^*}(t) + \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f}_2^{ L, L^*}(t) + \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)]\}.
\end{align*}</span></p>
<div id="rem-dLLmax">
<p>The two functions <span class="math inline">\hat d_1^L(t)</span> and <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> are of the same order as they are built with the same approach. They depend on the length of the samples. To obtain the thinnest band, the best strategy is to split the sample in two sub-samples of equal length <span class="math inline">n_1=n_2= n/2</span>.</p>
</div>
<p>The behavior of <span class="math inline">\hat d_1^L</span> has been described in <a href="#sec-bandSun">Section&nbsp;3</a>. Let us describe the behavior of <span class="math inline">\hat d_2^{L,L_{\max}}</span>:</p>
<ul>
<li><span class="math inline">\|\hat d_2^{L,L_{\max}}\|_\infty</span> decreases with <span class="math inline">L</span>.</li>
<li>When <span class="math inline">L&gt;L^\varepsilon</span>, <span class="math inline">\|\hat d_2^{L,L_{\max}}\|_\infty</span> is constant with <span class="math inline">L</span> and the probability in <a href="#eq-def-dL2">Equation&nbsp;6</a> is equal to <span class="math inline">1</span>.</li>
<li>When <span class="math inline">L^{*}&lt;L&lt;L^\varepsilon</span>, <span class="math inline">\|\hat d_2^{L,L_{\max}}\|_\infty</span> is constant with <span class="math inline">L</span> when the functions <span class="math inline">B_\ell^L</span> consists in an orthonormal family. Otherwise, the behavior is erratic.</li>
</ul>
<p>It means that when the band defined in <a href="#prp-CBf">Proposition&nbsp;5</a> is calculated for <span class="math inline">L&gt;L^\varepsilon</span>, the confidence level is <span class="math inline">1-\alpha</span> instead of <span class="math inline">1-\alpha\beta</span>.</p>
<p>The advantages of this approach is that the bias of the band is corrected and the level for the true function <span class="math inline">f^{L^*}</span> is guaranteed when <span class="math inline">L^\varepsilon</span> is large. This was the main objective of the paper.</p>
<p>We illustrate numerically those advantages. In <a href="#fig-Lstar">Figure&nbsp;5</a>, top row, we plot the confidence bands obtained for different dimensions <span class="math inline">L \in \{3,5,11,15,21\}</span> with Fourier, Legendre and Splines families and <span class="math inline">\alpha=\beta=\sqrt{0.05}\approx 0.22</span>. We can see that all the confidence bands are alike. Especially, they are unbiased, even for <span class="math inline">L=3</span>. A larger dimension <span class="math inline">L</span> provides a smoother band. On the middle and bottom rows of <a href="#fig-Lstar">Figure&nbsp;5</a>, we illustrate the two terms that enter the confidence band, <span class="math inline">t \mapsto \hat d_1^L(t)</span> and <span class="math inline">t\mapsto \hat d_2^{L,L_{\max}}(t)</span>. Their behavior is the same along time. The function <span class="math inline">\hat d_1^L(t)</span> can be seen as a variance, this is why it is larger near 0 and 1 where there are less observations. The function <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> is smaller than <span class="math inline">\hat d_1^L(t)</span> because it controls the remaining rest after the projection. Note that as expected when <span class="math inline">L&gt;L^\varepsilon</span>, <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> is close to 0. As explained before, the influence of <span class="math inline">L</span> is not the same for the two functions. When <span class="math inline">L</span> increases, <span class="math inline">\hat d_1^L(t)</span> increases while <span class="math inline">\hat d_2^{L,L_{\max}}(t)</span> decreases.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the time-points and the individual functions</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.1</span> <span class="ot">=</span> data<span class="fl">.2</span> <span class="ot">=</span> data</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  ind<span class="fl">.1</span> <span class="ot">=</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>], <span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.1</span><span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,ind<span class="fl">.1</span>]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.2</span><span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,<span class="sc">-</span>ind<span class="fl">.1</span>]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.1</span>, basis, L)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>scl <span class="ot">=</span> data.<span class="fl">1.</span>proj</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>scl<span class="sc">$</span>y <span class="ot">=</span> (data.<span class="fl">1.</span>proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  c.L<span class="fl">.1</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">1.</span>scl, alpha)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>  d.L<span class="fl">.1</span> <span class="ot">=</span> c.L<span class="fl">.1</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">1.</span>scl<span class="sc">$</span>y))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.2</span>, basis, L)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.2</span>, basis, Lmax)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L<span class="fl">.1</span> <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L<span class="fl">.1</span> <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">d.L =</span> d.L<span class="fl">.1</span>, <span class="at">d.L.Lmax =</span> d.L.Lmax<span class="fl">.2</span>))</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>dfTrue <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>                    <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>                    <span class="at">basis =</span> <span class="fu">character</span>()</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>dfBandup <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>                      <span class="at">bandup =</span> <span class="fu">double</span>(),</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>                      <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>dfBandlow <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>                       <span class="at">bandlow =</span> <span class="fu">double</span>(),</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>                       <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>                       <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>dfdL <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>                  <span class="at">dLLmax =</span> <span class="fu">double</span>(),</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>                  <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>                  <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>dfdLLmax <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dL =</span> <span class="fu">double</span>(),</span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>                      <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>)</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>  dfTrue <span class="ot">=</span> <span class="fu">rbind</span>(dfTrue, <span class="fu">data.frame</span>(<span class="at">Time =</span>  data<span class="sc">$</span>time,</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">f =</span> data<span class="sc">$</span>f.true,</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>  crit.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">nrow =</span> <span class="dv">30</span>)</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>    conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>    crit.sel[L,] <span class="ot">=</span><span class="fu">c</span>(<span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L), <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax),</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">sum</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L<span class="sc">+</span>conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax)))</span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>    dfBandup <span class="ot">=</span> <span class="fu">rbind</span>(dfBandup, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">bandup =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up),</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>    dfBandlow <span class="ot">=</span> <span class="fu">rbind</span>(dfBandlow, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">bandlow =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low),</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a>    dfdL <span class="ot">=</span> <span class="fu">rbind</span>(dfdL, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dL =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L),</span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>    dfdLLmax <span class="ot">=</span> <span class="fu">rbind</span>(dfdLLmax, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dLLmax =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax),</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrue, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f)) <span class="sc">+</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandup, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandup, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandlow, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandlow, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb7-99"><a href="#cb7-99" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span> basis)</span>
<span id="cb7-100"><a href="#cb7-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-101"><a href="#cb7-101" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb7-102"><a href="#cb7-102" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdL, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dL, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb7-103"><a href="#cb7-103" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>( <span class="sc">~</span> basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"d.L"</span>)</span>
<span id="cb7-104"><a href="#cb7-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-105"><a href="#cb7-105" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb7-106"><a href="#cb7-106" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdLLmax, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dLLmax, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb7-107"><a href="#cb7-107" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>( <span class="sc">~</span> basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"d.L.Lmax"</span>)</span>
<span id="cb7-108"><a href="#cb7-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-109"><a href="#cb7-109" aria-hidden="true" tabindex="-1"></a><span class="fu">ggarrange</span>(p1, p2, p3, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">common.legend =</span> <span class="cn">TRUE</span>, <span class="at">legend =</span> <span class="st">"bottom"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-Lstar" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-Lstar-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5: Illustrative example. For a given dataset, we plot several confidence bands (top row), functions dL (middle row) and dLLmax (bottom row). Bands and functions are estimated with Fourier (left column), Legendre (middle column) and Spline (right column) basis and several dimensions L (3, 5, 11, 15, 21).</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#tbl-levLstar">Table&nbsp;2</a>, we simulate 1000 repeated datasets with two sample sizes <span class="math inline">n=50</span> and <span class="math inline">n=150</span>. For each dataset, we compute the confidence band defined in <a href="#prp-CBf">Proposition&nbsp;5</a> with a theoretical confidence level of <span class="math inline">1-\alpha\beta=0.95</span> and for different values of <span class="math inline">L</span>. Then the confidence level is approximated as the proportion of confidence bands containing the true function <span class="math inline">f</span>. Remark that when <span class="math inline">L&lt;L^{\varepsilon}</span>, the level is the expected one, that is 0.95. When <span class="math inline">L&gt;L^{\varepsilon}</span>, the level is not more ensured, as explained before. Indeed the term <span class="math inline">d^{L,L^{\max}}</span> is mainly equal to 0, and the level is close to <span class="math inline">1-\alpha</span> instead of <span class="math inline">1-\alpha\beta</span>. This is not the case for the band in <a href="#sec-bandSun">Section&nbsp;3</a>, as this is due to the correction of the bias.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>)  </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> <span class="fu">max</span>(vec.L), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){<span class="fu">print</span>(L)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>      cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="fu">set.seed</span>(rep)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">basis =</span> <span class="st">"Legendre"</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.2</span>, <span class="at">beta=</span><span class="fl">0.2</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        f.true <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> data<span class="sc">$</span>f.true, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span>} </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>      perf[L,ind.n] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> perf[vec.L,]</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(perf) <span class="ot">=</span> vec.L</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(perf) <span class="ot">=</span> vec.n</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab2.RData"</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_Tab2.RData'</span>)}</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(perf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="tbl-levLstar" class="anchored">
<table class="table table-sm table-striped small">
<caption>Table&nbsp;2: Illustrative example. We display the level of confidence for the proposed confidence band, for several L in rows and several n in columns.</caption>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">50</th>
<th style="text-align: right;">150</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: right;">0.960</td>
<td style="text-align: right;">0.963</td>
</tr>
<tr class="even">
<td style="text-align: left;">5</td>
<td style="text-align: right;">0.969</td>
<td style="text-align: right;">0.970</td>
</tr>
<tr class="odd">
<td style="text-align: left;">11</td>
<td style="text-align: right;">0.961</td>
<td style="text-align: right;">0.970</td>
</tr>
<tr class="even">
<td style="text-align: left;">15</td>
<td style="text-align: right;">0.947</td>
<td style="text-align: right;">0.958</td>
</tr>
<tr class="odd">
<td style="text-align: left;">21</td>
<td style="text-align: right;">0.780</td>
<td style="text-align: right;">0.799</td>
</tr>
<tr class="even">
<td style="text-align: left;">25</td>
<td style="text-align: right;">0.803</td>
<td style="text-align: right;">0.787</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</section>
<section id="sec-SelectionL2" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sec-SelectionL2"><span class="header-section-number">4.2</span> Influence of <span class="math inline">L</span></h2>
<p>This approach gives a collection of confidence bands for different values of <span class="math inline">L</span>. The confidence bands have different widths for a same confidence level <span class="math inline">1-\alpha\beta</span>. It is thus natural to want to select one of them. This means we want to select the best dimension <span class="math inline">L</span> among the collection <span class="math inline">\{1, \ldots, L_{\max}\}</span>. We need to define what “best” means. It is quite intuitive to focus on the band that is the thinnest. Thinnest could be thought in different norms, the infinity norm, the L1 norm. Here we consider the infinity norm of the width of the confidence band, which gives a preference to smooth bands. We thus define the following criteria</p>
<p><span id="eq-def-Lhat"><span class="math display">
\hat L = \arg\min_L \left\{\sup_{t} |\hat\theta_2^L(t)-\hat\theta_1^L(t)|\right\} = \arg\min_L \left\{\sup_t | \hat d^L(t) + \hat d^{L,L_{\max}}(t)|\right\}.
\tag{7}</span></span></p>
<p>We illustrate the different terms involved in <a href="#eq-def-Lhat">Equation&nbsp;7</a>. In <a href="#fig-dLLmax">Figure&nbsp;6</a>, we plot for a given dataset, the infinity norm of the width of the band <span class="math inline">\hat d^L(t) + \hat d^{L,L_{\max}}(t)</span> (top), of <span class="math inline">\hat d^L(t)</span> (middle) and <span class="math inline">\hat d^{L,L_{\max}}(t)</span> (bottom) functions obtained with the Fourier (left column), Legendre (middle column) and Spline (right column) basis. As already said, <span class="math inline">\|\hat d^L\|_{\infty}</span> increases with <span class="math inline">L</span> while <span class="math inline">\|\hat d^{L,L_{\max}}\|_{\infty}</span> decreases (and is zero when <span class="math inline">L&gt;L\varepsilon</span>). The width of the band wrt <span class="math inline">L</span> does not have a <span class="math inline">U</span>-shape, as expected. It is thus difficult to minimize this criterion.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Norm =</span> <span class="fu">double</span>(),</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">type =</span> <span class="fu">character</span>(),</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">dimension =</span> <span class="fu">integer</span>()</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> d.L <span class="ot">=</span> d.L.Lmax <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, basis, L, <span class="at">Lmax =</span> L.max, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up)))</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    d.L <span class="ot">=</span> <span class="fu">c</span>(d.L, <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L))</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    d.L.Lmax <span class="ot">=</span> <span class="fu">c</span>(d.L.Lmax, <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax))</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">=</span> <span class="fu">rbind</span>(df, <span class="fu">data.frame</span> (<span class="at">Norm =</span> <span class="fu">c</span>(length.band, d.L, d.L.Lmax),</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>                             <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Band width norm"</span>, <span class="st">"d.L norm"</span>, <span class="st">"d.L.Lmax norm"</span>), <span class="at">each =</span> <span class="fu">length</span>(vec.L)),</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>                             <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">3</span><span class="sc">*</span> <span class="fu">length</span>(vec.L)),</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>                             <span class="at">dimension =</span> <span class="fu">rep</span>(vec.L, <span class="dv">3</span>)))</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Norm, <span class="at">fill =</span> type)) <span class="sc">+</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span> </span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(type <span class="sc">~</span> basis, <span class="at">scale =</span> <span class="st">'free'</span>) <span class="sc">+</span> <span class="fu">xlab</span>(<span class="st">"L"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-dLLmax" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-dLLmax-1.svg" style="height:50.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;6: Illustrative example. For a given dataset, we calculate the norm of the width of the confidence band (top), of the dL function (middle) and the dLLmax function (bottom), for several dimensions L and for Fourier (left column), Legendre (middle column) and Splines (right column) basis.</figcaption>
</figure>
</div>
</div>
</div>
<p>We then evaluate the performance of the selection criteria. To do that, we simulate 100 repeated datasets. Confidence bands and the norm of their widths are computed for several <span class="math inline">L</span>. We apply the selection criteria and plot the distribution of the estimated dimension <span class="math inline">\hat L</span> in <a href="#fig-modelsel">Figure&nbsp;7</a>, for the three basis families. The estimated dimension is almost always larger than the true <span class="math inline">L^*=11</span>. Being larger is not a problem and the selected band is unbiased and has the correct level as soon as <span class="math inline">L^\varepsilon</span> is large, which was the objective. However, the criteria has the tendency to select a (too) smooth band. It is not satisfactory not to be able to select the true dimension. This is why we propose a new approach in <a href="#sec-modsel">Section&nbsp;5</a>. In <a href="#sec-comparisonBands">Section&nbsp;4.3</a>, we also illustrate that this band is too conservative .</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  repet <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  dfBandWidth <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">double</span>(),</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                           <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                           <span class="at">dimension =</span> <span class="fu">integer</span>()</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  dfLhat <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Lhat =</span> <span class="fu">double</span>(), <span class="at">L =</span> <span class="fu">integer</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    mod.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> repet, <span class="at">ncol =</span> <span class="dv">4</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    Lmax <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>repet){</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">set.seed</span>(rep)</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>, <span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      length.band <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, <span class="at">basis =</span> basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up<span class="sc">-</span>conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low)))</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">min</span>(length.band), vec.L[<span class="fu">which.min</span>(length.band)])</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>      conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> Lmax, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">3</span>] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.max<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L.max<span class="sc">$</span>f.hat.up))</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>      conf.band.L.star <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> <span class="dv">10</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">4</span>] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.star<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L.star<span class="sc">$</span>f.hat.up))</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">c</span>(mod.sel[ ,<span class="dv">1</span>], mod.sel[ ,<span class="dv">3</span>], mod.sel[ ,<span class="dv">4</span>]),</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis, repet<span class="sc">*</span><span class="dv">3</span>),</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Lhat"</span>, <span class="st">"Lmax"</span>, <span class="st">"Lstar"</span>), <span class="at">each =</span> repet)))  </span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    dfLhat <span class="ot">=</span> <span class="fu">rbind</span>(dfLhat, <span class="fu">data.frame</span>(</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>      <span class="at">L =</span> vec.L,</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel[,<span class="dv">2</span>], <span class="at">levels =</span> vec.L))),</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab3_n50_3basisBandWidth.RData"</span>)</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfLhat, <span class="at">file =</span> <span class="st">"Res_Tab3_n50_3basisLhat.RData"</span>)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisBandWidth.RData'</span>)</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisLhat.RData'</span>)}</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> dfLhat, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat)) <span class="sc">+</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-modelsel" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-modelsel-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;7: Illustrative example. From 100 datasets, we calculate the distribution of the estimated dimension L. The true dimension is <span class="math inline">L^* = 11</span>.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-comparisonBands" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="sec-comparisonBands"><span class="header-section-number">4.3</span> Comparison with the confidence bands of <a href="#sec-bandSun">Section&nbsp;3</a></h2>
<p>The reformulation of the band around <span class="math inline">\underline{\hat f}_2^{ L_{\max}, L^*}</span> is close to the band presented in <a href="#sec-bandSun">Section&nbsp;3</a> for <span class="math inline">L=L_{\max}</span>, that is a band centered around <span class="math inline">\underline{\hat f}^{ L_{\max}, L^*}</span>. A natural question is to understand what is the gain by doing so instead of using the band from <a href="#sec-bandSun">Section&nbsp;3</a> with <span class="math inline">L=L_{\max}</span>, namely the band <span class="math inline">[\underline{\hat f}^{ L_{\max}, L^*}(t)-\hat d^{L_{\max}}(t); \underline{\hat f}^{ L_{\max}, L^*}(t)+\hat d^{L_{\max}}(t)]</span>. To do that, we have to understand the behavior of the different terms.</p>
<p>It is difficult to compare theoretically the width of the two bands. We compare them with simulations. For 100 repeated datasets, we compute three different confidence bands: the band defined in <a href="#prp-CBf">Proposition&nbsp;5</a> with <span class="math inline">\hat L</span> defined in <a href="#eq-def-Lhat">Equation&nbsp;7</a>, the band constructed in <a href="#sec-bandSun">Section&nbsp;3</a> with <span class="math inline">L_{\max}</span> and the ideal (and not accessible) band constructed in <a href="#sec-bandSun">Section&nbsp;3</a> with the true <span class="math inline">L^*</span>. In <a href="#fig-width">Figure&nbsp;8</a>, we present the boxplots of the norms of the width of the band with <span class="math inline">\hat L</span> (left), with <span class="math inline">L_{\max}</span> (middle) and <span class="math inline">L^*</span> (right).<br>
The width of the confidence band with the true <span class="math inline">L^*</span> is smaller, which is expected but unfortunately not achievable. What was not expected, but sad, is that the width of the confidence band constructed in <a href="#sec-bandSun">Section&nbsp;3</a> with some <span class="math inline">L_{\max}</span> is smaller than our band with a correction of the bias and the model selection criteria. This may be understood because we estimate two different quantities, on smaller dataset, for more conservative level (<span class="math inline">1-\alpha</span> and <span class="math inline">1-\beta</span> respectively) to achieve at the end the confidence level of <span class="math inline">1-\alpha\beta</span>. The use of the two independent subsamples is mandatory to control the probability in the proof of <a href="#thm-sunLoader">Theorem&nbsp;1</a>. Therefore it is not possible to correct this problem. In the next section, we come back to the confidence bands proposed in <a href="#sec-bandSun">Section&nbsp;3</a> and propose a model selection criterion to take into account the bias.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfBandWidth, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Band.width)) <span class="sc">+</span> </span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-width" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-width-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;8: Illustrative example. We display within boxplots the confidence band’s width over 100 repetitions for the model selected by our criterion, some fixed Lmax and the true (unknown) <span class="math inline">L^{*}</span> for Fourier (left), Legendre (middle) and Splines (right) basis.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-modsel" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Selection criteria of the best confidence band accounting for the bias</h1>
<p>In this section, we want to propose a new heuristic criteria going back to the definition of the band itself seen as the estimation of a quantile of a certain empirical process. The criteria is inspired by model selection tools to select the best dimension <span class="math inline">L</span>.</p>
<p>We work on the quantile <span class="math inline">q^L</span> introduced in <a href="#eq-qL">Equation&nbsp;3</a>, its oracle version <span class="math inline">q^{L^*}</span> for the level <span class="math inline">L^*</span> and the estimation <span class="math inline">\hat q^L</span>. All of them are scalar, in a collection of scalars, with <span class="math inline">L=1, \ldots, L_{\max}</span>. A natural criteria to choose the best <span class="math inline">L</span> is such that the estimator <span class="math inline">\hat q^L</span> minimizes the quadratic error <span class="math inline">\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right)</span>. However, this quadratic error is unknown as <span class="math inline">q^{L^*}</span> is unknown. We can not directly use it.</p>
<p>Instead, we study <span class="math inline">\|\hat{q}^{L_{\max}}-\hat q^L\|^2</span>. We assume that <span class="math inline">L_{\max}</span> is large enough such that <span class="math inline">\underline f^{L_{\max},L^*}=f^{L^*}</span>. While the theoretical error decreases when <span class="math inline">L&lt;L^*</span> and increases when <span class="math inline">L&gt;L^*</span>, this approximation is still decreasing when <span class="math inline">L&gt;L^*</span>, as illustrated in <a href="#fig-crit1">Figure&nbsp;9</a>.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L.star<span class="fl">.3</span> <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">c.L =</span> c.L, <span class="at">c.L.Lmax =</span> c.L.Lmax<span class="fl">.2</span>))</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>dfCriterion <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">criterion =</span> <span class="fu">double</span>(),</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a>                         <span class="at">dimension =</span> <span class="fu">integer</span>(),</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>) }</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">L.eps =</span> <span class="dv">28</span>)</span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>  c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L  </span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>    length.band[L] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L<span class="sc">$</span>f.hat.up))</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L])<span class="co"># + lambda * vec.L/((dim(data$y)[1]))</span></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>  dfCriterion <span class="ot">=</span> <span class="fu">rbind</span>(dfCriterion, <span class="fu">data.frame</span>(<span class="at">error =</span> crit,</span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">dimension =</span> vec.L,</span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb12-56"><a href="#cb12-56" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-57"><a href="#cb12-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-58"><a href="#cb12-58" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfCriterion, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> error)) <span class="sc">+</span> </span>
<span id="cb12-59"><a href="#cb12-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>()<span class="sc">+</span></span>
<span id="cb12-60"><a href="#cb12-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-crit1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-crit1-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;9: Illustrative example. For a given simulated dataset, we show the behavior of the error as a function of the dimension L, for Fourier (left), Legendre (middle) and Splines (right) basis.</figcaption>
</figure>
</div>
</div>
</div>
<p>The, we recognize a behavior similar to a bias, high with model of small dimension, and small when dimension is large. Selecting a model using this criterion will always overfit the data. Thus, we propose to penalize by the dimension, as usually in model selection criterion.</p>
<p></p>
<p>Instead, we use the classic decomposition into bias and variance: <span class="math display">\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right) = \|q^{L^*}-q^L\|^2+\mathbb{E}\left( \|q^L-\hat q^L\|^2\right)=:b^L+v^L,</span> where the first term <span class="math inline">b^L = \|q^{L^*}-q^L\|^2</span> is the bias term and <span class="math inline">v^L = \mathbb{E}\left( \|q^L-\hat q^L\|^2\right)</span> is the variance term. Note that these terms are not functional and different from the functional bias defined previously. The two terms are unknown. Let us denote <span class="math inline">\hat b^L</span> and <span class="math inline">\hat v^L</span> their estimators. We assume that <span class="math inline">L_{\max}</span> is large enough such that <span class="math inline">\underline f^{L_{\max},L^*}=f^{L^*}</span>. Under this assumption, instead of computing the bias <span class="math inline">\|q^{L^*}-q^L\|^2</span>, we focus on <span class="math inline">\|q^{L_{\max}}-q^L\|^2</span>. This is not an equality because the first term decreases when <span class="math inline">L&lt;L^*</span> and increases when <span class="math inline">L&gt;L^*</span>, while the second term is still decreasing when <span class="math inline">L&gt;L^*</span>. However, we just need the decreasing behavior of the bias which will be compensated by the increasing of the variance. We then introduce the estimator of the bias as <span class="math inline">\hat b^L = \|\hat q^{L_{\max}}-\hat q^L\|^2</span>. For the variance term, we need to bound it. Let us remark that the variance of <span class="math inline">\hat q^L</span> is of order <span class="math inline">L/N</span>. Thus we set <span class="math display">\hat v^L := \lambda \frac{L}{N},</span> where <span class="math inline">\lambda&gt;0</span> is a tuning parameter.</p>
<p></p>
<p>A natural criteria to select the best <span class="math inline">L</span> is then<br>
<span class="math display">crit(L) =  \|\hat q^{L_{\max}}-\hat q^L\|^2  +\lambda \frac{L}{N}.</span></p>
<p>Then we define <span class="math display">\hat L = \arg\min_L crit(L),</span> and take the band centered around <span class="math inline">\underline{\hat{f}}^{\hat L, L^*}</span>.</p>
<p>In <a href="#fig-critlast">Figure&nbsp;10</a>, we illustrate the behavior of this model selection criterion on simulated data, with <span class="math inline">\lambda=1</span> for the three basis. We can see that <span class="math inline">\hat L</span> is overestimated. As we work with nested spaces, it ensures that <span class="math inline">\hat L</span> has the tendency to be larger than <span class="math inline">L^*</span> and thus the confidence band is automatically unbiased.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L.star<span class="fl">.3</span> <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">c.L =</span> c.L, <span class="at">c.L.Lmax =</span> c.L.Lmax<span class="fl">.2</span>))</span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>dfCriterion <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">criterion =</span> <span class="fu">double</span>(),</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>                         <span class="at">dimension =</span> <span class="fu">integer</span>(),</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>) }</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">L.eps =</span> <span class="dv">28</span>)</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>  c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L  </span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>    length.band[L] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L<span class="sc">$</span>f.hat.up))</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a>  dfCriterion <span class="ot">=</span> <span class="fu">rbind</span>(dfCriterion, <span class="fu">data.frame</span>(<span class="at">criterion =</span> crit,</span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">dimension =</span> vec.L,</span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfCriterion, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> criterion)) <span class="sc">+</span> </span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>()<span class="sc">+</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-critlast" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-critlast-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;10: Illustrative example. For a given simulated dataset, we show the behavior of the criteria as a function of the dimension L, for Fourier (left), Legendre (middle) and Splines (right) basis.</figcaption>
</figure>
</div>
</div>
</div>
<p>In <a href="#fig-critlastmodsel">Figure&nbsp;11</a>, we test which model is selected over 100 repetitions for the three basis. The estimated dimension is equal or larger than the true <span class="math inline">L^*=11</span>. As in <a href="#fig-modelsel">Figure&nbsp;7</a>, being larger is not a problem. However, the selected dimension is smaller in distribution, and closer to the true value than in <a href="#fig-modelsel">Figure&nbsp;7</a>. Thus this new approach performs better. Moreover, as we then use the confidence band of <a href="#sec-bandSun">Section&nbsp;3</a>, the confidence level is ensured to be the expected one.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">"Res_Tab3_n50_3basisBandWidth.RData"</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  dfLengthSelect <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">length =</span> <span class="fu">double</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  dfLhatSelect <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Lhat =</span> <span class="fu">double</span>(), <span class="at">L =</span> <span class="fu">integer</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    mod.sel<span class="ot">=</span> length.CBL <span class="ot">=</span> length.modsel <span class="ot">=</span> length.CBmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (repet <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>){</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>      c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">set.seed</span>(repet)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>      data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>      conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>      c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L  </span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>      length.CBmax[repet] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L.max<span class="sc">$</span>f.hat.up <span class="sc">-</span> conf.band.L.max<span class="sc">$</span>f.hat.low)</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>        conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>        length.CBL[L] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L<span class="sc">$</span>f.hat.up <span class="sc">-</span> conf.band.L<span class="sc">$</span>f.hat.low))</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>      lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>      crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>      mod.sel[repet] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>      length.modsel[repet] <span class="ot">=</span> length.CBL[vec.L[<span class="fu">which.min</span>(crit)]]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    dfLhatSelect <span class="ot">=</span> <span class="fu">rbind</span>(dfLhatSelect, <span class="fu">data.frame</span>(</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>      <span class="at">L =</span> vec.L,</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel, <span class="at">levels =</span> vec.L))),</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> length.modsel,</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis, repet),</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="st">"Lhat2"</span>, <span class="at">each =</span> repet)))  </span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfLhatSelect, <span class="at">file =</span> <span class="st">"Res_barplot_n50_3basisLhat.RData"</span>)</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab3_n50_3basisBandWidth_2.RData"</span>)</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_barplot_n50_3basisLhat.RData'</span>)</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisBandWidth_2.RData'</span>)}</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> dfLhatSelect, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat)) <span class="sc">+</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-critlastmodsel" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-critlastmodsel-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;11: Illustrative example. We show the distribution of the selected model, over 100 repetitions, with the new criteria used to select a model for different basis.</figcaption>
</figure>
</div>
</div>
</div>
<p>We then show in <a href="#fig-width-2">Figure&nbsp;12</a> that the width of the selected model is better than the width of the confidence band with a large level <span class="math inline">L_{\max}</span>, which one should have used to avoid model selection.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisBandWidth_2.RData'</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfBandWidth, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Band.width)) <span class="sc">+</span>    <span class="fu">geom_boxplot</span>() <span class="sc">+</span>     <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div id="fig-width-2" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-width-2-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;12: Illustrative example. We display within boxplots the confidence band’s width over 100 repetitions for the model selected by our criterion, some fixed Lmax and the true (unknown) <span class="math inline">L^{*}</span> for Fourier (left), Legendre (middle) and Splines (right) basis.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="real-data-analysis" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Real data analysis</h1>
<p>In this section, we illustrate the proposed method on the Berkeley Growth Study data. It consists of the heights in centimeters of 39 boys at 31 ages from 1 to 18. We approximate those curves by our 3 basis, namely Legendre, Splines and Fourier. We select the level of each basis using the method introduced in <a href="#sec-modsel">Section&nbsp;5</a>.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fda)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(growth)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">list</span>()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>time <span class="ot">=</span> (growth<span class="sc">$</span>age <span class="sc">-</span> <span class="fu">min</span>(growth<span class="sc">$</span>age))<span class="sc">/</span>(<span class="fu">max</span>(growth<span class="sc">$</span>age) <span class="sc">-</span> <span class="fu">min</span>(growth<span class="sc">$</span>age))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>y <span class="ot">=</span> growth<span class="sc">$</span>hgtm</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">25</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="dv">3</span><span class="sc">:</span><span class="dv">24</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fl">0.2</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>dfBandlow <span class="ot">=</span> dfBandup <span class="ot">=</span> df.max <span class="ot">=</span> res_growth <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Splines"</span>, <span class="st">"Fourier"</span>)){</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  mod.sel<span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">24</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> alpha)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>  df.max <span class="ot">=</span> <span class="fu">rbind</span>(df.max, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age, </span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">band.up =</span> <span class="fu">t</span>(conf.band.L.max<span class="sc">$</span>f.hat.up),</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">band.low =</span> <span class="fu">t</span>(conf.band.L.max<span class="sc">$</span>f.hat.low),</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (alpha))</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>  mod.sel <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste0</span>(<span class="st">'model selected:'</span>, mod.sel))</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>  conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, mod.sel, <span class="at">alpha =</span> alpha)</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>  dfBandup <span class="ot">=</span> <span class="fu">rbind</span>(dfBandup, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age,</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">bandup =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up),</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>  dfBandlow <span class="ot">=</span> <span class="fu">rbind</span>(dfBandlow, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age,</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">bandlow =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low),</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste0</span>(<span class="st">'length L sel:'</span>, conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>c.L))</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>  res_growth <span class="ot">=</span> <span class="fu">cbind</span>(res_growth, <span class="fu">c</span>(conf.band.L.max<span class="sc">$</span>c.L, conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>c.L, mod.sel))</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "model selected:6"
[1] "length L sel:1.98960434593563"
[1] "model selected:5"
[1] "length L sel:1.94736120271032"
[1] "model selected:7"
[1] "length L sel:2.07846739360277"</code></pre>
</div>
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(res_growth) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Splines"</span>, <span class="st">"Fourier"</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(res_growth) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Length Lmax"</span>, <span class="st">"Length selected"</span>, <span class="st">"Model selected"</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>df.data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">rep</span>(growth<span class="sc">$</span>age,<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]), <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]), <span class="at">each =</span> <span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span>  <span class="fu">geom_line</span>(<span class="at">data=</span>df.data, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span>f, <span class="at">group=</span>ind), <span class="at">color =</span> <span class="st">"lightgrey"</span>,<span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandup, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandup,<span class="at">col =</span> basis, <span class="at">group =</span> basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandlow, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandlow,<span class="at">col =</span> basis, <span class="at">group =</span> basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> df.max, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span> band.up, <span class="at">group=</span>basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> df.max, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span> band.low, <span class="at">group=</span>basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span> basis)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>p1</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>res_growth</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>                Legendre  Splines  Fourier
Length Lmax     2.124539 2.124536 2.204230
Length selected 1.989604 1.947361 2.078467
Model selected  6.000000 5.000000 7.000000</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-realdata" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="ConfBand_files/figure-html/fig-realdata-1.svg" style="height:25.0%" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;13: Real data analysis example. We display the confidence bands for Fourier (left), Legendre (middle) and Splines (right) basis on the Berkeley Growth Study data. Black curves correspond to the confidence bands with <span class="math inline">L_{max}</span>, while colored one are the confidence bands constructed by our data-driven method.</figcaption>
</figure>
</div>
</div>
</div>
<p>As the data is not periodic, the Fourier basis is meaningless, and so is the associated confidence band, whatever the level considered. Both splines and Legendre basis give similar confidence bands. When analyzing the length of the bands compared with the one with <span class="math inline">L_{\max}</span> coefficients, we see that there are less smooth but also smaller, and from our empirical study we guess that it makes a trade-off between bias and variance.</p>
</section>
<section id="sec-conc" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Conclusion</h1>
<p>This paper discusses the construction of confidence bands when considering a linear model over a functional family. Depending on the nature of the family (an orthogonal or orthonormal basis, or just a vector space), theoretical guarantees of the linear estimator are reminded and illustrated. Then, several confidence bands are proposed. First, when considering a functional family with a fixed level, we discuss the confidence band derived from <span class="citation" data-cites="sun1994">Sun and Loader (<a href="#ref-sun1994" role="doc-biblioref">1994</a>)</span>. It is bias if the level is not high enough to approximate well the true function. Then, a new confidence band is proposed that correct this bias. To do so, the bias is estimated and the additional randomness is controlled. A model selection criterion is proposed to select the best level. Unfortunately, the two kinds of randomness are leading to a larger confidence band, and this result is then not more interesting than the naive one, which consists in taking the largest level possible <span class="math inline">L_{\max}</span>. Finally, a heuristic model selection criterion is proposed to select the level on the first confidence band, that did not correct the bias. It takes into account the bias as well as the variance, to select a moderate level. Throughout the paper, extensive experimental study on Fourier, Legendre and Spline basis have illustrated the theoretical and methodological proposition, and a real data study is proposed to conclude the paper.</p>
<p>The last model selection criterion is heuristic, while each term is intuitive. An interesting next step, but out of the scope of this paper, consists of a theoretical study of this criterion. No result, to our knowledge, exist for confidence band with the supremum norm. The euclidean norm is well-studied in general, but is not of interest here, where we want to ensure that the tube is valid as a whole. The supremum norm, on its side, is difficult to study theoretically. A keypoint here also is the randomness of the criterion, that has also to be taken into account, through an oracle inequality for example.</p>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-ANEIROS2022104871" class="csl-entry" role="listitem">
Aneiros, Germán, Silvia Novo, and Philippe Vieu. 2022. <span>“Variable Selection in Functional Regression Models: A Review.”</span> <em>Journal of Multivariate Analysis</em> 188: 104871. https://doi.org/<a href="https://doi.org/10.1016/j.jmva.2021.104871">https://doi.org/10.1016/j.jmva.2021.104871</a>.
</div>
<div id="ref-BASNA2022104868" class="csl-entry" role="listitem">
Basna, Rani, Hiba Nassar, and Krzysztof Podgórski. 2022. <span>“Data Driven Orthogonal Basis Selection for Functional Data Analysis.”</span> <em>Journal of Multivariate Analysis</em> 189: 104868. https://doi.org/<a href="https://doi.org/10.1016/j.jmva.2021.104868">https://doi.org/10.1016/j.jmva.2021.104868</a>.
</div>
<div id="ref-bunea2011" class="csl-entry" role="listitem">
Bunea, Florentina, Andrada E. Ivanescu, and Marten H. Wegkamp. 2011. <span>“Adaptive Inference for the Mean of a Gaussian Process in Functional Data.”</span> <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em> 73 (4): 531–58. https://doi.org/<a href="https://doi.org/10.1111/j.1467-9868.2010.00768.x">https://doi.org/10.1111/j.1467-9868.2010.00768.x</a>.
</div>
<div id="ref-Claeskens2003" class="csl-entry" role="listitem">
Claeskens, G., and I. Van Keilegom. 2003. <span>“Bootstrap Confidence Bands for Regression Curves and Their Derivatives.”</span> <em>Ann. Stat.</em>
</div>
<div id="ref-conformalPrediction2022" class="csl-entry" role="listitem">
Diquigiovanni, Jacopo, Matteo Fontana, and Simone Vantini. 2022. <span>“Conformal Prediction Bands for Multivariate Functional Data.”</span> <em>Journal of Multivariate Analysis</em> 189: 104879. https://doi.org/<a href="https://doi.org/10.1016/j.jmva.2021.104879">https://doi.org/10.1016/j.jmva.2021.104879</a>.
</div>
<div id="ref-GoeppSubmitted" class="csl-entry" role="listitem">
Goepp, V., O. Bouaziz, and G. Nuel. Submitted. <span>“Spline Regression with Automatic Knot Selection,”</span> Submitted.
</div>
<div id="ref-Hall1991" class="csl-entry" role="listitem">
Hall, P. 1991. <span>“On Convergence Rates of Suprema.”</span> <em>Probab Theory Related Fields</em>.
</div>
<div id="ref-jacques2022" class="csl-entry" role="listitem">
Jacques, Julien, and Sanja Samardžić. 2022. <span>“<span class="nocase">Analysing Cycling Sensors Data Through Ordinal Logistic Regression with Functional Covariates</span>.”</span> <em>Journal of the Royal Statistical Society Series C: Applied Statistics</em> 71 (4): 969–86. <a href="https://doi.org/10.1111/rssc.12563">https://doi.org/10.1111/rssc.12563</a>.
</div>
<div id="ref-kokoszka2017introduction" class="csl-entry" role="listitem">
Kokoszka, P., and M. Reimherr. 2017. <em>Introduction to Functional Data Analysis</em>. Chapman &amp; Hall / CRC Numerical Analysis and Scientific Computing. CRC Press. <a href="https://books.google.dk/books?id=HIxIvgAACAAJ">https://books.google.dk/books?id=HIxIvgAACAAJ</a>.
</div>
<div id="ref-Krivobokova2010" class="csl-entry" role="listitem">
Krivobokova, Tatyana, Thomas Kneib, and Gerda Claeskens. 2010. <span>“Simultaneous Confidence Bands for Penalized Spline Estimators.”</span> <em>Journal of the American Statistical Association</em> 105 (490): 852–63.
</div>
<div id="ref-LI2022104806" class="csl-entry" role="listitem">
Li, Yehua, Yumou Qiu, and Yuhang Xu. 2022. <span>“From Multivariate to Functional Data Analysis: Fundamentals, Recent Developments, and Emerging Areas.”</span> <em>Journal of Multivariate Analysis</em> 188: 104806. https://doi.org/<a href="https://doi.org/10.1016/j.jmva.2021.104806">https://doi.org/10.1016/j.jmva.2021.104806</a>.
</div>
<div id="ref-Liebl2019" class="csl-entry" role="listitem">
Liebl, D, and M. Reimherr. 2019. <span>“Fast and Fair Simultaneous Confidence Bands for Functional Parameters.”</span>
</div>
<div id="ref-Neumann1998" class="csl-entry" role="listitem">
Neumann, M., and J. Polzehl. 1998. <span>“Simultaneous Bootstrap Confidence Bands in Nonparametric Regression.”</span> <em>J Nonparametr Statist</em>.
</div>
<div id="ref-Quinton-2017-escon" class="csl-entry" role="listitem">
Quinton, J-C., E. Devijver, A. Leclercq-Samson, and A. Smeding. 2017. <span>“Functional Mixed Effect Models for Mouse-Tracking Data in Social Cognition.”</span> In <em>ESCON Transfer of Knowledge Conference, Gdansk, Polland</em>.
</div>
<div id="ref-CB_survivalAnalysis2022" class="csl-entry" role="listitem">
Sachs, Michael C., Adam Brand, and Erin E. Gabriel. 2022. <span>“Confidence Bands in Survival Analysis.”</span> <em>The British Journal of Cancer. Supplement</em> 127: 1636–41. <a href="https://doi.org/10.1038/s41416-022-01920-5">https://doi.org/10.1038/s41416-022-01920-5</a>.
</div>
<div id="ref-sun1994" class="csl-entry" role="listitem">
Sun, Jiayang, and Clive R. Loader. 1994. <span>“Simultaneous Confidence Bands for Linear Regression and Smoothing.”</span> <em>Ann. Statist.</em> 22 (3): 1328–45. <a href="https://doi.org/10.1214/aos/1176325631">https://doi.org/10.1214/aos/1176325631</a>.
</div>
<div id="ref-Telschow2023" class="csl-entry" role="listitem">
Telschow, Fabian J. E., Dan Cheng, Pratyush Pranav, and Armin Schwartzman. 2023. <span>“<span class="nocase">Estimation of expected Euler characteristic curves of nonstationary smooth random fields</span>.”</span> <em>The Annals of Statistics</em> 51 (5): 2272–97. <a href="https://doi.org/10.1214/23-AOS2337">https://doi.org/10.1214/23-AOS2337</a>.
</div>
<div id="ref-TELSCHOW202270" class="csl-entry" role="listitem">
Telschow, Fabian J. E., and Armin Schwartzman. 2022. <span>“Simultaneous Confidence Bands for Functional Data Using the Gaussian Kinematic Formula.”</span> <em>Journal of Statistical Planning and Inference</em> 216: 70–94. https://doi.org/<a href="https://doi.org/10.1016/j.jspi.2021.05.008">https://doi.org/10.1016/j.jspi.2021.05.008</a>.
</div>
<div id="ref-Xia1998" class="csl-entry" role="listitem">
Xia, Y. 1998. <span>“Bias-Corrected Confidence Bands in Nonparametric Regression.”</span> <em>J.R. Stat. Soc. Ser. B</em>.
</div>
<div id="ref-Zhou1998" class="csl-entry" role="listitem">
Zhou, S., X. Shen, and D. A. Wolfe. 1998. <span>“Local Asymptotics for Regression Splines and Confidence Regions.”</span> <em>Ann. Statist.</em>
</div>
</div>
</section>
<section id="appendix-proofs" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Appendix: proofs</h1>
<section id="proof-of-proposition-prp-error" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="proof-of-proposition-prp-error"><span class="header-section-number">8.1</span> Proof of Proposition <a href="#prp-error">Proposition&nbsp;3</a></h2>
<p>Let us prove the first point. We have <span class="math display"> \mathbb{E}(\hat{\underline{\mu}}^{L,L^\star}) = (\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbb{E}(\mathbf{y}) =(\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbf{B}_{L^*}\mu^{L^*}=:\underline{\mu}^{L,L^\star}.</span></p>
<p>The theory of the linear model gives that the variance of <span class="math inline">\hat{\underline{\mu}}^L</span> is equal to <span class="math inline">\sigma^2 (\mathbf{B}^T\mathbf{B})^{-1} \mathbf{B}^T\Sigma \mathbf{B}(\mathbf{B}^T\mathbf{B})^{-1}</span> with <span class="math inline">\Sigma=Diag(\Sigma_1, \ldots, \Sigma_N)</span> the <span class="math inline">nN \times nN</span> covariance matrix of <span class="math inline">\mathbf{y}</span>. So finally, we have</p>
<p><span class="math display">
\hat{\underline{\mu}}^{L,L^\star}
\sim \mathcal{N}\left(\underline{\mu}^{L,L^\star}, \sigma^2\Sigma_{B}^{L, L^ \varepsilon}
\right).
</span></p>
<p>Now we can easily deduce the distribution of <span class="math inline">\hat{\underline{f}}^{L,L^*}(t)</span>, for each <span class="math inline">t\in [0,1]</span>: <span class="math display">\hat{\underline{f}}^{L,L^*}(t)- \mathbf f^{L,L^*}(t) \sim \mathcal{N}\left(0, \sigma^2 B(t)\Sigma_{B}^{L, L^\varepsilon} B(t)^T\right).</span></p>
</section>
<section id="proof-of-theorem-thm-cb_liebl_asymptotic" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="proof-of-theorem-thm-cb_liebl_asymptotic"><span class="header-section-number">8.2</span> Proof of Theorem <a href="#thm-CB_Liebl_asymptotic">Theorem&nbsp;2</a></h2>
<p>We have <span class="math display">P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-\underline{f}^{L, L^*}(t)+ \underline{f}^{L, L^*}(t)- f^{L,L^*}(t)| \leq \hat d^L(t))</span></p>
<p>Set assumptions <a href="#def-ass-regression_finite">Definition&nbsp;1</a> and <a href="#def-ass-noise-spline">Definition&nbsp;3</a> and a probability <span class="math inline">\alpha\in [0,1]</span>. Then, we have, <span class="math display">\lim_{n \rightarrow +\infty} P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = 1-\alpha</span> with <span class="math inline">\hat d^L(t) = \hat c^L \sqrt{\hat C_L(t,t)/N}</span> and <span class="math inline">\hat c^L</span> defined as the solution of <a href="#eq-cL">Equation&nbsp;4</a>.</p>
</section>
<section id="proof-of-prp-cbf" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="proof-of-prp-cbf"><span class="header-section-number">8.3</span> Proof of <a href="#prp-CBf">Proposition&nbsp;5</a></h2>
<p>To simplify the notations, let us denote <span class="math inline">a(t) = \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t)</span> and <span class="math inline">b(t) = \underline{f}^{L_{\max},L^*}(t)- \underline{f}^{L,L^*}(t)-(\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L,L^*}(t))</span>. We have <span class="math display">\begin{align*}
    P\left( \exists t |a(t)+b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right) &amp;\leq
    P\left( \exists t |a(t)|+|b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right)\\
    &amp;= P\left( \exists t |a(t)| \geq \hat d_1^L(t)  \right)P\left( \exists t  |b(t)|\geq \hat d_2^{L,L_{\max}}(t)\right) = \alpha\beta.
\end{align*}</span></p>
<p>The last equality holds thanks to the independence of the two sub-samples.</p>
</section>
</section>
<section id="sec:band1" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Heuristics of bounding separately the infinity norms of the term and the term</h1>
<p>Let us give the main ideas. We denote <span class="math display">\begin{align*}
A_{L, L^*} &amp;= \sup_t|Approx(t)| = \sup_t|\underline{f}^{L, L^*}(t) - \underline{f}^{L^*,L^*}(t)| = \sup_t|\underline{f}^{L, L^*}(t) - f^{L^*}(t)|,\\
b_{L, L^*} &amp;=\sup_t| Bias(t)|= \sup_t|\hat{\underline{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)|,
\end{align*}</span> the two infinity norms of the and the terms. Recall that when <span class="math inline">L\geq L^*</span>, <span class="math inline">Approx(t)=0</span> and thus <span class="math inline">A_{L, L^*}=0</span>. Then by the triangular inequality, we get <span class="math display">\sup_t |\hat{\underline{f}}^{L, L^*}(t) -f^{L^*}(t)| \leq A_{L, L^*} + b_{L, L^*}.</span></p>
<p>If we find a bound <span class="math inline">M^L</span> such that <span id="eq-ML_BiaisVariance"><span class="math display">
P( A_{L, L^*} + b_{L, L^*} \leq M^L)\geq 1-\alpha ,
\tag{8}</span></span> it will imply a confidence band of order <span class="math inline">1-\alpha</span> for <span class="math inline">f^{L^*}(t)</span>: <span class="math display">
P(\sup_t |\hat{\underline{f}}^{L, L^*}(t) -f^{L^*}(t)| \leq M^L)\geq 1-\alpha .
</span>{#eq-ML}}</p>
<p>The problem reduces to find <span class="math inline">M^L</span> which bounds both the term and the term. We bound each term in <a href="#sec-BiasLstar">Section&nbsp;9.1</a> and <a href="#sec-ApproxLstar">Section&nbsp;9.2</a>, respectively. The term <span class="math inline">A_{L, L^*}</span> is deterministic. However, as it is analytically unknown, we will estimate an upper bound based on observations. To guarantee the independence between the two bounds, the sample of observations is split in two parts and the two bounds are calculated on one half of the sample. We denote <span class="math inline">\mathbf{y}^1 = (y_1, \ldots, y_{n/2})</span> and <span class="math inline">\mathbf{y}^2 = (y_{n/2+1}, \ldots, y_{n})</span> the two sub-samples. Then we introduce the confidence band of <span class="math inline">f^{L^*}</span> based on <span class="math inline">\underline{f}^{L,L^*}</span> in <a href="#sec-BandLstar">Section&nbsp;9.3</a>.</p>
<section id="sec-BiasLstar" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="sec-BiasLstar"><span class="header-section-number">9.1</span> Bound of the term.</h2>
<p>The bound of the term is calculated with the first sub-sample <span class="math inline">\mathbf{y}^1</span> of size <span class="math inline">n/2</span>. The estimator <span class="math inline">\hat{\underline{f}}_1^{L, L^*}</span> is calculated on this sub-sample. The statistical <span class="math inline">b_{L, L^*}</span> is the supremum of a Gaussian process. Using the confidence band proposed in Section , for a given confidence level <span class="math inline">1-\alpha_1</span>, there exists an estimable function <span class="math inline">\hat d_1^L()</span> defined as <span class="math inline">\hat d_1^L(t)= \hat c^L \sqrt{\frac{\hat{C}_L(t)}{n/2}}</span> such that <span class="math display">P(\forall t, \hat{\underline{f}}^{L,L^*}_1 (t) - \hat d_1^L(t) \leq \underline{f}^{L,L^*}(t)\leq \hat{\underline{f}}^{L,L^*}_1 (t) + \hat d_1^L(t))=1-\alpha_1.</span> Let us denote <span class="math inline">\hat d^L_1 = \sup_t |\hat d_1^L(t)|</span>. Then with probability <span class="math inline">1-\alpha_1</span>, we have</p>
<p><span class="math display">
b_{L,L^*}\leq \hat d^L_1.
</span>{eq:borne_bL}</p>
</section>
<section id="sec-ApproxLstar" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="sec-ApproxLstar"><span class="header-section-number">9.2</span> Bound of the term.</h2>
<p></p>
<p>Let us now bound the term which has no explicit form. We thus need to estimate a bound of <span class="math inline">A_{L, L^*}</span> and will use the second sub-sample <span class="math inline">\mathbf{y}^2</span> to do that.</p>
<p>Let us consider <span class="math inline">L_{\max}</span> large enough such that <span class="math inline">\underline{f}^{L^*,L^*} =\underline{f}^{L_{\max},L^*}</span>. A natural estimator of <span class="math inline">\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)</span> is <span class="math inline">\hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t)</span>. We can then decompose the term by introducing its estimator: <span class="math display">\begin{align*}
|\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)|&amp;=
|\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)-(\hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t))| \\
&amp;+| \hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t)|.
\end{align*}</span></p>
<p>The first term is a centered Gaussian process, the second term is a quantity that we can estimate and thus bound. Let us give a bound for the first term, using Section . For a given level <span class="math inline">1-\alpha_2</span>, there exists a function <span class="math inline">\hat d^{L,L_{\max}}()</span> such that</p>
<p><span class="math display"> P\left( \forall t \in [0,1], |\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)-(\hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t))| \leq \hat d^{L,L_{\max}}(t)\right) = 1-\alpha_2.
</span>{eq-borne_dLLmax}</p>
<p>Let us denote <span class="math inline">\hat d^{L,L_{\max}} = \sup_t |\hat d^{L,L_{\max}}(t)|</span> and <span class="math inline">\| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*} \|_\infty = \sup_t | \hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t)|</span>. Then we can deduce that with probability <span class="math inline">1-\beta_2</span> <span class="math display"> A_{L,L^*} \leq  \hat d^{L,L_{\max}} + \| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*} \|_\infty.
</span></p>
<p>Note that when <span class="math inline">L\geq L^*</span>, $ A_{L,L^*} = 0$. We thus expect the bound <span class="math inline">\hat d^{L,L_{\max}} + \| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*} \|_\infty</span> to be small when <span class="math inline">L\geq L^*</span>. But as <span class="math inline">L^*</span> is unknown, we can not remove it from the bound. </p>
<p></p>
</section>
<section id="sec-BandLstar" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="sec-BandLstar"><span class="header-section-number">9.3</span> Confidence band of <span class="math inline">\underline{f}^{L^*}</span> for a given <span class="math inline">L</span></h2>
<p>Using the two bounds of the and the terms allows to define a bound <span class="math inline">M^L</span> of <span class="math inline">\hat{\underline{f}}^{L, L^*}-f^{L^*}</span>. We can prove the following result:</p>
<div id="thm-CBfLstarMax" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3 </strong></span>With high probability, we have <span class="math display"> \forall t \in [0,1], \quad |\hat{\underline{f}}^{L,L^*}(t) - \underline{f}^{L^*,L^*}| \leq \hat M^L
</span></p>
<p>with <span class="math display">\hat M^L := \hat d^L +\hat d^{L,L_{\max}} + \| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*}\|_\infty</span> where <span class="math inline">\hat d^L</span> is defined by with level <span class="math inline">\alpha/2</span> using the first sub-sample <span class="math inline">\mathbf{y}^1</span> and <span class="math inline">\hat d^{L,L_{\max}}</span> is defined by with level <span class="math inline">\alpha/2</span> using the second sub-sample <span class="math inline">\mathbf{y}^2</span>.</p>
</div>
<p> </p>
<p>This theorem provides a confidence band for <span class="math inline">\underline{f}^{L^*,L^*}</span> which is based on the estimator <span class="math inline">\hat{\underline{f}}^{L,L^*}</span>: <span class="math display"> \left[\hat{\underline{f}}^{L,L^*}(t) - \hat M^L; \hat{\underline{f}}^{L,L^*}(t) + \hat M^L\right] </span> for all <span class="math inline">t\in[0,1]</span>.</p>
<!-- -->

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{devijver2024,
  author = {Devijver, Emilie and Samson, Adeline},
  publisher = {Société Française de Statistique},
  title = {Should We Correct the Bias in {Confidence} {Bands} for
    {Repeated} {Functional} {Data?}},
  journal = {Computo},
  date = {2024-05-27},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {While confidence intervals for finite quantities are
    well-established, constructing confidence bands for objects of
    infinite dimension, such as functions, poses challenges. In this
    paper, we explore the concept of parametric confidence bands for
    functional data with an orthonormal basis. Specifically, we revisit
    the method proposed by Sun and Loader, which yields confidence bands
    for the projection of the regression function in a fixed-dimensional
    space. This approach can introduce bias in the confidence bands when
    the dimension of the basis is misspecified. Leveraging this insight,
    we introduce a corrected, unbiased confidence band. Surprisingly,
    our corrected band tends to be wider than what a naive approach
    would suggest. To address this, we propose a model selection
    criterion that allows for data-driven estimation of the basis
    dimension, balancing the trade-off between bias and variance.
    Throughout the paper, we illustrate these strategies using an
    extensive simulation study. We conclude with an application to real
    data.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-devijver2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Devijver, Emilie, and Adeline Samson. 2024. <span>“Should We Correct the
Bias in Confidence Bands for Repeated Functional Data?”</span>
<em>Computo</em>, May. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb20" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Should we correct the bias in Confidence Bands for Repeated Functional Data?"</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Emilie Devijver</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">    email: emilie.devijver@univ-grenoble-alpes.fr</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://lig-aptikal.imag.fr/~devijvee/</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: CNRS, Univ. Grenoble Alpes, Grenoble INP, LIG, 38000 Grenoble, France</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Adeline Samson</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">    email: adeline.leclercq-samson@univ-grenoble-alpes.fr</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://adeline.e-samson.org</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Univ. Grenoble Alpes, CNRS, Grenoble INP, LJK, 38000 Grenoble, France</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="co"> While confidence intervals for finite quantities are well-established, constructing confidence bands for objects of infinite dimension, such as functions, poses challenges. In this paper, we explore the concept of parametric confidence bands for functional data with an orthonormal basis. Specifically, we revisit the method proposed by Sun and Loader, which yields confidence bands for the projection of the regression function in a fixed-dimensional space. This approach can introduce bias in the confidence bands when the dimension of the basis is misspecified. Leveraging this insight, we introduce a corrected, unbiased confidence band. Surprisingly, our corrected band tends to be wider than what a naive approach would suggest. To address this, we propose a model selection criterion that allows for data-driven estimation of the basis dimension, balancing the trade-off between bias and variance. Throughout the paper, we illustrate these strategies using an extensive simulation study. We conclude with an application to real data.</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [functional data, repeated data, confidence band, Kac-Rice formulae, bias, dimension selection]</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "template-computo-r"</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: default</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: default</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>Functional data analysis is widely used for handling complex data with smooth shapes, finding applications in diverse fields such as neuroscience (e.g., EEG data, \textcolor{red}{REF}), psychology (e.g., mouse-tracking data, @Quinton-2017-escon), and sensor data from daily-life activities (@jacques2022).</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>We consider multiple independent observations of the same function, yielding noisy functional data. To analyze such data, a common approach, typically in the parametric setting, involves projecting the data onto a functional space defined by a family of functions (@LI2022104806, @kokoszka2017introduction). When the family serves as an orthonormal basis, e.g., Legendre (with the standard scalar product) or Fourier (with another scalar product), the projection is clearly understood, but widely used families such as  splines are not orthonormal for the standard scalar product. Leveraging an approximate functional space offers a key advantage: it simplifies the inference problem to estimating coefficients, for example through methods like least squares or maximum likelihood estimation. Subsequently, the function is estimated as the mean of the functional data following projection onto the functional basis.</span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>Measuring the uncertainty of an estimator is usually done using confidence intervals. In this paper, our focus lies specifically on providing a simultaneous confidence band for the function means, rather than point-wise confidence intervals. This task presents several challenges: the confidence band must effectively control the simultaneous functional type-I error rate, as opposed to point-wise rates; it must strike a balance between being sufficiently conservative to maintain a confidence level while not being overly so as to render it meaningless; and the method used to construct this confidence band should be computationally feasible for practical application.</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>Several developments have already been proposed to answer these questions. First, consider the case with only one individual (no repetition) but with many time points. Some methods study the asymptotic distribution of the infinity norm between the true function and its estimator. The asymptotic in the number of time points is studied in @Hall1991, @Claeskens2003. This approach works only for large datasets in time and is likely to be too conservative otherwise. For small samples, bootstrap methods have been developed to compute the confidence band (@Neumann1998, @Claeskens2003), but with a high computational cost. Another approach is to construct confidence bands based on the volume of the tube formula. @sun1994 studied the tail probabilities of suprema of Gaussian random processes. This approach is based on an unbiased linear estimator of the regression function. @Zhou1998 used the volume-of-tube formula for estimation by regression splines. @Krivobokova2010 used this method for the construction of confidence bands by penalized spline estimators. They proposed to mix Bayesian and frequentist approaches, to get the good properties from the Bayesian world but reducing the variability to be less conservative using the frequentist approach. The bias is considered through spline modeling, assuming sufficient knots are considered. @Liebl2019 have proposed a method based on random field theory and the volume-of-tube formula. They provide a band with locally varying widths using an unbiased estimator. Their method does not require the estimation of the full covariance function of the estimator, but only its diagonal. This reduces the computational time. From a practical viewpoint, @CB_survivalAnalysis2022 introduce a package to popularize simultaneous confidence bands, in the context of survival analysis. </span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>Some papers, like ours, rely on several observations of the same function. @bunea2011 propose a threshold-type estimator and derive error bounds and simultaneous confidence bands, having an unbiased estimator. @TELSCHOW202270 propose a simultaneous confidence band based on the Gaussian kinematic formula. Again, it assumes access to an unbiased estimator of the function of interest.</span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>Note that recent extensions have been proposed, to nonstationary random field in @Telschow2023 and based on conformal prediction in @conformalPrediction2022. These extensions are out of the scope of this paper, focusing on the simple functional case.</span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>One limitation of all those approaches is that they do not generally take into account the bias of the functional estimator. @sun1994 proposed a bias correction for a particular class of functions but left the smoothing parameter choice open, leading to an unusable estimator. In the nonparametric framework, the bias is approximated  using the estimator of the second derivative of the underlying mean function (@Xia1998). But in general, there is a lack of discussion on how to handle the bias of the functional estimator, even in the simple case of a functional space of finite dimension. </span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a>The objective of this paper is to address the bias problem in confidence band construction for a general function, utilizing a finite functional orthonormal family. Our contributions are as follows:</span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>we disentangle the bias issue by explicitly defining the parameter of interest within the approach of @sun1994;</span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>we propose a bias correction method in a new confidence band for the function of interest;</span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>we illustrate this confidence band, concluding on the conservatism of the procedure;</span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>finally, we  propose a method for selecting the dimension of the approximation space, treating it as a  model selection problem, with a trade-off between  conservatism and confidence level assurance. </span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true" tabindex="-1"></a>Note that while the model selection paradigm has been extensively studied in the literature, in multivariate statistics or functional data analysis  (e.g., @GoeppSubmitted, @ANEIROS2022104871, @BASNA2022104868), it has not been explored in the context of confidence band construction.  </span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-67"><a href="#cb20-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-68"><a href="#cb20-68" aria-hidden="true" tabindex="-1"></a>The paper is organized as follows:  @sec-model introduces the functional regression model, the considered functional family and the corresponding approximate regression models, as well as an estimator  defined in the finite space, along with descriptions of the error terms. In  @sec-bandSun, we propose a confidence band for the approximate regression function in the space of finite dimension, where the dimension is fixed. @sec-band2 proposes a strategy to construct a confidence band for the true function. This last confidence band being too conservative, @sec-modsel introduces a model selection criterion to select the best confidence band, doing a trade-off between  conservatism and confidence level assurance. @sec-conc ends the paper by a conclusion and discussion of perspectives. </span>
<span id="cb20-69"><a href="#cb20-69" aria-hidden="true" tabindex="-1"></a>The different estimation procedures are illustrated throughout the sections. </span>
<span id="cb20-70"><a href="#cb20-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-71"><a href="#cb20-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-72"><a href="#cb20-72" aria-hidden="true" tabindex="-1"></a><span class="fu"># Statistical Model {#sec-model}</span></span>
<span id="cb20-73"><a href="#cb20-73" aria-hidden="true" tabindex="-1"></a>In this paper, we consider time series as discrete measurements of functional curves. We first present the general functional regression model (@sec-functional_model) where the regression function belongs to a finite functional family of dimension $L^*$. </span>
<span id="cb20-74"><a href="#cb20-74" aria-hidden="true" tabindex="-1"></a>In practice, this dimension $L^*$ is unknown and we will work on functional space of dimension $L$. The regression model on the finite family of functions is presented in @sec-projection_model, and an estimator is proposed in @sec-estim, with a description of the error terms. </span>
<span id="cb20-75"><a href="#cb20-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-76"><a href="#cb20-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-77"><a href="#cb20-77" aria-hidden="true" tabindex="-1"></a>\bigskip</span>
<span id="cb20-78"><a href="#cb20-78" aria-hidden="true" tabindex="-1"></a><span class="fu">## Functional regression model {#sec-functional_model}</span></span>
<span id="cb20-79"><a href="#cb20-79" aria-hidden="true" tabindex="-1"></a>Let $y_{ij}$ be the measure at fixed time $t_{j} \in <span class="co">[</span><span class="ot">a,b</span><span class="co">]</span>$ for individual $i=1, \ldots, N$, with $j=1, \ldots, n$. We restrict ourselves to $<span class="co">[</span><span class="ot">a,b</span><span class="co">]</span> = <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, without loss of generality. </span>
<span id="cb20-80"><a href="#cb20-80" aria-hidden="true" tabindex="-1"></a>We assume these observations are discrete-time measurements of individual curves, which are independent and noisy realisations of a common function $f$ that belongs to a functional space. Thus for each individual $i$, we consider the following functional regression model</span>
<span id="cb20-81"><a href="#cb20-81" aria-hidden="true" tabindex="-1"></a>\begin{equation*}</span>
<span id="cb20-82"><a href="#cb20-82" aria-hidden="true" tabindex="-1"></a>y_{ij} = f(t_{j}) + \varepsilon_{ij}, </span>
<span id="cb20-83"><a href="#cb20-83" aria-hidden="true" tabindex="-1"></a>\end{equation*}</span>
<span id="cb20-84"><a href="#cb20-84" aria-hidden="true" tabindex="-1"></a>where $\varepsilon_{i.}=(\varepsilon_{i1}, \ldots, \varepsilon_{in})$ is the noise representing the individual functional variation around $f$. </span>
<span id="cb20-85"><a href="#cb20-85" aria-hidden="true" tabindex="-1"></a>We assume that the $\varepsilon_{i}$ are independent. Their distribution is detailed below. </span>
<span id="cb20-86"><a href="#cb20-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-87"><a href="#cb20-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-88"><a href="#cb20-88" aria-hidden="true" tabindex="-1"></a>For each individual $i=1, \ldots, N$, we denote $y_{i.}=(y_{i1}, \ldots, y_{in})$ the $n\times 1$ vector of observations, $t_{.}=(t_{1}, \ldots, t_{n})$ the $n \times 1$ vector of observation times and $f(t_{.})=(f(t_{1}), \ldots, f(t_{n}))$ the $n \times 1$ vector of the function $f$ evaluated in $t_{.}$. We also denote $\mathbf{y} = (y_{1.}, \ldots, y_{N.})$ the whole matrix of observations. </span>
<span id="cb20-89"><a href="#cb20-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-90"><a href="#cb20-90" aria-hidden="true" tabindex="-1"></a>Let us introduce the functional space $\mathcal{S}^{L^*} = Vect((t \mapsto B_\ell^{L^*}(t))_{1\leq \ell \leq L^*})$ with $L^*$ functions $(B_\ell^{L^*})_{1\leq \ell \leq L^*}$ assumed to be linearly independent.</span>
<span id="cb20-91"><a href="#cb20-91" aria-hidden="true" tabindex="-1"></a>Then, for any $f \in \mathcal{S}^{L^*}$, there exists a unique vector of coefficients $(\mu_{\ell}^{L^*})_{1\leq \ell \leq L^*}$ such that, for all $t$, $f(t) = \sum_{\ell =1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t)$. </span>
<span id="cb20-92"><a href="#cb20-92" aria-hidden="true" tabindex="-1"></a>The regression function $f$ verifies the following assumption:</span>
<span id="cb20-93"><a href="#cb20-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-94"><a href="#cb20-94" aria-hidden="true" tabindex="-1"></a>::: {#def-ass-regression_finite}</span>
<span id="cb20-95"><a href="#cb20-95" aria-hidden="true" tabindex="-1"></a>The function $f$ belongs to the space $\mathcal{S}^{L^*}$ of dimension $L^*$. It is denoted ${f}^{L^*}$ and defined as:</span>
<span id="cb20-96"><a href="#cb20-96" aria-hidden="true" tabindex="-1"></a>$$f(t) = {f}^{L^*}(t) = \sum_{\ell = 1}^{L^*} \mu_\ell^{L^*} B^{L^*}_\ell(t). $$</span>
<span id="cb20-97"><a href="#cb20-97" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-98"><a href="#cb20-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-99"><a href="#cb20-99" aria-hidden="true" tabindex="-1"></a>Many functional spaces are available in the literature, as Splines, Fourier or Legendre families. </span>
<span id="cb20-100"><a href="#cb20-100" aria-hidden="true" tabindex="-1"></a>Let us consider the space $L^2(<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>)$ with its standard scalar product $&lt;f_1,f_2&gt; = \int_0^1 |f_1(t)f_2(t)|dt$, for $f_1,f_2 \in L^2(<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>)$. We introduce the following assumption:</span>
<span id="cb20-101"><a href="#cb20-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-102"><a href="#cb20-102" aria-hidden="true" tabindex="-1"></a>::: {#def-ass-orth}</span>
<span id="cb20-103"><a href="#cb20-103" aria-hidden="true" tabindex="-1"></a>The functional family $(t \mapsto B^{L^*}_\ell(t))_{1\leq \ell\leq L^*}$ is orthonormal with respect to the standard scalar product $&lt;.,.&gt;$. </span>
<span id="cb20-104"><a href="#cb20-104" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-105"><a href="#cb20-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-106"><a href="#cb20-106" aria-hidden="true" tabindex="-1"></a>Note that if @def-ass-orth holds, one get $\mu_\ell^{L^*} = &lt;{f}^{L^*},B^{L^*}_\ell&gt;$ for $\ell = 1,\ldots, L^*$. </span>
<span id="cb20-107"><a href="#cb20-107" aria-hidden="true" tabindex="-1"></a>The Legendre family is orthonormal, the Fourier family is orthogonal for the standard scalar product (but not orthonormal), and the B-splines family is not orthogonal. </span>
<span id="cb20-108"><a href="#cb20-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-109"><a href="#cb20-109" aria-hidden="true" tabindex="-1"></a>We also consider  a functional noise through the following assumption. </span>
<span id="cb20-110"><a href="#cb20-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-111"><a href="#cb20-111" aria-hidden="true" tabindex="-1"></a>::: {#def-ass-noise-spline}</span>
<span id="cb20-112"><a href="#cb20-112" aria-hidden="true" tabindex="-1"></a>The sequence $\varepsilon_{i}$ is functional and belongs to the functional space $\mathcal{S}^{L^\varepsilon}$ of dimension $L^\varepsilon$. Then, there exists a sequence of coefficients $(c_{i\ell})_{1\leq \ell\leq L^\varepsilon}$ such that</span>
<span id="cb20-113"><a href="#cb20-113" aria-hidden="true" tabindex="-1"></a>$$\varepsilon_{ij} = \sum_{\ell = 1}^{L^\varepsilon} c_{i\ell} B_\ell^{L^\varepsilon}(t_{j}).$$</span>
<span id="cb20-114"><a href="#cb20-114" aria-hidden="true" tabindex="-1"></a>We also assume that the coefficients are Gaussian: for all $i=1,\ldots, N$ and $\ell=1, \ldots, L^\varepsilon$,</span>
<span id="cb20-115"><a href="#cb20-115" aria-hidden="true" tabindex="-1"></a>$$c_{i \ell} \sim_{iid} \mathcal{N}(0,\sigma^2).$$ </span>
<span id="cb20-116"><a href="#cb20-116" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-117"><a href="#cb20-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-118"><a href="#cb20-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-119"><a href="#cb20-119" aria-hidden="true" tabindex="-1"></a>@def-ass-regression_finite and @def-ass-noise-spline imply that each curve $y_i$ belongs to a finite family: for $j=1,\ldots,n$,</span>
<span id="cb20-120"><a href="#cb20-120" aria-hidden="true" tabindex="-1"></a>$$ y_{ij} = \sum_{\ell=1}^{L^*} \mu_{\ell}^{L^*} B_\ell^{L^*}(t_{j}) + \sum_{\ell=1}^{L^\varepsilon} c_{i\ell} B_\ell^{L^\varepsilon}(t_{j}). $$</span>
<span id="cb20-121"><a href="#cb20-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-122"><a href="#cb20-122" aria-hidden="true" tabindex="-1"></a>As the observations are recorded at discrete time points $(t_j)_{1\leq j \leq n}$, we introduce the family of functions evaluated at the discrete times of observations. For $L\in \mathbb{N}$, let us denote $\mathbf{B}^L$ the matrix of $n\times L$ with coefficient in row $j$ and column $\ell$ equal to $B^L_\ell(t_{j})$. </span>
<span id="cb20-123"><a href="#cb20-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-124"><a href="#cb20-124" aria-hidden="true" tabindex="-1"></a>Let us introduce $c_{i.}=(c_{i1}, \ldots, c_{iL^\varepsilon})$ the $L^\varepsilon \times 1$ vector. Then $\varepsilon_{i.} = \mathbf{B}^{L^\varepsilon} c_{i.}$. </span>
<span id="cb20-125"><a href="#cb20-125" aria-hidden="true" tabindex="-1"></a>The vectors $y_{i.} \in \mathbb{R}^n$ are thus independent and $y_i\sim \mathcal{N}_n(f(t_{.}), \sigma^2 \Sigma^{L^\varepsilon})$ with $\Sigma^{L^\varepsilon} = \mathbf{B}^{L^\varepsilon} (\mathbf{B}^{L^\varepsilon})^T$.</span>
<span id="cb20-126"><a href="#cb20-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-127"><a href="#cb20-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-128"><a href="#cb20-128" aria-hidden="true" tabindex="-1"></a>To illustrate the model, we simulate a regression functional model with $n=50$ points per individual and $N=40$ individuals. In  @fig-BasisModel, the function $f$ (red curve) belongs to the Fourier (resp. Legendre and Spline) family with $L^*=10$ and the noisy observations $y_{ij}$ (black curves) have a functional noise in dimension $L^{\varepsilon}=20$, also in the Fourier (resp. Legendre and Spline) family on the left plot (resp. middle and right). </span>
<span id="cb20-129"><a href="#cb20-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-130"><a href="#cb20-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-131"><a href="#cb20-131" aria-hidden="true" tabindex="-1"></a><span class="in">```{r message=FALSE, fig.height=3, fig.width=7}</span></span>
<span id="cb20-132"><a href="#cb20-132" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-BasisModel</span></span>
<span id="cb20-133"><a href="#cb20-133" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. We generate a regression functional model in the Fourier (left), Legendre (middle) and Splines (right) families. The red curve corresponds to the true function, and the gray curves correspond to noisy observations."</span></span>
<span id="cb20-134"><a href="#cb20-134" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb20-135"><a href="#cb20-135" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fda)</span>
<span id="cb20-136"><a href="#cb20-136" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(orthopolynom)</span>
<span id="cb20-137"><a href="#cb20-137" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(wavelets)</span>
<span id="cb20-138"><a href="#cb20-138" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(basefun)</span>
<span id="cb20-139"><a href="#cb20-139" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fields)</span>
<span id="cb20-140"><a href="#cb20-140" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggpubr)</span>
<span id="cb20-141"><a href="#cb20-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-142"><a href="#cb20-142" aria-hidden="true" tabindex="-1"></a>func.basis <span class="ot">=</span> <span class="cf">function</span>(time, L, basis){</span>
<span id="cb20-143"><a href="#cb20-143" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Splines'</span>){</span>
<span id="cb20-144"><a href="#cb20-144" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">bsplineS</span>(time,<span class="at">breaks =</span> <span class="fu">seq</span>(<span class="fu">min</span>(time), <span class="fu">max</span>(time), <span class="at">length.out =</span> L<span class="dv">-1</span>), <span class="at">norder =</span> <span class="dv">3</span>, <span class="dv">0</span>) </span>
<span id="cb20-145"><a href="#cb20-145" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb20-146"><a href="#cb20-146" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">fourier</span>(time,<span class="at">nbasis =</span> L) </span>
<span id="cb20-147"><a href="#cb20-147" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Legendre'</span>){</span>
<span id="cb20-148"><a href="#cb20-148" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">Legendre_basis</span>(<span class="fu">numeric_var</span>(<span class="st">"x"</span>, <span class="at">support =</span> <span class="fu">c</span>(<span class="fu">min</span>(time), <span class="fu">max</span>(time))), </span>
<span id="cb20-149"><a href="#cb20-149" aria-hidden="true" tabindex="-1"></a>                       <span class="at">order =</span> L<span class="dv">-1</span>)(time)</span>
<span id="cb20-150"><a href="#cb20-150" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-151"><a href="#cb20-151" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(B)</span>
<span id="cb20-152"><a href="#cb20-152" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-153"><a href="#cb20-153" aria-hidden="true" tabindex="-1"></a>dgp <span class="ot">=</span> <span class="cf">function</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> <span class="st">'Fourier'</span>, <span class="at">f.true =</span> <span class="cn">NULL</span>){ </span>
<span id="cb20-154"><a href="#cb20-154" aria-hidden="true" tabindex="-1"></a>  <span class="do">### n: number of timepoints</span></span>
<span id="cb20-155"><a href="#cb20-155" aria-hidden="true" tabindex="-1"></a>  <span class="do">### N: number of individuals</span></span>
<span id="cb20-156"><a href="#cb20-156" aria-hidden="true" tabindex="-1"></a>  <span class="do">### sd: noise level (standard deviation)</span></span>
<span id="cb20-157"><a href="#cb20-157" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb20-158"><a href="#cb20-158" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L.eps: number of functional basis for the noise</span></span>
<span id="cb20-159"><a href="#cb20-159" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha.mu: vector of coefficients</span></span>
<span id="cb20-160"><a href="#cb20-160" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Legendre', 'Fourier', 'Splines'</span></span>
<span id="cb20-161"><a href="#cb20-161" aria-hidden="true" tabindex="-1"></a>  <span class="do">### f.true: if one wants to fix the true function</span></span>
<span id="cb20-162"><a href="#cb20-162" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length.out =</span> n)</span>
<span id="cb20-163"><a href="#cb20-163" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-164"><a href="#cb20-164" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb20-165"><a href="#cb20-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L.star<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L.star <span class="ot">=</span> L.star<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb20-166"><a href="#cb20-166" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L.eps<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L.eps <span class="ot">=</span> L.eps<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb20-167"><a href="#cb20-167" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-168"><a href="#cb20-168" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-169"><a href="#cb20-169" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(f.true)){</span>
<span id="cb20-170"><a href="#cb20-170" aria-hidden="true" tabindex="-1"></a>    <span class="do">### Create the functional basis </span></span>
<span id="cb20-171"><a href="#cb20-171" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L.star, basis)</span>
<span id="cb20-172"><a href="#cb20-172" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-173"><a href="#cb20-173" aria-hidden="true" tabindex="-1"></a>    <span class="do">### Generate randomly coefficients, if needed</span></span>
<span id="cb20-174"><a href="#cb20-174" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(alpha.mu)){</span>
<span id="cb20-175"><a href="#cb20-175" aria-hidden="true" tabindex="-1"></a>      alpha.mu <span class="ot">=</span> <span class="fu">sample</span>(<span class="at">x =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">5</span><span class="sc">:-</span><span class="dv">2</span>, <span class="dv">2</span><span class="sc">:</span><span class="dv">5</span>),<span class="at">size=</span>L.star,<span class="at">replace=</span><span class="cn">TRUE</span>)} </span>
<span id="cb20-176"><a href="#cb20-176" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb20-177"><a href="#cb20-177" aria-hidden="true" tabindex="-1"></a>      alpha.mu <span class="ot">=</span> alpha.mu <span class="sc">/</span> <span class="dv">3</span></span>
<span id="cb20-178"><a href="#cb20-178" aria-hidden="true" tabindex="-1"></a>      sd <span class="ot">=</span> sd<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb20-179"><a href="#cb20-179" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-180"><a href="#cb20-180" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow =</span> N, <span class="at">ncol =</span> n)</span>
<span id="cb20-181"><a href="#cb20-181" aria-hidden="true" tabindex="-1"></a>    f.true <span class="ot">=</span> B <span class="sc">%*%</span> alpha.mu</span>
<span id="cb20-182"><a href="#cb20-182" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-183"><a href="#cb20-183" aria-hidden="true" tabindex="-1"></a>  B.eps <span class="ot">=</span> <span class="fu">func.basis</span>(time, L.eps, basis)</span>
<span id="cb20-184"><a href="#cb20-184" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>,<span class="at">nrow =</span> N, <span class="at">ncol =</span> n)</span>
<span id="cb20-185"><a href="#cb20-185" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb20-186"><a href="#cb20-186" aria-hidden="true" tabindex="-1"></a>    y[i,] <span class="ot">=</span> f.true <span class="sc">+</span> B.eps <span class="sc">%*%</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(L.eps, <span class="dv">0</span>, sd))</span>
<span id="cb20-187"><a href="#cb20-187" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-188"><a href="#cb20-188" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">y =</span> <span class="fu">t</span>(y), <span class="at">alpha.mu =</span> alpha.mu, <span class="at">time =</span> time, <span class="at">L.star=</span>L.star, <span class="at">f.true =</span> f.true))</span>
<span id="cb20-189"><a href="#cb20-189" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-190"><a href="#cb20-190" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-191"><a href="#cb20-191" aria-hidden="true" tabindex="-1"></a>n<span class="ot">=</span><span class="dv">50</span></span>
<span id="cb20-192"><a href="#cb20-192" aria-hidden="true" tabindex="-1"></a>N<span class="ot">=</span><span class="dv">40</span></span>
<span id="cb20-193"><a href="#cb20-193" aria-hidden="true" tabindex="-1"></a>sd<span class="ot">=</span><span class="dv">1</span></span>
<span id="cb20-194"><a href="#cb20-194" aria-hidden="true" tabindex="-1"></a>L.star<span class="ot">=</span><span class="dv">11</span></span>
<span id="cb20-195"><a href="#cb20-195" aria-hidden="true" tabindex="-1"></a>L.eps <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb20-196"><a href="#cb20-196" aria-hidden="true" tabindex="-1"></a>alpha.mu <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb20-197"><a href="#cb20-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-198"><a href="#cb20-198" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-199"><a href="#cb20-199" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb20-200"><a href="#cb20-200" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-201"><a href="#cb20-201" aria-hidden="true" tabindex="-1"></a>dfLegendre <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb20-202"><a href="#cb20-202" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-203"><a href="#cb20-203" aria-hidden="true" tabindex="-1"></a>                         <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>f.true),</span>
<span id="cb20-204"><a href="#cb20-204" aria-hidden="true" tabindex="-1"></a>                         <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb20-205"><a href="#cb20-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-206"><a href="#cb20-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-207"><a href="#cb20-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-208"><a href="#cb20-208" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Fourier"</span></span>
<span id="cb20-209"><a href="#cb20-209" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-210"><a href="#cb20-210" aria-hidden="true" tabindex="-1"></a>dfFourier <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb20-211"><a href="#cb20-211" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-212"><a href="#cb20-212" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>f.true),</span>
<span id="cb20-213"><a href="#cb20-213" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb20-214"><a href="#cb20-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-215"><a href="#cb20-215" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb20-216"><a href="#cb20-216" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>n,<span class="at">N=</span>N,<span class="at">sd=</span>sd,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> L.eps, <span class="at">alpha.mu =</span> alpha.mu, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-217"><a href="#cb20-217" aria-hidden="true" tabindex="-1"></a>dfSplines <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,N<span class="sc">+</span><span class="dv">1</span>),</span>
<span id="cb20-218"><a href="#cb20-218" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, (N<span class="sc">+</span><span class="dv">1</span>)<span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-219"><a href="#cb20-219" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y,data<span class="sc">$</span>f.true),</span>
<span id="cb20-220"><a href="#cb20-220" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="st">"obs"</span>, N), <span class="st">"True"</span>), <span class="at">each =</span> n), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(N<span class="sc">+</span><span class="dv">1</span>), <span class="at">each =</span> n))</span>
<span id="cb20-221"><a href="#cb20-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-222"><a href="#cb20-222" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">rbind</span>(dfLegendre, dfFourier, dfSplines)</span>
<span id="cb20-223"><a href="#cb20-223" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> df, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">color =</span> type, <span class="at">group =</span> ind)) <span class="sc">+</span> </span>
<span id="cb20-224"><a href="#cb20-224" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb20-225"><a href="#cb20-225" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_colour_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"obs"</span> <span class="ot">=</span> <span class="st">"lightgrey"</span>,<span class="st">"True"</span> <span class="ot">=</span> <span class="st">"red"</span>)) <span class="sc">+</span></span>
<span id="cb20-226"><a href="#cb20-226" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-227"><a href="#cb20-227" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-228"><a href="#cb20-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-229"><a href="#cb20-229" aria-hidden="true" tabindex="-1"></a>The objective of this paper is to construct a tight confidence bound for $f^{L^*}$ using data $(y_{ij})_{ij}$. </span>
<span id="cb20-230"><a href="#cb20-230" aria-hidden="true" tabindex="-1"></a>The main challenge is that the true dimension $L^*$ is unknown. In the rest of the paper, we will work with a collection of models defined on a finite family of dimension $L$ with $L\in \{L_{\min}, \ldots, L_{\max}\}$, $L_{\max}$ being chosen to be sufficiently large by  the user, expecting that $L^*\leq L_{\max}$. Then we will propose different strategies to choose the best bandwidths among the different collections. </span>
<span id="cb20-231"><a href="#cb20-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-232"><a href="#cb20-232" aria-hidden="true" tabindex="-1"></a>First,  in @sec-projection_model and @sec-estim, we define for a fixed $L$ the corresponding regression model and its estimator. Then @sec-bandSun,  @sec-band2  and @sec-modsel  will introduce the different bandwidths. </span>
<span id="cb20-233"><a href="#cb20-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-234"><a href="#cb20-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-235"><a href="#cb20-235" aria-hidden="true" tabindex="-1"></a><span class="fu">## Approximation of the model on a finite family {#sec-projection_model}</span></span>
<span id="cb20-236"><a href="#cb20-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-237"><a href="#cb20-237" aria-hidden="true" tabindex="-1"></a>Let $f^{L^*} \in \mathcal{S}^{L^*}$ with $L^*$ unknown, and consider the space $\mathcal{S}^L$ for $L\in <span class="sc">\{</span>1, \ldots, L_{\max}<span class="sc">\}</span>$ fixed. </span>
<span id="cb20-238"><a href="#cb20-238" aria-hidden="true" tabindex="-1"></a>As $\mathcal{S}^L$ is a  family of linearly independent functions, there always exists a unique vector $\mu^{L,L^*}$ of coefficients defining $f^{L,L^*}(t) = \sum_{\ell_=1}^L \mu_\ell^{L,L^*} B_\ell^L(t)=B^L(t) \mu^{L,L^*}$ such that</span>
<span id="cb20-239"><a href="#cb20-239" aria-hidden="true" tabindex="-1"></a>$$f^{L,L^*} = \arg\min_{f \in \mathcal{S}^L}\{\|f^{L^*} - f\|_2^2<span class="sc">\}</span>,$$</span>
<span id="cb20-240"><a href="#cb20-240" aria-hidden="true" tabindex="-1"></a>and </span>
<span id="cb20-241"><a href="#cb20-241" aria-hidden="true" tabindex="-1"></a>if the family is orthonormal (@def-ass-orth), it corresponds to the projected coefficients </span>
<span id="cb20-242"><a href="#cb20-242" aria-hidden="true" tabindex="-1"></a>$\mu_{\ell}^{L,L^*}$: </span>
<span id="cb20-243"><a href="#cb20-243" aria-hidden="true" tabindex="-1"></a>$$\mu_{\ell}^{L,L^*} :=&lt;f^{L^*}, B_\ell^L&gt;.$$</span>
<span id="cb20-244"><a href="#cb20-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-245"><a href="#cb20-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-246"><a href="#cb20-246" aria-hidden="true" tabindex="-1"></a>We can prove the following property:</span>
<span id="cb20-247"><a href="#cb20-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-248"><a href="#cb20-248" aria-hidden="true" tabindex="-1"></a>::: {#prp-proj}</span>
<span id="cb20-249"><a href="#cb20-249" aria-hidden="true" tabindex="-1"></a>Under @def-ass-regression_finite, </span>
<span id="cb20-250"><a href="#cb20-250" aria-hidden="true" tabindex="-1"></a>$$f^{L^*,L^*} = f^{L^*}.$$</span>
<span id="cb20-251"><a href="#cb20-251" aria-hidden="true" tabindex="-1"></a>Moreover, if @def-ass-orth also holds, the projection coefficients verify</span>
<span id="cb20-252"><a href="#cb20-252" aria-hidden="true" tabindex="-1"></a>$$\mu_{\ell}^{L,L^*} = \mu_\ell^{L^*} \quad{ for }\; \ell =1, \ldots, \min(L, L^{*}).$$</span>
<span id="cb20-253"><a href="#cb20-253" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-254"><a href="#cb20-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-255"><a href="#cb20-255" aria-hidden="true" tabindex="-1"></a>In practice, data are observed at discrete time, we consider the operator $\mathbf{P}^L$ defined as the  matrix $\mathbf{P}^L = ((\mathbf{B}^L)^T \mathbf{B}^L)^{-1} (\mathbf{B}^L)^T$ of size $L\times n$ (this operator is a bit more complex when the functional family is not orthonormal wrt the standard scalar product). </span>
<span id="cb20-256"><a href="#cb20-256" aria-hidden="true" tabindex="-1"></a>Then we define the coefficients $\underline{\mu}^{L,L^*}$ which are the coefficients of ${\mu}^{L,L^*}$ approximated on the vector space, denoted $\mathbf{S}^L$, defined by the matrix $\mathbf{B}^L$. </span>
<span id="cb20-257"><a href="#cb20-257" aria-hidden="true" tabindex="-1"></a>$$\underline{\mu}^{L,L^*} := \mathbf{P}^L \mathbf{B}^{L^*}\mu^{L^*}.$$</span>
<span id="cb20-258"><a href="#cb20-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-259"><a href="#cb20-259" aria-hidden="true" tabindex="-1"></a>The corresponding finite approximated regression function is denoted $\underline{f}^{L,L^*}$ and is defined, for all $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, as </span>
<span id="cb20-260"><a href="#cb20-260" aria-hidden="true" tabindex="-1"></a>$$\underline{f}^{L,L^*}(t) = B^L(t) \underline{\mu}^{L,L^*}.$$</span>
<span id="cb20-261"><a href="#cb20-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-262"><a href="#cb20-262" aria-hidden="true" tabindex="-1"></a>We can prove the following properties linking $L, L^*$ and the number of timepoints $n$:</span>
<span id="cb20-263"><a href="#cb20-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-264"><a href="#cb20-264" aria-hidden="true" tabindex="-1"></a>::: {#prp-proj2}</span>
<span id="cb20-265"><a href="#cb20-265" aria-hidden="true" tabindex="-1"></a>Under @def-ass-regression_finite and @def-ass-orth, </span>
<span id="cb20-266"><a href="#cb20-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-267"><a href="#cb20-267" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L\geq L^*$, $\mathbf{P}^L \mathbf{B}^{L^*}$ has $L^*$ diagonal elements equal to 1 and other non-diagonal elements close to 0.</span>
<span id="cb20-268"><a href="#cb20-268" aria-hidden="true" tabindex="-1"></a>The first $L^*$ elements of $\underline{\mu}^{L,L^*}$ are equal to $\mu^{L^*}$ when $n&gt;L$.</span>
<span id="cb20-269"><a href="#cb20-269" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L&lt;L^*$, $\mathbf{P}^L\mathbf{B}^{L^*}$ has $L$ diagonal elements equal to 1.</span>
<span id="cb20-270"><a href="#cb20-270" aria-hidden="true" tabindex="-1"></a>The first $L$ elements of $\underline{\mu}^{L,L^*}$ are different to $\mu_\ell^{L^*}$. When $n\rightarrow\infty$, $\underline{\mu}_\ell^{L,L^*}\rightarrow \mu_\ell^{L^*}$ for $\ell = 1,\ldots, \min(L,L^*)$.</span>
<span id="cb20-271"><a href="#cb20-271" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>If $n&gt;L^*$, then $f^{L^*} = f^{L^*,L^*} = \underline{f}^{L^*,L^*}$. </span>
<span id="cb20-272"><a href="#cb20-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-273"><a href="#cb20-273" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-274"><a href="#cb20-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-275"><a href="#cb20-275" aria-hidden="true" tabindex="-1"></a>These properties are illustrated in @fig-coefficients. The true dimension is $L^*=11$. Three families are considered,  Fourier, Legendre and Splines. The plots display the absolute difference between the coefficients $\mu_\ell^{L^*}$ and the projected coefficients $\underline{\mu}^{L,L^*}$, for different $\ell$ in x-axis and for different values of $L$ and $n$ of the y-axis, namely a case with $L&lt;L^*$ and two values of $n$: $L=7, n=20$ and $L=7, n=100$; and a case with $L&gt;L^*$ and two values of $n$: $L=15, n=20$ and $L=15, n=100$. The absolute difference is represented as a gradient of color, this gradient being adapted for each functional family. We can see that as Legendre (resp. Fourier) are orthonormal (resp. orthogonal) families, the differences are close to $0$ when $L=15$, whatever the values of $n$. When $L&lt;L^*$, the difference is close to $0$ when $n$ is large. </span>
<span id="cb20-276"><a href="#cb20-276" aria-hidden="true" tabindex="-1"></a>This property does not hold for the spline family, which is not orthogonal. </span>
<span id="cb20-277"><a href="#cb20-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-278"><a href="#cb20-278" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height=7, fig.width=7}</span></span>
<span id="cb20-279"><a href="#cb20-279" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-coefficients</span></span>
<span id="cb20-280"><a href="#cb20-280" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. The true dimension is 11, we generate the coefficients with three families,  Fourier (which is orthogonal), Legendre (which is orthonormal) and the splines (which are not orthogonal wrt the standard scalar product). In the y-axis, two dimensions of the family  (7 or 15) and two numbers of timepoints (20 or 100) are compared. We plot in x-axis the value of the absolute difference between the true coefficients and their approximations for the first 7 coefficients of the basis. The color scale is adapted to each functional basis. "</span></span>
<span id="cb20-281"><a href="#cb20-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-282"><a href="#cb20-282" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-283"><a href="#cb20-283" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(RColorBrewer)</span>
<span id="cb20-284"><a href="#cb20-284" aria-hidden="true" tabindex="-1"></a>cols <span class="ot">=</span> <span class="fu">brewer.pal</span>(<span class="dv">9</span>, <span class="st">"BuPu"</span>)</span>
<span id="cb20-285"><a href="#cb20-285" aria-hidden="true" tabindex="-1"></a>pal <span class="ot">&lt;-</span> <span class="fu">colorRampPalette</span>(cols)</span>
<span id="cb20-286"><a href="#cb20-286" aria-hidden="true" tabindex="-1"></a>L.star <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb20-287"><a href="#cb20-287" aria-hidden="true" tabindex="-1"></a>Time <span class="ot">=</span> <span class="fu">seq</span>(data<span class="sc">$</span>time[<span class="dv">1</span>], data<span class="sc">$</span>time[<span class="fu">length</span>(data<span class="sc">$</span>time)], <span class="at">length.out =</span> <span class="dv">100</span>)</span>
<span id="cb20-288"><a href="#cb20-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-289"><a href="#cb20-289" aria-hidden="true" tabindex="-1"></a>L.star <span class="ot">=</span> <span class="dv">11</span></span>
<span id="cb20-290"><a href="#cb20-290" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">7</span>,<span class="dv">15</span>)</span>
<span id="cb20-291"><a href="#cb20-291" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">1</span>))</span>
<span id="cb20-292"><a href="#cb20-292" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Fourier"</span>, <span class="st">"Legendre"</span>,  <span class="st">"Splines"</span>)){</span>
<span id="cb20-293"><a href="#cb20-293" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">20</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span>L.star, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-294"><a href="#cb20-294" aria-hidden="true" tabindex="-1"></a>  alpha.tot <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-295"><a href="#cb20-295" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-296"><a href="#cb20-296" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-297"><a href="#cb20-297" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb20-298"><a href="#cb20-298" aria-hidden="true" tabindex="-1"></a>    B.n.large <span class="ot">=</span> <span class="fu">func.basis</span>(Time, L, basis)</span>
<span id="cb20-299"><a href="#cb20-299" aria-hidden="true" tabindex="-1"></a>    B.Lstar.n.large <span class="ot">=</span> <span class="fu">func.basis</span>(Time, L.star, basis)</span>
<span id="cb20-300"><a href="#cb20-300" aria-hidden="true" tabindex="-1"></a>    alpha.true.L <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true</span>
<span id="cb20-301"><a href="#cb20-301" aria-hidden="true" tabindex="-1"></a>    alpha.true.L.n.large <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.n.large) <span class="sc">%*%</span> B.n.large) <span class="sc">%*%</span> <span class="fu">t</span>(B.n.large) <span class="sc">%*%</span> B.Lstar.n.large <span class="sc">%*%</span> data<span class="sc">$</span>alpha.mu</span>
<span id="cb20-302"><a href="#cb20-302" aria-hidden="true" tabindex="-1"></a>    alpha.tot <span class="ot">=</span> <span class="fu">cbind</span>(alpha.tot, alpha.true.L[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))]<span class="sc">-</span>data<span class="sc">$</span>alpha.mu[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))], alpha.true.L.n.large[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))] <span class="sc">-</span> data<span class="sc">$</span>alpha.mu[<span class="dv">1</span><span class="sc">:</span><span class="fu">min</span>(<span class="fu">c</span>(L.star, vec.L))])</span>
<span id="cb20-303"><a href="#cb20-303" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-304"><a href="#cb20-304" aria-hidden="true" tabindex="-1"></a>  <span class="fu">image.plot</span>(<span class="fu">abs</span>(alpha.tot), <span class="at">main =</span> <span class="fu">paste0</span>(basis, <span class="st">"'s basis"</span>), <span class="at">col =</span> <span class="fu">pal</span>(<span class="dv">20</span>), <span class="at">yaxt=</span><span class="st">"n"</span>, <span class="at">xaxt =</span> <span class="st">"n"</span>, <span class="at">xlab =</span> <span class="st">"index of the basis"</span> )</span>
<span id="cb20-305"><a href="#cb20-305" aria-hidden="true" tabindex="-1"></a>  <span class="fu">axis</span>(<span class="dv">2</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="at">length =</span> <span class="fu">ncol</span>(alpha.tot)), <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"L=7, n=20"</span>, <span class="st">"L=7, n=100"</span>, <span class="st">"L=15, n=20"</span>, <span class="st">"L=15, n=100"</span>), <span class="at">las =</span> <span class="dv">2</span>, <span class="at">cex.axis =</span> <span class="fl">0.7</span>)</span>
<span id="cb20-306"><a href="#cb20-306" aria-hidden="true" tabindex="-1"></a>  <span class="fu">axis</span>(<span class="dv">1</span>, <span class="at">at =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">length.out =</span> <span class="dv">7</span>), <span class="at">labels =</span> <span class="fu">c</span>(<span class="st">"1"</span>, <span class="st">"2"</span>, <span class="st">"3"</span>, <span class="st">"4"</span>, <span class="st">"5"</span>, <span class="st">"6"</span>, <span class="st">"7"</span>))</span>
<span id="cb20-307"><a href="#cb20-307" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-308"><a href="#cb20-308" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-309"><a href="#cb20-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-310"><a href="#cb20-310" aria-hidden="true" tabindex="-1"></a><span class="fu">## Estimator {#sec-estim}</span></span>
<span id="cb20-311"><a href="#cb20-311" aria-hidden="true" tabindex="-1"></a>Let  $L\in <span class="sc">\{</span>L_{\min}, \ldots, L_{\max}<span class="sc">\}</span>$. </span>
<span id="cb20-312"><a href="#cb20-312" aria-hidden="true" tabindex="-1"></a>This section presents the least square estimator of the regression function on the space of dimension $L$ defined by the family $\mathbf{B}^L$ and discusses its error.</span>
<span id="cb20-313"><a href="#cb20-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-314"><a href="#cb20-314" aria-hidden="true" tabindex="-1"></a><span class="fu">### Estimation of the regression function</span></span>
<span id="cb20-315"><a href="#cb20-315" aria-hidden="true" tabindex="-1"></a>When considering the estimation of the regression function $f^{L^*}$ on the space of dimension $L$ defined by the family $\mathbf{B}^L$, we do not directly estimate $f^{L^*}$ but its projection on this finite space, which corresponds to the projected function $\underline{f}^{L,L^*}(t)$ and its associated coefficients $(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}$. </span>
<span id="cb20-316"><a href="#cb20-316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-317"><a href="#cb20-317" aria-hidden="true" tabindex="-1"></a>::: {#def-proj2}</span>
<span id="cb20-318"><a href="#cb20-318" aria-hidden="true" tabindex="-1"></a>The vector of coefficients $(\underline{\mu}_\ell^{L,L^*})_{1 \leq \ell \leq L}$ is estimated by the least square estimator $\hat{\underline{\mu}}^{L, L^*}$ defined as:</span>
<span id="cb20-319"><a href="#cb20-319" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-320"><a href="#cb20-320" aria-hidden="true" tabindex="-1"></a>\hat{\underline{\mu}}^{L, L^*}:=\frac1N \sum_{i=1}^N</span>
<span id="cb20-321"><a href="#cb20-321" aria-hidden="true" tabindex="-1"></a>\mathbf{P}^L y_{i.}.</span>
<span id="cb20-322"><a href="#cb20-322" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-323"><a href="#cb20-323" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-324"><a href="#cb20-324" aria-hidden="true" tabindex="-1"></a>For a fixed $t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, the estimator of the function $\underline{f}^{L,L^*}(t)$ is defined by:</span>
<span id="cb20-325"><a href="#cb20-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-326"><a href="#cb20-326" aria-hidden="true" tabindex="-1"></a>$$ \underline{\hat{f}_{}}^{L,L^*}(t) = \sum_{\ell=1}^L \underline{\hat \mu}_\ell^{L,L^*} B^L_\ell(t)= B^L(t)\hat{\underline{\mu}}^{L,L^*}.</span>
<span id="cb20-327"><a href="#cb20-327" aria-hidden="true" tabindex="-1"></a>$$ {#eq-fhatL}</span>
<span id="cb20-328"><a href="#cb20-328" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-329"><a href="#cb20-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-330"><a href="#cb20-330" aria-hidden="true" tabindex="-1"></a>@eq-fhatL directly implies that the estimator is thus the empirical mean of the functional approximation of each individual vector of observations. </span>
<span id="cb20-331"><a href="#cb20-331" aria-hidden="true" tabindex="-1"></a>Because we work with least squares estimators, we can easily study the error of estimation of $\hat{\underline{\mu}}^{L, L^*}$ and $\underline{\hat{f}_{}}^{L,L^*}$. </span>
<span id="cb20-332"><a href="#cb20-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-333"><a href="#cb20-333" aria-hidden="true" tabindex="-1"></a>::: {#prp-error}</span>
<span id="cb20-334"><a href="#cb20-334" aria-hidden="true" tabindex="-1"></a>Under @def-ass-regression_finite and @def-ass-noise-spline, we have</span>
<span id="cb20-335"><a href="#cb20-335" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-336"><a href="#cb20-336" aria-hidden="true" tabindex="-1"></a>\hat{\underline{\mu}}^{L, L^*}</span>
<span id="cb20-337"><a href="#cb20-337" aria-hidden="true" tabindex="-1"></a>&amp;\sim \mathcal{N}_L\left(\underline{\mu}^{L, L^*}, \frac{\sigma^2}N\Sigma_{B}^{L,L^\varepsilon}</span>
<span id="cb20-338"><a href="#cb20-338" aria-hidden="true" tabindex="-1"></a>\right),</span>
<span id="cb20-339"><a href="#cb20-339" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-340"><a href="#cb20-340" aria-hidden="true" tabindex="-1"></a>where the $L\times L$ covariance matrix $\Sigma_{B}^{L,L^{\varepsilon}}$ is defined as </span>
<span id="cb20-341"><a href="#cb20-341" aria-hidden="true" tabindex="-1"></a>$\Sigma_{B}^{L,L^\varepsilon}:=\mathbf{P}^L \Sigma^{L^\varepsilon} (\mathbf{P}^L)^T$</span>
<span id="cb20-342"><a href="#cb20-342" aria-hidden="true" tabindex="-1"></a>with $\Sigma^{L^\varepsilon}= \mathbf{B}^{L^\varepsilon} (\mathbf{B}^{L^\varepsilon})^T$.</span>
<span id="cb20-343"><a href="#cb20-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-344"><a href="#cb20-344" aria-hidden="true" tabindex="-1"></a>Moreover, $B^L()\mathbf{P}^L y_i$ is a Gaussian process with mean $\underline{f}^{L,L^*}()$ and covariance function $(s,t) \mapsto \sigma^2 B^L(s) \Sigma_{B}^{L,L^\varepsilon} (B^L(t))^T$, and $(\underline{\hat{f}_{}}^{L,L^*}- \underline{f}^{L,L^*})()$ is a centered Gaussian process  with covariance function $C^{L,L^*}: (s,t) \mapsto \frac{\sigma^2}N B^L(s) \Sigma_{B}^{L,L^\varepsilon} B^L(t)^T$. </span>
<span id="cb20-345"><a href="#cb20-345" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-346"><a href="#cb20-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-347"><a href="#cb20-347" aria-hidden="true" tabindex="-1"></a>The proof is given in Appendix. </span>
<span id="cb20-348"><a href="#cb20-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-349"><a href="#cb20-349" aria-hidden="true" tabindex="-1"></a>@fig-estimatorL displays estimators calculated with different dimensions $L$. Data are generated with $L^*=11$, $L^\varepsilon=20$, $n=50$ and $N=40$. The true function and its projection $\underline f^{L,L^*}$  are in cyan, and the estimator $\underline{\hat{f}_{}}^{L,L^*}$ is in red.  We compute it for the three families, Legendre, Fourier and splines. </span>
<span id="cb20-350"><a href="#cb20-350" aria-hidden="true" tabindex="-1"></a>In all cases, the estimators are very precise when considering the relevant function, but estimating a function of dimension $L^*$ with a function of dimension $L&lt;L^*$ is not consistent. Note that the performance of the estimator for the spline family is also good, even if the family is not orthonormal, because we work here at the level of the function (and not at the level of the coefficients).  </span>
<span id="cb20-351"><a href="#cb20-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-352"><a href="#cb20-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-353"><a href="#cb20-353" aria-hidden="true" tabindex="-1"></a><span class="in">```{r , out.height = "50%", fig.width=7}</span></span>
<span id="cb20-354"><a href="#cb20-354" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-estimatorL</span></span>
<span id="cb20-355"><a href="#cb20-355" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For each family (Fourier which is orthogonal, Legendre which is orthonormal and the splines which are not orthogonal wrt the standard scalar product), we consider a function with true dimension 11 (top), and its projection on the space of dimension 5 (bottom), displayed in cyan.  The estimators in dimensions 11 and 5 are displayed in red."</span></span>
<span id="cb20-356"><a href="#cb20-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-357"><a href="#cb20-357" aria-hidden="true" tabindex="-1"></a>estimator <span class="ot">=</span> <span class="cf">function</span>(data, basis, L){</span>
<span id="cb20-358"><a href="#cb20-358" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb20-359"><a href="#cb20-359" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb20-360"><a href="#cb20-360" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb20-361"><a href="#cb20-361" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-362"><a href="#cb20-362" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb20-363"><a href="#cb20-363" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb20-364"><a href="#cb20-364" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-365"><a href="#cb20-365" aria-hidden="true" tabindex="-1"></a>  B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb20-366"><a href="#cb20-366" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-367"><a href="#cb20-367" aria-hidden="true" tabindex="-1"></a>  <span class="do">### Data projection</span></span>
<span id="cb20-368"><a href="#cb20-368" aria-hidden="true" tabindex="-1"></a>  Hi <span class="ot">=</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>y</span>
<span id="cb20-369"><a href="#cb20-369" aria-hidden="true" tabindex="-1"></a>  mu.hat <span class="ot">=</span> <span class="fu">rowMeans</span>(Hi)</span>
<span id="cb20-370"><a href="#cb20-370" aria-hidden="true" tabindex="-1"></a>  f.hat <span class="ot">=</span> <span class="fu">c</span>(B <span class="sc">%*%</span> mu.hat)</span>
<span id="cb20-371"><a href="#cb20-371" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> data</span>
<span id="cb20-372"><a href="#cb20-372" aria-hidden="true" tabindex="-1"></a>  data.proj<span class="sc">$</span>y <span class="ot">=</span> B <span class="sc">%*%</span> Hi</span>
<span id="cb20-373"><a href="#cb20-373" aria-hidden="true" tabindex="-1"></a>  cov.emp <span class="ot">=</span> <span class="fu">crossprod</span>(<span class="fu">t</span>(data.proj<span class="sc">$</span>y <span class="sc">-</span> f.hat)) <span class="sc">/</span> <span class="fu">ncol</span>(data.proj<span class="sc">$</span>y)</span>
<span id="cb20-374"><a href="#cb20-374" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-375"><a href="#cb20-375" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat=</span>f.hat, <span class="at">mu.hat =</span> mu.hat, <span class="at">cov.emp =</span> cov.emp, <span class="at">data.proj =</span> data.proj))</span>
<span id="cb20-376"><a href="#cb20-376" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-377"><a href="#cb20-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-378"><a href="#cb20-378" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-379"><a href="#cb20-379" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb20-380"><a href="#cb20-380" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-381"><a href="#cb20-381" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L=</span><span class="dv">5</span>, basis)</span>
<span id="cb20-382"><a href="#cb20-382" aria-hidden="true" tabindex="-1"></a>f.true.L5 <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb20-383"><a href="#cb20-383" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">5</span>)</span>
<span id="cb20-384"><a href="#cb20-384" aria-hidden="true" tabindex="-1"></a>est11 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">11</span>)</span>
<span id="cb20-385"><a href="#cb20-385" aria-hidden="true" tabindex="-1"></a>dfLegendre <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,<span class="dv">4</span>),</span>
<span id="cb20-386"><a href="#cb20-386" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">4</span><span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-387"><a href="#cb20-387" aria-hidden="true" tabindex="-1"></a>                         <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>f.true, <span class="fu">c</span>(f.true.L5), est5<span class="sc">$</span>f.hat, est11<span class="sc">$</span>f.hat),</span>
<span id="cb20-388"><a href="#cb20-388" aria-hidden="true" tabindex="-1"></a>                         <span class="at">L =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L = 11"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 11"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-389"><a href="#cb20-389" aria-hidden="true" tabindex="-1"></a>                         <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"True"</span>, <span class="st">"True"</span>, <span class="st">"Estimated"</span>, <span class="st">"Estimated"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)))</span>
<span id="cb20-390"><a href="#cb20-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-391"><a href="#cb20-391" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Fourier"</span></span>
<span id="cb20-392"><a href="#cb20-392" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-393"><a href="#cb20-393" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L=</span><span class="dv">5</span>, basis)</span>
<span id="cb20-394"><a href="#cb20-394" aria-hidden="true" tabindex="-1"></a>f.true.L5 <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb20-395"><a href="#cb20-395" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">5</span>)</span>
<span id="cb20-396"><a href="#cb20-396" aria-hidden="true" tabindex="-1"></a>est11 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">11</span>)</span>
<span id="cb20-397"><a href="#cb20-397" aria-hidden="true" tabindex="-1"></a>dfFourier <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,<span class="dv">4</span>),</span>
<span id="cb20-398"><a href="#cb20-398" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">4</span><span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-399"><a href="#cb20-399" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>f.true, <span class="fu">c</span>(f.true.L5), est5<span class="sc">$</span>f.hat, est11<span class="sc">$</span>f.hat),</span>
<span id="cb20-400"><a href="#cb20-400" aria-hidden="true" tabindex="-1"></a>                        <span class="at">L =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L = 11"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 11"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-401"><a href="#cb20-401" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"True"</span>, <span class="st">"True"</span>, <span class="st">"Estimated"</span>, <span class="st">"Estimated"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)))</span>
<span id="cb20-402"><a href="#cb20-402" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-403"><a href="#cb20-403" aria-hidden="true" tabindex="-1"></a>basis <span class="ot">=</span> <span class="st">"Splines"</span></span>
<span id="cb20-404"><a href="#cb20-404" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">11</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-405"><a href="#cb20-405" aria-hidden="true" tabindex="-1"></a>B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, <span class="at">L=</span><span class="dv">5</span>, basis)</span>
<span id="cb20-406"><a href="#cb20-406" aria-hidden="true" tabindex="-1"></a>f.true.L5 <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb20-407"><a href="#cb20-407" aria-hidden="true" tabindex="-1"></a>est5 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">5</span>)</span>
<span id="cb20-408"><a href="#cb20-408" aria-hidden="true" tabindex="-1"></a>est11 <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, <span class="at">L=</span><span class="dv">11</span>)</span>
<span id="cb20-409"><a href="#cb20-409" aria-hidden="true" tabindex="-1"></a>dfSplines <span class="ot">=</span> <span class="fu">data.frame</span>( <span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time,<span class="dv">4</span>),</span>
<span id="cb20-410"><a href="#cb20-410" aria-hidden="true" tabindex="-1"></a>                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">4</span><span class="sc">*</span><span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-411"><a href="#cb20-411" aria-hidden="true" tabindex="-1"></a>                        <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>f.true, <span class="fu">c</span>(f.true.L5), est5<span class="sc">$</span>f.hat, est11<span class="sc">$</span>f.hat),</span>
<span id="cb20-412"><a href="#cb20-412" aria-hidden="true" tabindex="-1"></a>                        <span class="at">L =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"L = 11"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 5"</span>, <span class="st">"L = 11"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-413"><a href="#cb20-413" aria-hidden="true" tabindex="-1"></a>                        <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"True"</span>, <span class="st">"True"</span>, <span class="st">"Estimated"</span>, <span class="st">"Estimated"</span>), <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time)))</span>
<span id="cb20-414"><a href="#cb20-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-415"><a href="#cb20-415" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">rbind</span>(dfLegendre, dfFourier, dfSplines)</span>
<span id="cb20-416"><a href="#cb20-416" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> df, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">color =</span> type)) <span class="sc">+</span> </span>
<span id="cb20-417"><a href="#cb20-417" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">linetype =</span> type), <span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb20-418"><a href="#cb20-418" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(L<span class="sc">~</span>basis)</span>
<span id="cb20-419"><a href="#cb20-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-420"><a href="#cb20-420" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-421"><a href="#cb20-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-422"><a href="#cb20-422" aria-hidden="true" tabindex="-1"></a>Even if the estimator $\underline{\hat{f}_{}}^{L,L^*}$ is defined on the functional space associated to $\mathbf{S}^L$, it can also be seen as an estimator of the function $f^{ L^*}$ which lies in the space $\mathcal{S}^{L^*}$. In that case, the error includes a functional approximation term due to the approximation of $f^{ L^*}$ on the space $\mathcal{S}^L$, which will be nonzero if $L\neq L^*$. It corresponding to the bias of the estimator $\underline{\hat{f}_{}}^{L,L^*}$, i.e. the difference between its expectation and the true $f^{ L^*}$. Indeed, recalling that $f^{L^*} = \underline{f}^{L^*,L^*}$, the error of estimation can be decomposed into</span>
<span id="cb20-423"><a href="#cb20-423" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-424"><a href="#cb20-424" aria-hidden="true" tabindex="-1"></a>\underline{\hat{f}}^{L, L^*}(t) -f^{L^*}(t) </span>
<span id="cb20-425"><a href="#cb20-425" aria-hidden="true" tabindex="-1"></a>= \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t) + \underline{f}^{L, L^*}(t) - \underline{f}^{L^*,L^*}(t) =: Stat_{L,L^*}(t) + Bias_{L,L^*}(t),</span>
<span id="cb20-426"><a href="#cb20-426" aria-hidden="true" tabindex="-1"></a>$$ {#eq-decomposition}</span>
<span id="cb20-427"><a href="#cb20-427" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-428"><a href="#cb20-428" aria-hidden="true" tabindex="-1"></a>The first term $Stat_{L,L^*}(t)  = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)$ is the (unrescaled) statistics of the model. The second term $Bias_{L,L^*}(t) = \mathbb{E}(\underline{\hat{f}}^{L, L^*}(t)) - \underline{f}^{L^*,L^*}(t)$ is the bias of the estimator $\underline{\hat{f}}^{L, L^*}(t)$ when estimating the true function $\underline{f}^{L^*,L^*}(t)$. </span>
<span id="cb20-429"><a href="#cb20-429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-430"><a href="#cb20-430" aria-hidden="true" tabindex="-1"></a>Let us remark that this bias is different than the bias of the estimator $\underline{\hat{f}}^{L, L^*}(t)$ when estimating the projected function $\underline{f}^{L,L^*}=f^{ L^*}$, which is 0.</span>
<span id="cb20-431"><a href="#cb20-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-432"><a href="#cb20-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-433"><a href="#cb20-433" aria-hidden="true" tabindex="-1"></a>The two terms defined in @eq-decomposition are more detailed in the two next subsections. </span>
<span id="cb20-434"><a href="#cb20-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-435"><a href="#cb20-435" aria-hidden="true" tabindex="-1"></a><span class="fu">### Statistics  </span></span>
<span id="cb20-436"><a href="#cb20-436" aria-hidden="true" tabindex="-1"></a>The statistics of the model, $t\mapsto Stat_{L,L^*}(t) = \underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)$,  is a random functional quantity which depends on the estimator $\underline{\hat{f}}^{L, L^*}$. From @prp-error,  for any $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$, we define the centered and rescale statistics $Z_L(t)$ such that: </span>
<span id="cb20-437"><a href="#cb20-437" aria-hidden="true" tabindex="-1"></a>$$Z_L(t):= \frac{Stat_{L,L^*}(t)}{\sqrt{\text{Var}(Stat_{L,L^*}(t))}} </span>
<span id="cb20-438"><a href="#cb20-438" aria-hidden="true" tabindex="-1"></a>= \frac{\underline{\hat{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)}{\sqrt{C^{L, L^*}(t,t)}}\sim \mathcal{N}(0,1). $$</span>
<span id="cb20-439"><a href="#cb20-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-440"><a href="#cb20-440" aria-hidden="true" tabindex="-1"></a>The covariance function can be estimated using the observations $y_{i.}$ as </span>
<span id="cb20-441"><a href="#cb20-441" aria-hidden="true" tabindex="-1"></a>$$\hat C^{L, L^*}(s,t) = \frac1{N-1}\sum_{i=1}^{N} (B^L(s)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(s))(B^L(t)\mathbf{P}^L y_{i.} - \underline{\hat{f}_{}}^{L,L^*}(t)).$$</span>
<span id="cb20-442"><a href="#cb20-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-443"><a href="#cb20-443" aria-hidden="true" tabindex="-1"></a><span class="fu">### Bias </span></span>
<span id="cb20-444"><a href="#cb20-444" aria-hidden="true" tabindex="-1"></a>The bias is due to the fact that the estimation is potentially performed in a different (finite) space than the space where the true function $\underline{f}^{L^*,L^*}$ lives. This is a functional bias, which is not random. It corresponds to the approximation (orthogonal projection if  @def-ass-orth holds) of $f^{L^*}$ from $\mathcal{S}^{L^*}$ to the space $\mathcal{S}^{L}$. It can be written as follows:</span>
<span id="cb20-445"><a href="#cb20-445" aria-hidden="true" tabindex="-1"></a>$$Bias_{L,L^*}(t) = B^L(t) \underline{\mu} ^{L,L^*} - B^{L^*}(t) \mu^{L^*}.$$</span>
<span id="cb20-446"><a href="#cb20-446" aria-hidden="true" tabindex="-1"></a>Thus, we can deduce that when $L&lt;L^*$ and if the family is orthonormal (@def-ass-orth holds),</span>
<span id="cb20-447"><a href="#cb20-447" aria-hidden="true" tabindex="-1"></a>$$Bias_{L,L^*}(t)= \sum_{\ell=1}^L B_\ell^L(t)\underline{\mu}_\ell^{L,L^*} - \sum_{\ell=1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*} = \sum_{\ell = L+1}^{L^*} B_\ell^{L^*}(t)\underline{\mu}_\ell^{L^*}.$$</span>
<span id="cb20-448"><a href="#cb20-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-449"><a href="#cb20-449" aria-hidden="true" tabindex="-1"></a>From @prp-error, we can directly deduce the following proposition:</span>
<span id="cb20-450"><a href="#cb20-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-451"><a href="#cb20-451" aria-hidden="true" tabindex="-1"></a>::: {#prp-bias}</span>
<span id="cb20-452"><a href="#cb20-452" aria-hidden="true" tabindex="-1"></a>Under @def-ass-regression_finite and @def-ass-noise-spline, the mean is, for all $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$,</span>
<span id="cb20-453"><a href="#cb20-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-454"><a href="#cb20-454" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>for $L&lt;L^*$, $Bias_{L,L^*}(t)\neq 0$,</span>
<span id="cb20-455"><a href="#cb20-455" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>for $L\geq L^*$, $Bias_{L,L^*}(t) = 0$.</span>
<span id="cb20-456"><a href="#cb20-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-457"><a href="#cb20-457" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-458"><a href="#cb20-458" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-459"><a href="#cb20-459" aria-hidden="true" tabindex="-1"></a>\bigskip</span>
<span id="cb20-460"><a href="#cb20-460" aria-hidden="true" tabindex="-1"></a>In the next section, we explain how to use this property to derive confidence bands of $\underline{f}^{L, L^*}$ and $f^{L, L^*}$. </span>
<span id="cb20-461"><a href="#cb20-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-462"><a href="#cb20-462" aria-hidden="true" tabindex="-1"></a><span class="fu"># Confidence Bands of $\underline{f}^{L, L^*}$ and $f^{L, L^*}$ for a fixed $L$ {#sec-bandSun}</span></span>
<span id="cb20-463"><a href="#cb20-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-464"><a href="#cb20-464" aria-hidden="true" tabindex="-1"></a>The objective is to construct a confidence band for the two functions $\underline{f}^{L, L^*}$ and $f^{L, L^*}$, based on the observations $\mathbf{y}$, for a given value $L\in \{L_{\min}, \ldots, L_{\max}\}$. The band for $\underline{f}^{L, L^*}$ enters the framework proposed by @sun1994 which relies on an unbiased and linear estimator of the function. This is the case for the estimator $\underline{\hat f}^{L, L^*}$ which is an unbiased estimator of $\underline{f}^{L, L^*}$. We recall in @sec-bandSun2 the construction of this confidence band which attains a given confidence level in a non-asymptotic setting, that is for a finite number of observations $n$ for each individual.  Then in @sec-bandfLLstar, we prove that the confidence band proposed by @sun1994 can be viewed as a confidence band for $f^{L, L^*}$ with an asymptotic confidence level, the asymptotic framework being considered when $n\rightarrow\infty$.</span>
<span id="cb20-465"><a href="#cb20-465" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-466"><a href="#cb20-466" aria-hidden="true" tabindex="-1"></a>\bigskip</span>
<span id="cb20-467"><a href="#cb20-467" aria-hidden="true" tabindex="-1"></a><span class="fu">## Confidence band for $\underline{f}^{L,L^*}$ {#sec-bandSun2}</span></span>
<span id="cb20-468"><a href="#cb20-468" aria-hidden="true" tabindex="-1"></a>Let $L\in <span class="sc">\{</span>1, \ldots, L_{\max}<span class="sc">\}</span>$.</span>
<span id="cb20-469"><a href="#cb20-469" aria-hidden="true" tabindex="-1"></a>Consider $1-\alpha$ as a fixed confidence level. Our aim is to find a function $d^L()$ such that</span>
<span id="cb20-470"><a href="#cb20-470" aria-hidden="true" tabindex="-1"></a>$$\mathbb{P}\left( \forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>,\; \underline{\hat{f}_{}}^{L,L^*}(t) -d^L(t)\leq \underline{f}^{L,L^*}(t)\leq \underline{\hat{f}_{}}^{L,L^*}(t) +d^L(t)\right) = 1-\alpha.$$</span>
<span id="cb20-471"><a href="#cb20-471" aria-hidden="true" tabindex="-1"></a>Consider the normalized statistics $Z_L(t)$ which is a centered and reduced Gaussian process. We want to find the quantile $q^L$ satisfying</span>
<span id="cb20-472"><a href="#cb20-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-473"><a href="#cb20-473" aria-hidden="true" tabindex="-1"></a>$$q^L =\arg\min_{q} \left<span class="sc">\{</span> \mathbb{P}\left(\max_{t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>} \left|Z_L(t)\right| \leq q \right) = 1 - \alpha\right<span class="sc">\}</span>.$${#eq-qL}</span>
<span id="cb20-474"><a href="#cb20-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-475"><a href="#cb20-475" aria-hidden="true" tabindex="-1"></a>Then we can take $d^L(t) = q^L \sqrt{C^{L, L^*}(t,t)}$. The covariance function $C^{L, L^*}(t,t)$ can be replaced by its estimator $\hat{C}^{L,L^*}(t,t)$, making the distribution a Student's distribution with $N-1$ degrees of freedom. Thus, it only requires to be able to compute the critical value $q^L$.</span>
<span id="cb20-476"><a href="#cb20-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-477"><a href="#cb20-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-478"><a href="#cb20-478" aria-hidden="true" tabindex="-1"></a>This can be done following @sun1994 who propose a confidence band for a centered Gaussian process. Their procedure is based on an unbiased linear estimator of the function of interest, which is the case for $\underline{\hat{f}_{}}^{L,L^*}$ when we consider a band for $\underline{f}^{L,L^*}$. </span>
<span id="cb20-479"><a href="#cb20-479" aria-hidden="true" tabindex="-1"></a>We recall their result in the following proposition, the computation of the value $q^L$ is detailed thereafter. </span>
<span id="cb20-480"><a href="#cb20-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-481"><a href="#cb20-481" aria-hidden="true" tabindex="-1"></a>::: {#thm-sunLoader}</span>
<span id="cb20-482"><a href="#cb20-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-483"><a href="#cb20-483" aria-hidden="true" tabindex="-1"></a><span class="fu">## @sun1994</span></span>
<span id="cb20-484"><a href="#cb20-484" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-485"><a href="#cb20-485" aria-hidden="true" tabindex="-1"></a>Set @def-ass-regression_finite and @def-ass-noise-spline and a probability $\alpha\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Then, we have </span>
<span id="cb20-486"><a href="#cb20-486" aria-hidden="true" tabindex="-1"></a>$$\mathbb{P}\left(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, \left|\underline{\hat{f}}^{L, L^*}(t)-\underline{f}^{L,L^*}(t)\right| \leq \hat d^L(t)\right) = 1- \alpha$$</span>
<span id="cb20-487"><a href="#cb20-487" aria-hidden="true" tabindex="-1"></a>with </span>
<span id="cb20-488"><a href="#cb20-488" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-489"><a href="#cb20-489" aria-hidden="true" tabindex="-1"></a>\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N};</span>
<span id="cb20-490"><a href="#cb20-490" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-491"><a href="#cb20-491" aria-hidden="true" tabindex="-1"></a>and $\hat q^L$ defined as the solution of the following equation, seen as a function of $q^L$:</span>
<span id="cb20-492"><a href="#cb20-492" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-493"><a href="#cb20-493" aria-hidden="true" tabindex="-1"></a>\alpha = \mathbb{P}(|t_{N-1}|&gt;q^L) +\frac{\| \tau^L\|_1}{\pi}\left( 1+\frac{(q^L)^2}{N-1}\right)^{-(N-1)/2} ,</span>
<span id="cb20-494"><a href="#cb20-494" aria-hidden="true" tabindex="-1"></a>$${#eq-cL}</span>
<span id="cb20-495"><a href="#cb20-495" aria-hidden="true" tabindex="-1"></a>with $(\tau^L)^2(t)= \partial_{12} c(t,t) = Var(Z_L(t))'$ where </span>
<span id="cb20-496"><a href="#cb20-496" aria-hidden="true" tabindex="-1"></a>we denote $\partial_{12}c(t,t)$ the partial derivatives of a function $c(t,s)$ in the first and second coordinates and then evaluated at $t=s$. </span>
<span id="cb20-497"><a href="#cb20-497" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-498"><a href="#cb20-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-499"><a href="#cb20-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-500"><a href="#cb20-500" aria-hidden="true" tabindex="-1"></a>We can thus deduce a confidence band of level $1-\alpha$ for $\underline{f}^{L,L^*}$:</span>
<span id="cb20-501"><a href="#cb20-501" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-502"><a href="#cb20-502" aria-hidden="true" tabindex="-1"></a>CB_1(\underline{f}^{L,L^*})&amp; = \{ \forall t\in [0,1], [\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) ]<span class="sc">\}</span>.</span>
<span id="cb20-503"><a href="#cb20-503" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-504"><a href="#cb20-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-505"><a href="#cb20-505" aria-hidden="true" tabindex="-1"></a>\textcolor{red}{Dans la derniere section pour definir le critere, on a besoin de montrer que la variance de $\hat{\tau}$ est bornée par $L/N$. Le processus $(P^L y_i(t)-\underline{\hat{f}}^{L, L^*}(t))$ vit dans un espace de dimension $L$. Ca parait naturel de borner par $L/N$?? Mais comment le justifier ?  }</span>
<span id="cb20-506"><a href="#cb20-506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-507"><a href="#cb20-507" aria-hidden="true" tabindex="-1"></a>The value $\hat q^L$ is defined implicitly in @eq-cL which involves the quantity $t\mapsto \tau^L(t)$. @Liebl2019 propose to estimate $\tau^L(t)$, for all $t$, by</span>
<span id="cb20-508"><a href="#cb20-508" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-509"><a href="#cb20-509" aria-hidden="true" tabindex="-1"></a>\hat \tau^L(t) &amp;= \left(\widehat{Var}(({U}^{L})'_{1}(t), \ldots, ({U}^{L})'_{N}(t)\right)^{1/2}<span class="sc">\\</span></span>
<span id="cb20-510"><a href="#cb20-510" aria-hidden="true" tabindex="-1"></a>&amp;= \left(\frac{1}{N-1}\sum_{i=1}^N\left(({U}^{L})'_{i}(t)-\frac1N\sum_{j=1}^N({U}^{L})'_{j}(t)\right)^2\right)^{1/2},</span>
<span id="cb20-511"><a href="#cb20-511" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-512"><a href="#cb20-512" aria-hidden="true" tabindex="-1"></a>where ${U}^L_{i}(t) = (P^L y_i(t)-\underline{\hat{f}}^{L, L^*}(t))/(\hat C^{L,L^*}(t))^{1/2}$ and $({U}^{L})'_{i}$ is a smooth version of the differentiated function ${U}^L_{i}$. Then we take the $L_1$-norm of $\hat \tau^L$. </span>
<span id="cb20-513"><a href="#cb20-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-514"><a href="#cb20-514" aria-hidden="true" tabindex="-1"></a>Let us describe the behavior of $\hat d^L$:</span>
<span id="cb20-515"><a href="#cb20-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-516"><a href="#cb20-516" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\|\hat d^L\|_\infty$ increases with $L$</span>
<span id="cb20-517"><a href="#cb20-517" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When the functions $(B_\ell^L)_{1\leq \ell \leq L}$ consists in an orthonormal family, $\|\hat d^L\|_\infty$ increases with $L$ until $L=L^*$ and then  $\|\hat d^L\|_\infty$ is constant with $L$.</span>
<span id="cb20-518"><a href="#cb20-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-519"><a href="#cb20-519" aria-hidden="true" tabindex="-1"></a>This band is illustrated on @fig-bandL. It displays on the top row several functional data generated under either the Fourier family (left), Legendre (middle) or Spline (right),    on the middle row the confidence bands of $\underline f^{L,L^*}$ for different values of $L=3,5$ and $11$, and on the bottom row the bound $\hat d^L$. The true functions $\underline f^{L,L^*}$ are displayed in cyan and the confidence bands in purple. The bands are very precise for each $L$. The behavior of $\hat d^L$ increases with $L$. As $d^L$ can be seen as a variance, $\hat d^L(t)$ is larger on the boundary of the domain, as there are less observations near 0 and 1. </span>
<span id="cb20-520"><a href="#cb20-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-521"><a href="#cb20-521" aria-hidden="true" tabindex="-1"></a>We also evaluate numerically the levels of the obtained confidence bands. For this, 1000 datasets are simulated, the confidence band is estimated for each of them. </span>
<span id="cb20-522"><a href="#cb20-522" aria-hidden="true" tabindex="-1"></a>The empirical confidence level is then evaluated as the proportion of confidence bands that contain the true function. @tbl-levelL presents the empirical confidence levels for different values of $L$ and two sample sizes $n=50$ and $n=150$, with $N=40$. </span>
<span id="cb20-523"><a href="#cb20-523" aria-hidden="true" tabindex="-1"></a>The level is the expected one whatever the value of $L$, especially when $L&lt;L^*$ and $L&gt;L^*$ but also when $L&gt;L^\varepsilon$. We will see in the next sections that this will not be the case for the debiased confidence band.  </span>
<span id="cb20-524"><a href="#cb20-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-525"><a href="#cb20-525" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-526"><a href="#cb20-526" aria-hidden="true" tabindex="-1"></a><span class="in">```{r }</span></span>
<span id="cb20-527"><a href="#cb20-527" aria-hidden="true" tabindex="-1"></a>compute.c.L <span class="ot">=</span> <span class="cf">function</span>(data.scl, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb20-528"><a href="#cb20-528" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data.scl: the rescaled data </span></span>
<span id="cb20-529"><a href="#cb20-529" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb20-530"><a href="#cb20-530" aria-hidden="true" tabindex="-1"></a>  x_approx <span class="ot">=</span> <span class="fu">apply</span>(data.scl<span class="sc">$</span>y, <span class="dv">2</span>,<span class="at">FUN=</span><span class="cf">function</span>(yy){</span>
<span id="cb20-531"><a href="#cb20-531" aria-hidden="true" tabindex="-1"></a>    fn <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">splinefun</span>(<span class="at">x =</span> data.scl<span class="sc">$</span>time, <span class="at">y =</span> yy, <span class="at">method =</span> <span class="st">"natural"</span>)</span>
<span id="cb20-532"><a href="#cb20-532" aria-hidden="true" tabindex="-1"></a>    pracma<span class="sc">::</span><span class="fu">fderiv</span>(<span class="at">f =</span> fn, <span class="at">x =</span> data.scl<span class="sc">$</span>time, <span class="at">n =</span> <span class="dv">1</span>, <span class="at">h =</span> <span class="fl">1e-6</span>, <span class="at">method =</span> <span class="st">"central"</span>)</span>
<span id="cb20-533"><a href="#cb20-533" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb20-534"><a href="#cb20-534" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="fu">ncol</span>(data.scl<span class="sc">$</span>y)</span>
<span id="cb20-535"><a href="#cb20-535" aria-hidden="true" tabindex="-1"></a>  hat.tau <span class="ot">=</span> <span class="fu">apply</span>(x_approx, <span class="dv">1</span>, stats<span class="sc">::</span>sd) </span>
<span id="cb20-536"><a href="#cb20-536" aria-hidden="true" tabindex="-1"></a>  hat.tau[<span class="fu">which</span>(<span class="fu">is.na</span>(hat.tau))] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb20-537"><a href="#cb20-537" aria-hidden="true" tabindex="-1"></a>  tau_01     <span class="ot">=</span> (hat.tau)[<span class="sc">-</span><span class="dv">1</span>]<span class="sc">%*%</span><span class="fu">diff</span>(data.scl<span class="sc">$</span>time)</span>
<span id="cb20-538"><a href="#cb20-538" aria-hidden="true" tabindex="-1"></a>  myfun      <span class="ot">=</span> <span class="cf">function</span>(c){stats<span class="sc">::</span><span class="fu">pt</span>(c, <span class="at">lower.tail =</span> <span class="cn">FALSE</span>, <span class="at">df =</span> N<span class="dv">-1</span>) <span class="sc">+</span> tau_01 <span class="sc">*</span> </span>
<span id="cb20-539"><a href="#cb20-539" aria-hidden="true" tabindex="-1"></a>      (<span class="dv">1</span> <span class="sc">+</span> c<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span>(N<span class="dv">-1</span>))<span class="sc">^</span>(<span class="sc">-</span>(N<span class="dv">-1</span>)<span class="sc">/</span><span class="dv">2</span>)<span class="sc">/</span>(<span class="dv">2</span> <span class="sc">*</span> pi) <span class="sc">-</span> alpha<span class="sc">/</span><span class="dv">2</span>}</span>
<span id="cb20-540"><a href="#cb20-540" aria-hidden="true" tabindex="-1"></a>  c.L       <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">uniroot</span>(<span class="at">f =</span> myfun,<span class="at">interval =</span> <span class="fu">c</span>(.<span class="dv">5</span>,<span class="dv">8</span>))<span class="sc">$</span>root</span>
<span id="cb20-541"><a href="#cb20-541" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(c.L)</span>
<span id="cb20-542"><a href="#cb20-542" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-543"><a href="#cb20-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-544"><a href="#cb20-544" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb20-545"><a href="#cb20-545" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb20-546"><a href="#cb20-546" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb20-547"><a href="#cb20-547" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb20-548"><a href="#cb20-548" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb20-549"><a href="#cb20-549" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-550"><a href="#cb20-550" aria-hidden="true" tabindex="-1"></a>  est <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb20-551"><a href="#cb20-551" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est<span class="sc">$</span>data.proj</span>
<span id="cb20-552"><a href="#cb20-552" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb20-553"><a href="#cb20-553" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est<span class="sc">$</span>cov.emp))</span>
<span id="cb20-554"><a href="#cb20-554" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-555"><a href="#cb20-555" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb20-556"><a href="#cb20-556" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb20-557"><a href="#cb20-557" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est<span class="sc">$</span>f.hat <span class="sc">+</span> d.L</span>
<span id="cb20-558"><a href="#cb20-558" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est<span class="sc">$</span>f.hat <span class="sc">-</span> d.L</span>
<span id="cb20-559"><a href="#cb20-559" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-560"><a href="#cb20-560" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">d.L =</span> d.L, <span class="at">c.L =</span> c.L))</span>
<span id="cb20-561"><a href="#cb20-561" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-562"><a href="#cb20-562" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-563"><a href="#cb20-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-564"><a href="#cb20-564" aria-hidden="true" tabindex="-1"></a>d.L.Lmax <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax=</span><span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>){</span>
<span id="cb20-565"><a href="#cb20-565" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb20-566"><a href="#cb20-566" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-567"><a href="#cb20-567" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb20-568"><a href="#cb20-568" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb20-569"><a href="#cb20-569" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb20-570"><a href="#cb20-570" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb20-571"><a href="#cb20-571" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb20-572"><a href="#cb20-572" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb20-573"><a href="#cb20-573" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, alpha)</span>
<span id="cb20-574"><a href="#cb20-574" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb20-575"><a href="#cb20-575" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(c.L.Lmax<span class="fl">.2</span>)</span>
<span id="cb20-576"><a href="#cb20-576" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-577"><a href="#cb20-577" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-578"><a href="#cb20-578" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-579"><a href="#cb20-579" aria-hidden="true" tabindex="-1"></a><span class="in">```{r , fig.height = 7, fig.width=7}</span></span>
<span id="cb20-580"><a href="#cb20-580" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-bandL</span></span>
<span id="cb20-581"><a href="#cb20-581" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For the three families, resp. Fourier, Legendre and the splines, we display on the top row the observed functional data, on the middle row the confidence bands for different values of L (3, 5 and 11), and on the bottom row the bound dL."</span></span>
<span id="cb20-582"><a href="#cb20-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-583"><a href="#cb20-583" aria-hidden="true" tabindex="-1"></a>dfObs <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-584"><a href="#cb20-584" aria-hidden="true" tabindex="-1"></a>                   <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-585"><a href="#cb20-585" aria-hidden="true" tabindex="-1"></a>                   <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb20-586"><a href="#cb20-586" aria-hidden="true" tabindex="-1"></a>                   <span class="at">ind =</span> <span class="fu">integer</span>())</span>
<span id="cb20-587"><a href="#cb20-587" aria-hidden="true" tabindex="-1"></a>dfTrue <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-588"><a href="#cb20-588" aria-hidden="true" tabindex="-1"></a>                    <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-589"><a href="#cb20-589" aria-hidden="true" tabindex="-1"></a>                    <span class="at">f =</span> <span class="fu">double</span>())</span>
<span id="cb20-590"><a href="#cb20-590" aria-hidden="true" tabindex="-1"></a>dfTrueProjected <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-591"><a href="#cb20-591" aria-hidden="true" tabindex="-1"></a>                             <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-592"><a href="#cb20-592" aria-hidden="true" tabindex="-1"></a>                             <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb20-593"><a href="#cb20-593" aria-hidden="true" tabindex="-1"></a>                             <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb20-594"><a href="#cb20-594" aria-hidden="true" tabindex="-1"></a>dfBand <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-595"><a href="#cb20-595" aria-hidden="true" tabindex="-1"></a>                     <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-596"><a href="#cb20-596" aria-hidden="true" tabindex="-1"></a>                     <span class="at">flow =</span> <span class="fu">double</span>(),</span>
<span id="cb20-597"><a href="#cb20-597" aria-hidden="true" tabindex="-1"></a>                     <span class="at">fup =</span> <span class="fu">double</span>(),</span>
<span id="cb20-598"><a href="#cb20-598" aria-hidden="true" tabindex="-1"></a>                     <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb20-599"><a href="#cb20-599" aria-hidden="true" tabindex="-1"></a>dfdL <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-600"><a href="#cb20-600" aria-hidden="true" tabindex="-1"></a>                   <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-601"><a href="#cb20-601" aria-hidden="true" tabindex="-1"></a>                   <span class="at">dL =</span> <span class="fu">double</span>(),</span>
<span id="cb20-602"><a href="#cb20-602" aria-hidden="true" tabindex="-1"></a>                   <span class="at">dimension =</span> <span class="fu">character</span>())</span>
<span id="cb20-603"><a href="#cb20-603" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>)</span>
<span id="cb20-604"><a href="#cb20-604" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-605"><a href="#cb20-605" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="dv">40</span></span>
<span id="cb20-606"><a href="#cb20-606" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span>N,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-607"><a href="#cb20-607" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-608"><a href="#cb20-608" aria-hidden="true" tabindex="-1"></a>  dfObs <span class="ot">=</span> <span class="fu">rbind</span>(dfObs,<span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">rep</span>(data<span class="sc">$</span>time, N),</span>
<span id="cb20-609"><a href="#cb20-609" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(<span class="fu">c</span>(data<span class="sc">$</span>y))),</span>
<span id="cb20-610"><a href="#cb20-610" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y),</span>
<span id="cb20-611"><a href="#cb20-611" aria-hidden="true" tabindex="-1"></a>                                 <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>N, <span class="at">each =</span> <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb20-612"><a href="#cb20-612" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-613"><a href="#cb20-613" aria-hidden="true" tabindex="-1"></a>  dfTrue <span class="ot">=</span> <span class="fu">rbind</span>(dfTrue,<span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-614"><a href="#cb20-614" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-615"><a href="#cb20-615" aria-hidden="true" tabindex="-1"></a>                                   <span class="at">f =</span> data<span class="sc">$</span>f.true))</span>
<span id="cb20-616"><a href="#cb20-616" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-617"><a href="#cb20-617" aria-hidden="true" tabindex="-1"></a>    conf.band <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L)</span>
<span id="cb20-618"><a href="#cb20-618" aria-hidden="true" tabindex="-1"></a>    B <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb20-619"><a href="#cb20-619" aria-hidden="true" tabindex="-1"></a>    f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B) <span class="sc">%*%</span> B) <span class="sc">%*%</span> <span class="fu">t</span>(B) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb20-620"><a href="#cb20-620" aria-hidden="true" tabindex="-1"></a>    dfBand <span class="ot">=</span> <span class="fu">rbind</span>(dfBand, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-621"><a href="#cb20-621" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-622"><a href="#cb20-622" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">flow =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>f.hat.low), </span>
<span id="cb20-623"><a href="#cb20-623" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">fup =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>f.hat.up), </span>
<span id="cb20-624"><a href="#cb20-624" aria-hidden="true" tabindex="-1"></a>                                      <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb20-625"><a href="#cb20-625" aria-hidden="true" tabindex="-1"></a>    dfTrueProjected <span class="ot">=</span> <span class="fu">rbind</span>(dfTrueProjected, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-626"><a href="#cb20-626" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-627"><a href="#cb20-627" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">f =</span> <span class="fu">c</span>(f.true.L), </span>
<span id="cb20-628"><a href="#cb20-628" aria-hidden="true" tabindex="-1"></a>                                                        <span class="at">dimension =</span> <span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb20-629"><a href="#cb20-629" aria-hidden="true" tabindex="-1"></a>    dfdL <span class="ot">=</span> <span class="fu">rbind</span>(dfdL, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-630"><a href="#cb20-630" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-631"><a href="#cb20-631" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dL =</span> <span class="fu">c</span>(conf.band<span class="sc">$</span>d.L),</span>
<span id="cb20-632"><a href="#cb20-632" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L,<span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb20-633"><a href="#cb20-633" aria-hidden="true" tabindex="-1"></a>  } </span>
<span id="cb20-634"><a href="#cb20-634" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-635"><a href="#cb20-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-636"><a href="#cb20-636" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb20-637"><a href="#cb20-637" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfObs, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">group =</span> ind), <span class="at">linewidth =</span> <span class="fl">0.1</span>, <span class="at">color =</span> <span class="st">"grey"</span>) <span class="sc">+</span></span>
<span id="cb20-638"><a href="#cb20-638" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrue, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f), <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">linewidth =</span> <span class="fl">0.5</span>) <span class="sc">+</span> </span>
<span id="cb20-639"><a href="#cb20-639" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-640"><a href="#cb20-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-641"><a href="#cb20-641" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-642"><a href="#cb20-642" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb20-643"><a href="#cb20-643" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBand, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> flow, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb20-644"><a href="#cb20-644" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBand, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> fup, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.8</span>) <span class="sc">+</span> </span>
<span id="cb20-645"><a href="#cb20-645" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrueProjected, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f, <span class="at">group =</span> dimension), <span class="at">colour =</span> <span class="st">"black"</span>, <span class="at">linewidth =</span> <span class="fl">0.2</span>)<span class="sc">+</span> </span>
<span id="cb20-646"><a href="#cb20-646" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"confidence band"</span>)</span>
<span id="cb20-647"><a href="#cb20-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-648"><a href="#cb20-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-649"><a href="#cb20-649" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span></span>
<span id="cb20-650"><a href="#cb20-650" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdL, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dL, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension)) <span class="sc">+</span></span>
<span id="cb20-651"><a href="#cb20-651" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-652"><a href="#cb20-652" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-653"><a href="#cb20-653" aria-hidden="true" tabindex="-1"></a><span class="fu">ggarrange</span>(p1, p2, p3, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">common.legend =</span> <span class="cn">TRUE</span>, <span class="at">legend =</span> <span class="st">"bottom"</span>)</span>
<span id="cb20-654"><a href="#cb20-654" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-655"><a href="#cb20-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-656"><a href="#cb20-656" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-659"><a href="#cb20-659" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb20-660"><a href="#cb20-660" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-levelL</span></span>
<span id="cb20-661"><a href="#cb20-661" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Illustrative example. The confidence level of the confidence band is evaluated from 1000 repetitions. Confidence bands are calculated with the Legendre family, for several L in rows and several n in columns."</span></span>
<span id="cb20-662"><a href="#cb20-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-663"><a href="#cb20-663" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(knitr)</span>
<span id="cb20-664"><a href="#cb20-664" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb20-665"><a href="#cb20-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-666"><a href="#cb20-666" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb20-667"><a href="#cb20-667" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb20-668"><a href="#cb20-668" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb20-669"><a href="#cb20-669" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb20-670"><a href="#cb20-670" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>) </span>
<span id="cb20-671"><a href="#cb20-671" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb20-672"><a href="#cb20-672" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb20-673"><a href="#cb20-673" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> <span class="fu">max</span>(vec.L), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb20-674"><a href="#cb20-674" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb20-675"><a href="#cb20-675" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-676"><a href="#cb20-676" aria-hidden="true" tabindex="-1"></a>      cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb20-677"><a href="#cb20-677" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb20-678"><a href="#cb20-678" aria-hidden="true" tabindex="-1"></a>        <span class="fu">set.seed</span>(rep)</span>
<span id="cb20-679"><a href="#cb20-679" aria-hidden="true" tabindex="-1"></a>        data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">basis =</span> basis)</span>
<span id="cb20-680"><a href="#cb20-680" aria-hidden="true" tabindex="-1"></a>        conf.band <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L)</span>
<span id="cb20-681"><a href="#cb20-681" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){</span>
<span id="cb20-682"><a href="#cb20-682" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> (L<span class="sc">%%</span><span class="dv">2</span> <span class="sc">==</span> <span class="dv">0</span>){ L <span class="ot">=</span> L<span class="sc">+</span><span class="dv">1</span>}</span>
<span id="cb20-683"><a href="#cb20-683" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb20-684"><a href="#cb20-684" aria-hidden="true" tabindex="-1"></a>        B.old <span class="ot">=</span> <span class="fu">func.basis</span>(data<span class="sc">$</span>time, L, basis)</span>
<span id="cb20-685"><a href="#cb20-685" aria-hidden="true" tabindex="-1"></a>        B <span class="ot">=</span> <span class="fu">func.basis</span>(time, L, basis)</span>
<span id="cb20-686"><a href="#cb20-686" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-687"><a href="#cb20-687" aria-hidden="true" tabindex="-1"></a>        f.true.L <span class="ot">=</span> <span class="fu">t</span>(B <span class="sc">%*%</span> <span class="fu">solve</span>(<span class="fu">t</span>(B.old) <span class="sc">%*%</span> B.old) <span class="sc">%*%</span> <span class="fu">t</span>(B.old) <span class="sc">%*%</span> data<span class="sc">$</span>f.true)</span>
<span id="cb20-688"><a href="#cb20-688" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb20-689"><a href="#cb20-689" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band<span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb20-690"><a href="#cb20-690" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true.L<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true.L<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb20-691"><a href="#cb20-691" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span>} </span>
<span id="cb20-692"><a href="#cb20-692" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb20-693"><a href="#cb20-693" aria-hidden="true" tabindex="-1"></a>      perf[L,ind.n] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb20-694"><a href="#cb20-694" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-695"><a href="#cb20-695" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-696"><a href="#cb20-696" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> perf[vec.L,]</span>
<span id="cb20-697"><a href="#cb20-697" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(perf) <span class="ot">=</span> vec.L</span>
<span id="cb20-698"><a href="#cb20-698" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(perf) <span class="ot">=</span> vec.n</span>
<span id="cb20-699"><a href="#cb20-699" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">"res_Tab1.RData"</span>) } <span class="do">### charger les données</span></span>
<span id="cb20-700"><a href="#cb20-700" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-701"><a href="#cb20-701" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(perf)</span>
<span id="cb20-702"><a href="#cb20-702" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-703"><a href="#cb20-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-704"><a href="#cb20-704" aria-hidden="true" tabindex="-1"></a><span class="fu">## Asymptotic confidence band for $f^{L,L^*}$ {#sec-bandfLLstar}</span></span>
<span id="cb20-705"><a href="#cb20-705" aria-hidden="true" tabindex="-1"></a>Note that if one works in the asymptotic framework $n\rightarrow\infty$, the previous definition of $\hat d^L$ induces a natural asymptotic confidence band for the function $f^{L,L^*}$. Indeed, we can prove that </span>
<span id="cb20-706"><a href="#cb20-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-707"><a href="#cb20-707" aria-hidden="true" tabindex="-1"></a>::: {#thm-CB_Liebl_asymptotic}</span>
<span id="cb20-708"><a href="#cb20-708" aria-hidden="true" tabindex="-1"></a>Set @def-ass-regression_finite and @def-ass-noise-spline and a probability $\alpha\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Then, we have, </span>
<span id="cb20-709"><a href="#cb20-709" aria-hidden="true" tabindex="-1"></a>$$\lim_{n \rightarrow +\infty} \mathbb{P}\left(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\underline{\hat{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)\right) = 1-\alpha,$$</span>
<span id="cb20-710"><a href="#cb20-710" aria-hidden="true" tabindex="-1"></a>with $\hat d^L(t) = \hat q^L \sqrt{\hat C^{L,L^*}(t,t)/N}$ and $\hat q^L$ defined as the solution of @eq-cL.</span>
<span id="cb20-711"><a href="#cb20-711" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-712"><a href="#cb20-712" aria-hidden="true" tabindex="-1"></a>The proof is given in Appendix. </span>
<span id="cb20-713"><a href="#cb20-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-714"><a href="#cb20-714" aria-hidden="true" tabindex="-1"></a>Then a confidence band for $f^{L,L^*}$ at the asymptotic confidence level $1-\alpha$ for a large number of observations $n$ is given by </span>
<span id="cb20-715"><a href="#cb20-715" aria-hidden="true" tabindex="-1"></a>\begin{align*} </span>
<span id="cb20-716"><a href="#cb20-716" aria-hidden="true" tabindex="-1"></a>CB(f^{L,L^*})&amp; = \{ \forall t\in [0,1], [\underline{\hat{f}}^{L, L^*}(t) -\hat d^L(t) ; \underline{\hat{f}}^{L, L^*}(t) +\hat d^L(t) ]<span class="sc">\}</span>.</span>
<span id="cb20-717"><a href="#cb20-717" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-718"><a href="#cb20-718" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-719"><a href="#cb20-719" aria-hidden="true" tabindex="-1"></a>We do not provide any illustration of this property, as it would be similar than the previous ones. Indeed, we notice that the asymptotic is achieved even when $n$ is small on our examples. </span>
<span id="cb20-720"><a href="#cb20-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-721"><a href="#cb20-721" aria-hidden="true" tabindex="-1"></a><span class="fu"># Confidence Band of $f^{L^*}$ by correcting the bias {#sec-band2}</span></span>
<span id="cb20-722"><a href="#cb20-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-723"><a href="#cb20-723" aria-hidden="true" tabindex="-1"></a>The function of interest is $f^{L^*}=\underline{f}^{L^*, L^*}$, rather than $\underline{f}^{L,L^*}$. Therefore, our aim is to construct a confidence bound for $f^{L^*}$. However, an unbiased estimator of $f^{L^*}$ is unavailable by definition, since the true dimension $L^*$ is unknown. Instead, we propose to work with the estimator $\underline{\hat f}^{L,L^*}$ and to debias the corresponding confidence band.  </span>
<span id="cb20-724"><a href="#cb20-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-725"><a href="#cb20-725" aria-hidden="true" tabindex="-1"></a>To achieve this, we use the decomposition outlined in @eq-decomposition </span>
<span id="cb20-726"><a href="#cb20-726" aria-hidden="true" tabindex="-1"></a>between the bias term and the statistical term. The idea is to bound the infinity norm of these two terms. A first strategy consists in bounding each term separately and then summing the two bounds to construct the confidence band. However, this approach tends to produce a band that is too large and  conservative. The reason is that applying </span>
<span id="cb20-727"><a href="#cb20-727" aria-hidden="true" tabindex="-1"></a>the infinite norms on each term before bounding them does not take into account the functional nature of the two terms. This approach is presented in details in Appendix. </span>
<span id="cb20-728"><a href="#cb20-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-729"><a href="#cb20-729" aria-hidden="true" tabindex="-1"></a>A second strategy consists in keeping the functional aspect by bounding the infinity norm of the sum of the functional two terms. This approach is detailed in this section. </span>
<span id="cb20-730"><a href="#cb20-730" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-731"><a href="#cb20-731" aria-hidden="true" tabindex="-1"></a>In @sec-construction2, we first rewrite the band as a band around $\underline{f}^{L,L^*}(t)$. We then use a first subsample $\mathbf{y}^1$ to estimate the bound as defined in @sec-bandSun. A second subsample $\mathbf{y}^2$ is used to estimate the bias term (without the infinite norm). This yields a pointwise correction of the bias, and the final confidence band is centered around $\underline{\hat{f}}^{L_{\max},L^*}$. This procedure provides a collection of confidence bands, for $L=L_{\min}, \ldots, L_{\max}$,  each achieving a given confidence level but with varying width. Then, in @sec-SelectionL2, we propose a criterion to select the "best" band by minimizing its width. </span>
<span id="cb20-732"><a href="#cb20-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-733"><a href="#cb20-733" aria-hidden="true" tabindex="-1"></a><span class="fu">## Construction of the band of $f^{L^*}$ for a given $L$ {#sec-construction2}</span></span>
<span id="cb20-734"><a href="#cb20-734" aria-hidden="true" tabindex="-1"></a>We introduce  two independent sub-samples $\mathbf{y}^1$ and $\mathbf{y}^2$ of $\mathbf{y}$ of length $n_1$ and $n_2$ </span>
<span id="cb20-735"><a href="#cb20-735" aria-hidden="true" tabindex="-1"></a>such that $n_1+n_2=n$. \textcolor{red}{On le coupe en temps ou bien on sous-echantillonne ?}</span>
<span id="cb20-736"><a href="#cb20-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-737"><a href="#cb20-737" aria-hidden="true" tabindex="-1"></a>We use the first sub-sample $\mathbf{y}^1$ to calculate $\underline{\hat{f}_1}^{L,L^*}(t)$, an estimator of $\underline{f}^{L,L^*}(t)$ and  a functional bound denoted $\hat d_1^L$ that controls the bias term $\underline{f}^{L,L^*}(t)-\underline{\hat{f}_1}^{L,L^*}(t)$. This bound is defined in @sec-bandSun applied on $\mathbf{y}^1$, for a given level $\alpha$, such that:</span>
<span id="cb20-738"><a href="#cb20-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-739"><a href="#cb20-739" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-740"><a href="#cb20-740" aria-hidden="true" tabindex="-1"></a>\mathbb{P}\left(\forall t\in<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, -\hat d_1^L(t) \leq \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t) \leq \hat d_1^L(t)\right) = 1-\alpha.</span>
<span id="cb20-741"><a href="#cb20-741" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-dL1}</span>
<span id="cb20-742"><a href="#cb20-742" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-743"><a href="#cb20-743" aria-hidden="true" tabindex="-1"></a>Then, we need to control the bias $Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t)-f^{L^*}(t)$. Recall than when $L_{\max}$ is large enough and $n&gt; L_{\max}$, $f^{L^*} = \underline{f}^{L_{\max},L^*}$. Therefore, we want to control the $Bias_{L,L^*}(t) = \underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}(t)$. It would be tempting to replace $Bias_{L,L^*}(t)$ by its estimation based on the second sample $\mathbf{y}^2$. But this would introduce an estimation error that we also need to control, in the same spirit than what is done in @PCO. We can use again @sec-bandSun to compute the function $\hat d_2^{L,L_{\max}}(t)$ on the sample $\mathbf{y}^2$, and the functional estimators $\underline{\hat{f}}_2^{L,L^*}(t)$ and $\underline{\hat f}_2^{L_{\max}, L^*}(t)$ of $\underline{f}^{L,L^*}(t)$ and $\underline{ f}^{L_{\max}, L^*}(t)$, respectively. This allows to construct the following band for $\underline{f}^{L,L^*}(t) - \underline{f}^{L_{\max},L^*}$ for a confidence level $1-\beta$, </span>
<span id="cb20-744"><a href="#cb20-744" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-745"><a href="#cb20-745" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-746"><a href="#cb20-746" aria-hidden="true" tabindex="-1"></a>\mathbb{P}\left(\forall t\in<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, - \hat d_2^{L,L_{\max}}(t) \leq \underline{ f}^{L_{\max}, L^*}(t)- \underline{ f}^{L, L^*}(t) - (\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t)) \leq \hat d_2^{L,L_{\max}}(t)\right) = 1-\beta.</span>
<span id="cb20-747"><a href="#cb20-747" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-dL2}</span>
<span id="cb20-748"><a href="#cb20-748" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-749"><a href="#cb20-749" aria-hidden="true" tabindex="-1"></a>Combining @eq-def-dL1 and @eq-def-dL2, we can provide a debiased confidence band of $f^{L^*}(t)$. </span>
<span id="cb20-750"><a href="#cb20-750" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-751"><a href="#cb20-751" aria-hidden="true" tabindex="-1"></a>::: {#prp-CBf}</span>
<span id="cb20-752"><a href="#cb20-752" aria-hidden="true" tabindex="-1"></a>Let us define </span>
<span id="cb20-753"><a href="#cb20-753" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-754"><a href="#cb20-754" aria-hidden="true" tabindex="-1"></a>\hat\theta_1^L(t) &amp;:= -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L, L^*}(t) <span class="sc">\\</span></span>
<span id="cb20-755"><a href="#cb20-755" aria-hidden="true" tabindex="-1"></a>\hat\theta_2^L(t)&amp;:= \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t) +\underline{\hat f}_2^{L_{\max}, L^*}(t) - \underline{\hat f}_2^{L, L^*}(t),</span>
<span id="cb20-756"><a href="#cb20-756" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-757"><a href="#cb20-757" aria-hidden="true" tabindex="-1"></a>where $\hat d_1^L(t)$ is defined on sample $\mathbf{y}^1$ by @eq-def-dL1 for a level $\alpha$ and $\hat d_2^{L,L_{\max}}(t)$ is defined on sample $\mathbf{y}^2$ by @eq-def-dL2 for a level $\beta$. </span>
<span id="cb20-758"><a href="#cb20-758" aria-hidden="true" tabindex="-1"></a>Then we have</span>
<span id="cb20-759"><a href="#cb20-759" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-760"><a href="#cb20-760" aria-hidden="true" tabindex="-1"></a>\mathbb{P}\left(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, \quad \hat \theta_1^L(t) \leq f^{L^*}(t)- \underline{\hat f}_1^{L, L^*}(t)\leq \hat\theta_2^L(t)\right)\geq 1-\alpha\beta.</span>
<span id="cb20-761"><a href="#cb20-761" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-762"><a href="#cb20-762" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-763"><a href="#cb20-763" aria-hidden="true" tabindex="-1"></a>The proof is given in Appendix.</span>
<span id="cb20-764"><a href="#cb20-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-765"><a href="#cb20-765" aria-hidden="true" tabindex="-1"></a>This defines a confidence band which can be defined either around $\underline{\hat{f}_{1}}^{L,L^*}$: </span>
<span id="cb20-766"><a href="#cb20-766" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-767"><a href="#cb20-767" aria-hidden="true" tabindex="-1"></a>CB_2(\underline{f}^{L^*})=\{\forall t\in[0,1], [\underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_1^{ L}(t) \, ;\, \underline{\hat{f}_1}^{ L, L^*}(t) + \hat\theta_2^{ L}(t) ] <span class="sc">\}</span></span>
<span id="cb20-768"><a href="#cb20-768" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-769"><a href="#cb20-769" aria-hidden="true" tabindex="-1"></a>or around $\underline{\hat f}_2^{ L_{\max}, L^*}$:</span>
<span id="cb20-770"><a href="#cb20-770" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-771"><a href="#cb20-771" aria-hidden="true" tabindex="-1"></a>CB_2(\underline{f}^{L^*})=\{\forall t\in[0,1], [\underline{\hat f}_2^{ L_{\max}, L^*}(t) + \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f}_2^{ L, L^*}(t) -\hat d_1^L(t) - \hat d_2^{L,L_{\max}}(t) \, ;\, \underline{\hat f}_2^{ L_{\max}, L^*}(t) + \underline{\hat{f}_{1}}^{L,L^*}(t)-\underline{\hat f}_2^{ L, L^*}(t) + \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)]<span class="sc">\}</span>.</span>
<span id="cb20-772"><a href="#cb20-772" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-773"><a href="#cb20-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-774"><a href="#cb20-774" aria-hidden="true" tabindex="-1"></a>::: {#rem-dLLmax}</span>
<span id="cb20-775"><a href="#cb20-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-776"><a href="#cb20-776" aria-hidden="true" tabindex="-1"></a>The two functions $\hat d_1^L(t)$ and $\hat d_2^{L,L_{\max}}(t)$ are of the same order as they are built with the same approach. They depend on the length of the samples. To obtain the thinnest band, the best strategy is to split the sample in two sub-samples of equal length $n_1=n_2= n/2$. </span>
<span id="cb20-777"><a href="#cb20-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-778"><a href="#cb20-778" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-779"><a href="#cb20-779" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-780"><a href="#cb20-780" aria-hidden="true" tabindex="-1"></a>The behavior of $\hat d_1^L$ has been described in @sec-bandSun. Let us describe the behavior of $\hat d_2^{L,L_{\max}}$:</span>
<span id="cb20-781"><a href="#cb20-781" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-782"><a href="#cb20-782" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>$\|\hat d_2^{L,L_{\max}}\|_\infty$ decreases with $L$.</span>
<span id="cb20-783"><a href="#cb20-783" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L&gt;L^\varepsilon$, $\|\hat d_2^{L,L_{\max}}\|_\infty$ is constant with $L$ and the probability in @eq-def-dL2 is equal to $1$.</span>
<span id="cb20-784"><a href="#cb20-784" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>When $L^{*}&lt;L&lt;L^\varepsilon$, $\|\hat d_2^{L,L_{\max}}\|_\infty$ is constant with $L$ when the functions $B_\ell^L$ consists in an orthonormal family. Otherwise, the behavior is erratic.         </span>
<span id="cb20-785"><a href="#cb20-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-786"><a href="#cb20-786" aria-hidden="true" tabindex="-1"></a>It means that when the band defined in @prp-CBf is calculated for $L&gt;L^\varepsilon$, the confidence level is $1-\alpha$ instead of $1-\alpha\beta$. </span>
<span id="cb20-787"><a href="#cb20-787" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-788"><a href="#cb20-788" aria-hidden="true" tabindex="-1"></a>The advantages of this approach is that the bias of the band is corrected and the level for the true function $f^{L^*}$ is guaranteed when $L^\varepsilon$ is large. This was the main objective of the paper. </span>
<span id="cb20-789"><a href="#cb20-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-790"><a href="#cb20-790" aria-hidden="true" tabindex="-1"></a>We illustrate numerically those advantages. </span>
<span id="cb20-791"><a href="#cb20-791" aria-hidden="true" tabindex="-1"></a>In @fig-Lstar, top row, we plot the confidence bands obtained for different dimensions $L \in <span class="sc">\{</span>3,5,11,15,21<span class="sc">\}</span>$ with Fourier,  Legendre and Splines families and $\alpha=\beta=\sqrt{0.05}\approx 0.22$. We can see that all the confidence bands are alike. Especially, they are unbiased, even for $L=3$. A larger dimension $L$ provides a smoother band. </span>
<span id="cb20-792"><a href="#cb20-792" aria-hidden="true" tabindex="-1"></a>On the middle and bottom rows of  @fig-Lstar, we illustrate the two terms that enter the confidence band, $t \mapsto \hat d_1^L(t)$ and $t\mapsto \hat d_2^{L,L_{\max}}(t)$. Their behavior is the same along time. The function $\hat d_1^L(t)$ can be seen as a variance, this is why it is larger near 0 and 1 where there are less observations. The function $\hat d_2^{L,L_{\max}}(t)$ is smaller than $\hat d_1^L(t)$ because it controls the remaining rest after the projection. Note that as expected when $L&gt;L^\varepsilon$, $\hat d_2^{L,L_{\max}}(t)$ is close to 0. As explained before, the influence of $L$ is not the same for the two functions. When $L$ increases, $\hat d_1^L(t)$ increases while $\hat d_2^{L,L_{\max}}(t)$ decreases.  </span>
<span id="cb20-793"><a href="#cb20-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-794"><a href="#cb20-794" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.height = 7, fig.width=7}</span></span>
<span id="cb20-795"><a href="#cb20-795" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-Lstar</span></span>
<span id="cb20-796"><a href="#cb20-796" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For a given dataset, we plot several confidence bands (top row), functions dL (middle row) and dLLmax (bottom row). Bands and functions are estimated with Fourier (left column), Legendre (middle column) and Spline (right column) basis and several dimensions L (3, 5, 11, 15, 21)."</span></span>
<span id="cb20-797"><a href="#cb20-797" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-798"><a href="#cb20-798" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb20-799"><a href="#cb20-799" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the time-points and the individual functions</span></span>
<span id="cb20-800"><a href="#cb20-800" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb20-801"><a href="#cb20-801" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb20-802"><a href="#cb20-802" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb20-803"><a href="#cb20-803" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.1</span> <span class="ot">=</span> data<span class="fl">.2</span> <span class="ot">=</span> data</span>
<span id="cb20-804"><a href="#cb20-804" aria-hidden="true" tabindex="-1"></a>  ind<span class="fl">.1</span> <span class="ot">=</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>], <span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb20-805"><a href="#cb20-805" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.1</span><span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,ind<span class="fl">.1</span>]</span>
<span id="cb20-806"><a href="#cb20-806" aria-hidden="true" tabindex="-1"></a>  data<span class="fl">.2</span><span class="sc">$</span>y <span class="ot">=</span> data<span class="sc">$</span>y[,<span class="sc">-</span>ind<span class="fl">.1</span>]</span>
<span id="cb20-807"><a href="#cb20-807" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-808"><a href="#cb20-808" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb20-809"><a href="#cb20-809" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.1</span>, basis, L)</span>
<span id="cb20-810"><a href="#cb20-810" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-811"><a href="#cb20-811" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>scl <span class="ot">=</span> data.<span class="fl">1.</span>proj</span>
<span id="cb20-812"><a href="#cb20-812" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">1.</span>scl<span class="sc">$</span>y <span class="ot">=</span> (data.<span class="fl">1.</span>proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb20-813"><a href="#cb20-813" aria-hidden="true" tabindex="-1"></a>  c.L<span class="fl">.1</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">1.</span>scl, alpha)</span>
<span id="cb20-814"><a href="#cb20-814" aria-hidden="true" tabindex="-1"></a>  d.L<span class="fl">.1</span> <span class="ot">=</span> c.L<span class="fl">.1</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">1.</span>scl<span class="sc">$</span>y))</span>
<span id="cb20-815"><a href="#cb20-815" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-816"><a href="#cb20-816" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb20-817"><a href="#cb20-817" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.2</span>, basis, L)</span>
<span id="cb20-818"><a href="#cb20-818" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-819"><a href="#cb20-819" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data<span class="fl">.2</span>, basis, Lmax)</span>
<span id="cb20-820"><a href="#cb20-820" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb20-821"><a href="#cb20-821" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb20-822"><a href="#cb20-822" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb20-823"><a href="#cb20-823" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb20-824"><a href="#cb20-824" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb20-825"><a href="#cb20-825" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb20-826"><a href="#cb20-826" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb20-827"><a href="#cb20-827" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-828"><a href="#cb20-828" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L<span class="fl">.1</span> <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb20-829"><a href="#cb20-829" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L<span class="fl">.1</span> <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb20-830"><a href="#cb20-830" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-831"><a href="#cb20-831" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">d.L =</span> d.L<span class="fl">.1</span>, <span class="at">d.L.Lmax =</span> d.L.Lmax<span class="fl">.2</span>))</span>
<span id="cb20-832"><a href="#cb20-832" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-833"><a href="#cb20-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-834"><a href="#cb20-834" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-835"><a href="#cb20-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-836"><a href="#cb20-836" aria-hidden="true" tabindex="-1"></a>dfTrue <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-837"><a href="#cb20-837" aria-hidden="true" tabindex="-1"></a>                    <span class="at">f =</span> <span class="fu">double</span>(),</span>
<span id="cb20-838"><a href="#cb20-838" aria-hidden="true" tabindex="-1"></a>                    <span class="at">basis =</span> <span class="fu">character</span>()</span>
<span id="cb20-839"><a href="#cb20-839" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-840"><a href="#cb20-840" aria-hidden="true" tabindex="-1"></a>dfBandup <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-841"><a href="#cb20-841" aria-hidden="true" tabindex="-1"></a>                      <span class="at">bandup =</span> <span class="fu">double</span>(),</span>
<span id="cb20-842"><a href="#cb20-842" aria-hidden="true" tabindex="-1"></a>                      <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-843"><a href="#cb20-843" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb20-844"><a href="#cb20-844" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-845"><a href="#cb20-845" aria-hidden="true" tabindex="-1"></a>dfBandlow <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-846"><a href="#cb20-846" aria-hidden="true" tabindex="-1"></a>                       <span class="at">bandlow =</span> <span class="fu">double</span>(),</span>
<span id="cb20-847"><a href="#cb20-847" aria-hidden="true" tabindex="-1"></a>                       <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-848"><a href="#cb20-848" aria-hidden="true" tabindex="-1"></a>                       <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb20-849"><a href="#cb20-849" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-850"><a href="#cb20-850" aria-hidden="true" tabindex="-1"></a>dfdL <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-851"><a href="#cb20-851" aria-hidden="true" tabindex="-1"></a>                  <span class="at">dLLmax =</span> <span class="fu">double</span>(),</span>
<span id="cb20-852"><a href="#cb20-852" aria-hidden="true" tabindex="-1"></a>                  <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-853"><a href="#cb20-853" aria-hidden="true" tabindex="-1"></a>                  <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb20-854"><a href="#cb20-854" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-855"><a href="#cb20-855" aria-hidden="true" tabindex="-1"></a>dfdLLmax <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">double</span>(),</span>
<span id="cb20-856"><a href="#cb20-856" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dL =</span> <span class="fu">double</span>(),</span>
<span id="cb20-857"><a href="#cb20-857" aria-hidden="true" tabindex="-1"></a>                      <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-858"><a href="#cb20-858" aria-hidden="true" tabindex="-1"></a>                      <span class="at">dimension =</span> <span class="fu">character</span>()</span>
<span id="cb20-859"><a href="#cb20-859" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-860"><a href="#cb20-860" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>)</span>
<span id="cb20-861"><a href="#cb20-861" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-862"><a href="#cb20-862" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>,<span class="at">sd=</span><span class="dv">1</span>,<span class="at">L.star=</span><span class="dv">10</span>, <span class="at">L.eps =</span> <span class="dv">20</span>, <span class="at">alpha.mu =</span> <span class="cn">NULL</span>, <span class="at">basis =</span> basis, <span class="at">f.true =</span> <span class="cn">NULL</span>)</span>
<span id="cb20-863"><a href="#cb20-863" aria-hidden="true" tabindex="-1"></a>  dfTrue <span class="ot">=</span> <span class="fu">rbind</span>(dfTrue, <span class="fu">data.frame</span>(<span class="at">Time =</span>  data<span class="sc">$</span>time,</span>
<span id="cb20-864"><a href="#cb20-864" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">f =</span> data<span class="sc">$</span>f.true,</span>
<span id="cb20-865"><a href="#cb20-865" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb20-866"><a href="#cb20-866" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-867"><a href="#cb20-867" aria-hidden="true" tabindex="-1"></a>  crit.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">ncol =</span> <span class="dv">3</span>, <span class="at">nrow =</span> <span class="dv">30</span>)</span>
<span id="cb20-868"><a href="#cb20-868" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-869"><a href="#cb20-869" aria-hidden="true" tabindex="-1"></a>    conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-870"><a href="#cb20-870" aria-hidden="true" tabindex="-1"></a>    crit.sel[L,] <span class="ot">=</span><span class="fu">c</span>(<span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L), <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax),</span>
<span id="cb20-871"><a href="#cb20-871" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">sum</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L<span class="sc">+</span>conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax)))</span>
<span id="cb20-872"><a href="#cb20-872" aria-hidden="true" tabindex="-1"></a>    dfBandup <span class="ot">=</span> <span class="fu">rbind</span>(dfBandup, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-873"><a href="#cb20-873" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">bandup =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up),</span>
<span id="cb20-874"><a href="#cb20-874" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-875"><a href="#cb20-875" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb20-876"><a href="#cb20-876" aria-hidden="true" tabindex="-1"></a>    dfBandlow <span class="ot">=</span> <span class="fu">rbind</span>(dfBandlow, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-877"><a href="#cb20-877" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">bandlow =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low),</span>
<span id="cb20-878"><a href="#cb20-878" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-879"><a href="#cb20-879" aria-hidden="true" tabindex="-1"></a>                                            <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb20-880"><a href="#cb20-880" aria-hidden="true" tabindex="-1"></a>    dfdL <span class="ot">=</span> <span class="fu">rbind</span>(dfdL, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-881"><a href="#cb20-881" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dL =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L),</span>
<span id="cb20-882"><a href="#cb20-882" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-883"><a href="#cb20-883" aria-hidden="true" tabindex="-1"></a>                                  <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb20-884"><a href="#cb20-884" aria-hidden="true" tabindex="-1"></a>    dfdLLmax <span class="ot">=</span> <span class="fu">rbind</span>(dfdLLmax, <span class="fu">data.frame</span>(<span class="at">Time =</span> data<span class="sc">$</span>time,</span>
<span id="cb20-885"><a href="#cb20-885" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dLLmax =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax),</span>
<span id="cb20-886"><a href="#cb20-886" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time)),</span>
<span id="cb20-887"><a href="#cb20-887" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">dimension =</span> <span class="fu">as.factor</span>(<span class="fu">rep</span>(L, <span class="fu">length</span>(data<span class="sc">$</span>time)))))</span>
<span id="cb20-888"><a href="#cb20-888" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-889"><a href="#cb20-889" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-890"><a href="#cb20-890" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-891"><a href="#cb20-891" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-892"><a href="#cb20-892" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span></span>
<span id="cb20-893"><a href="#cb20-893" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfTrue, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> f)) <span class="sc">+</span></span>
<span id="cb20-894"><a href="#cb20-894" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandup, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandup, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb20-895"><a href="#cb20-895" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandlow, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandlow, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb20-896"><a href="#cb20-896" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span> basis)</span>
<span id="cb20-897"><a href="#cb20-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-898"><a href="#cb20-898" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb20-899"><a href="#cb20-899" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdL, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dL, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb20-900"><a href="#cb20-900" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>( <span class="sc">~</span> basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"d.L"</span>)</span>
<span id="cb20-901"><a href="#cb20-901" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-902"><a href="#cb20-902" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>() <span class="sc">+</span> </span>
<span id="cb20-903"><a href="#cb20-903" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfdLLmax, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> dLLmax, <span class="at">group =</span> dimension, <span class="at">color =</span> dimension), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb20-904"><a href="#cb20-904" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>( <span class="sc">~</span> basis) <span class="sc">+</span> <span class="fu">ylab</span>(<span class="st">"d.L.Lmax"</span>)</span>
<span id="cb20-905"><a href="#cb20-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-906"><a href="#cb20-906" aria-hidden="true" tabindex="-1"></a><span class="fu">ggarrange</span>(p1, p2, p3, <span class="at">nrow =</span> <span class="dv">3</span>, <span class="at">common.legend =</span> <span class="cn">TRUE</span>, <span class="at">legend =</span> <span class="st">"bottom"</span>)</span>
<span id="cb20-907"><a href="#cb20-907" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-908"><a href="#cb20-908" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-909"><a href="#cb20-909" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-910"><a href="#cb20-910" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-911"><a href="#cb20-911" aria-hidden="true" tabindex="-1"></a>In @tbl-levLstar, we simulate 1000 repeated datasets with two sample sizes $n=50$ and $n=150$. For each dataset, we compute  the confidence band defined in @prp-CBf with a theoretical confidence level of $1-\alpha\beta=0.95$ and for different values of $L$. Then the confidence level is approximated as the proportion of confidence bands containing the true function $f$. Remark that when $L&lt;L^{\varepsilon}$, the level is the expected one, that is 0.95. When $L&gt;L^{\varepsilon}$, the level is not more ensured, as explained before. Indeed the term $d^{L,L^{\max}}$ is mainly equal to 0, and the level is close to $1-\alpha$ instead of $1-\alpha\beta$. This is not the case for the band in @sec-bandSun, as this is due to the correction of the bias. </span>
<span id="cb20-914"><a href="#cb20-914" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb20-915"><a href="#cb20-915" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: tbl-levLstar</span></span>
<span id="cb20-916"><a href="#cb20-916" aria-hidden="true" tabindex="-1"></a><span class="co">#| tbl-cap: "Illustrative example. We display the level of confidence for the proposed confidence band, for several L in rows and several n in columns."</span></span>
<span id="cb20-917"><a href="#cb20-917" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-918"><a href="#cb20-918" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb20-919"><a href="#cb20-919" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb20-920"><a href="#cb20-920" aria-hidden="true" tabindex="-1"></a>  nb.repeat <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb20-921"><a href="#cb20-921" aria-hidden="true" tabindex="-1"></a>  n.test <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb20-922"><a href="#cb20-922" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">11</span>,<span class="dv">15</span>,<span class="dv">21</span>, <span class="dv">25</span>)</span>
<span id="cb20-923"><a href="#cb20-923" aria-hidden="true" tabindex="-1"></a>  vec.n <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">50</span>, <span class="dv">150</span>)  </span>
<span id="cb20-924"><a href="#cb20-924" aria-hidden="true" tabindex="-1"></a>  basis <span class="ot">=</span> <span class="st">"Legendre"</span></span>
<span id="cb20-925"><a href="#cb20-925" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">=</span> <span class="fu">seq</span>(<span class="fu">min</span>(data<span class="sc">$</span>time), <span class="fu">max</span>(data<span class="sc">$</span>time), <span class="at">length.out =</span> n.test)</span>
<span id="cb20-926"><a href="#cb20-926" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> <span class="fu">max</span>(vec.L), <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb20-927"><a href="#cb20-927" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-928"><a href="#cb20-928" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-929"><a href="#cb20-929" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (ind.n <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(vec.n)){</span>
<span id="cb20-930"><a href="#cb20-930" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (L <span class="cf">in</span> vec.L){<span class="fu">print</span>(L)</span>
<span id="cb20-931"><a href="#cb20-931" aria-hidden="true" tabindex="-1"></a>      cpt <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb20-932"><a href="#cb20-932" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nb.repeat){</span>
<span id="cb20-933"><a href="#cb20-933" aria-hidden="true" tabindex="-1"></a>        <span class="fu">set.seed</span>(rep)</span>
<span id="cb20-934"><a href="#cb20-934" aria-hidden="true" tabindex="-1"></a>        data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span>vec.n[ind.n], <span class="at">basis =</span> <span class="st">"Legendre"</span>)</span>
<span id="cb20-935"><a href="#cb20-935" aria-hidden="true" tabindex="-1"></a>        conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.2</span>, <span class="at">beta=</span><span class="fl">0.2</span>)</span>
<span id="cb20-936"><a href="#cb20-936" aria-hidden="true" tabindex="-1"></a>        f.true <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> data<span class="sc">$</span>f.true, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb20-937"><a href="#cb20-937" aria-hidden="true" tabindex="-1"></a>        f.hat.up <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb20-938"><a href="#cb20-938" aria-hidden="true" tabindex="-1"></a>        f.hat.low <span class="ot">=</span> stats<span class="sc">::</span><span class="fu">spline</span>(<span class="at">x =</span> data<span class="sc">$</span>time, <span class="at">y =</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low, <span class="at">xout =</span> time, <span class="at">method =</span> <span class="st">"natural"</span>)<span class="sc">$</span>y</span>
<span id="cb20-939"><a href="#cb20-939" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">sum</span>(f.true<span class="sc">&lt;</span> f.hat.up)<span class="sc">+</span><span class="fu">sum</span>(f.true<span class="sc">&gt;</span> f.hat.low) <span class="sc">==</span> <span class="dv">2</span><span class="sc">*</span>n.test){</span>
<span id="cb20-940"><a href="#cb20-940" aria-hidden="true" tabindex="-1"></a>          cpt <span class="ot">=</span> cpt<span class="sc">+</span><span class="dv">1</span>} </span>
<span id="cb20-941"><a href="#cb20-941" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb20-942"><a href="#cb20-942" aria-hidden="true" tabindex="-1"></a>      perf[L,ind.n] <span class="ot">=</span> cpt<span class="sc">/</span>nb.repeat</span>
<span id="cb20-943"><a href="#cb20-943" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-944"><a href="#cb20-944" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-945"><a href="#cb20-945" aria-hidden="true" tabindex="-1"></a>  perf <span class="ot">=</span> perf[vec.L,]</span>
<span id="cb20-946"><a href="#cb20-946" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rownames</span>(perf) <span class="ot">=</span> vec.L</span>
<span id="cb20-947"><a href="#cb20-947" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(perf) <span class="ot">=</span> vec.n</span>
<span id="cb20-948"><a href="#cb20-948" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(perf, <span class="at">file =</span> <span class="st">"Res_Tab2.RData"</span>)</span>
<span id="cb20-949"><a href="#cb20-949" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_Tab2.RData'</span>)}</span>
<span id="cb20-950"><a href="#cb20-950" aria-hidden="true" tabindex="-1"></a><span class="fu">kable</span>(perf)</span>
<span id="cb20-951"><a href="#cb20-951" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-952"><a href="#cb20-952" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-953"><a href="#cb20-953" aria-hidden="true" tabindex="-1"></a><span class="fu">## Influence of $L$ {#sec-SelectionL2}</span></span>
<span id="cb20-954"><a href="#cb20-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-955"><a href="#cb20-955" aria-hidden="true" tabindex="-1"></a>This approach gives a collection of confidence bands for different values of $L$. The confidence bands have different widths for a same confidence level $1-\alpha\beta$. It is thus natural to want to select one of them. This means we want to select the best dimension $L$ among the collection $<span class="sc">\{</span>1, \ldots, L_{\max}<span class="sc">\}</span>$. We need to define what  "best" means.  It is quite intuitive to focus on the band that is the thinnest. Thinnest could be thought in different norms, the infinity norm, the L1 norm. Here we consider the infinity norm of the width of the confidence band, which gives a preference to smooth bands. We thus define the following criteria</span>
<span id="cb20-956"><a href="#cb20-956" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-957"><a href="#cb20-957" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-958"><a href="#cb20-958" aria-hidden="true" tabindex="-1"></a>\hat L = \arg\min_L \left<span class="sc">\{</span>\sup_{t} |\hat\theta_2^L(t)-\hat\theta_1^L(t)|\right<span class="sc">\}</span> = \arg\min_L \left<span class="sc">\{</span>\sup_t | \hat d^L(t) + \hat d^{L,L_{\max}}(t)|\right<span class="sc">\}</span>.</span>
<span id="cb20-959"><a href="#cb20-959" aria-hidden="true" tabindex="-1"></a>$$ {#eq-def-Lhat}</span>
<span id="cb20-960"><a href="#cb20-960" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-961"><a href="#cb20-961" aria-hidden="true" tabindex="-1"></a>We illustrate the different terms involved in @eq-def-Lhat. In @fig-dLLmax, we plot for a given dataset, the infinity norm of the width of the band $\hat d^L(t) + \hat d^{L,L_{\max}}(t)$ (top), of  $\hat d^L(t)$ (middle) and $\hat d^{L,L_{\max}}(t)$ (bottom) functions obtained with the Fourier (left column), Legendre (middle column) and Spline (right column) basis. As already said, $\|\hat d^L\|_{\infty}$ increases with $L$ while  $\|\hat d^{L,L_{\max}}\|_{\infty}$ decreases (and is zero when $L&gt;L\varepsilon$). The width of the band wrt $L$ does not have a $U$-shape, as expected. It is thus difficult to minimize this criterion. </span>
<span id="cb20-962"><a href="#cb20-962" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-963"><a href="#cb20-963" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "50%", fig.width=7}</span></span>
<span id="cb20-964"><a href="#cb20-964" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-dLLmax</span></span>
<span id="cb20-965"><a href="#cb20-965" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For a given dataset, we calculate the norm of the width of the confidence band (top), of the dL function (middle) and the dLLmax function (bottom), for several dimensions L and for Fourier (left column), Legendre (middle column) and Splines (right column) basis." </span></span>
<span id="cb20-966"><a href="#cb20-966" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb20-967"><a href="#cb20-967" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-968"><a href="#cb20-968" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-969"><a href="#cb20-969" aria-hidden="true" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Norm =</span> <span class="fu">double</span>(),</span>
<span id="cb20-970"><a href="#cb20-970" aria-hidden="true" tabindex="-1"></a>                <span class="at">type =</span> <span class="fu">character</span>(),</span>
<span id="cb20-971"><a href="#cb20-971" aria-hidden="true" tabindex="-1"></a>                <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-972"><a href="#cb20-972" aria-hidden="true" tabindex="-1"></a>                <span class="at">dimension =</span> <span class="fu">integer</span>()</span>
<span id="cb20-973"><a href="#cb20-973" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb20-974"><a href="#cb20-974" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb20-975"><a href="#cb20-975" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-976"><a href="#cb20-976" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb20-977"><a href="#cb20-977" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb20-978"><a href="#cb20-978" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb20-979"><a href="#cb20-979" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-980"><a href="#cb20-980" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> d.L <span class="ot">=</span> d.L.Lmax <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb20-981"><a href="#cb20-981" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-982"><a href="#cb20-982" aria-hidden="true" tabindex="-1"></a>    conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, basis, L, <span class="at">Lmax =</span> L.max, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb20-983"><a href="#cb20-983" aria-hidden="true" tabindex="-1"></a>    length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up)))</span>
<span id="cb20-984"><a href="#cb20-984" aria-hidden="true" tabindex="-1"></a>    d.L <span class="ot">=</span> <span class="fu">c</span>(d.L, <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L))</span>
<span id="cb20-985"><a href="#cb20-985" aria-hidden="true" tabindex="-1"></a>    d.L.Lmax <span class="ot">=</span> <span class="fu">c</span>(d.L.Lmax, <span class="fu">max</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>d.L.Lmax))</span>
<span id="cb20-986"><a href="#cb20-986" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-987"><a href="#cb20-987" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-988"><a href="#cb20-988" aria-hidden="true" tabindex="-1"></a>  df <span class="ot">=</span> <span class="fu">rbind</span>(df, <span class="fu">data.frame</span> (<span class="at">Norm =</span> <span class="fu">c</span>(length.band, d.L, d.L.Lmax),</span>
<span id="cb20-989"><a href="#cb20-989" aria-hidden="true" tabindex="-1"></a>                             <span class="at">type =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Band width norm"</span>, <span class="st">"d.L norm"</span>, <span class="st">"d.L.Lmax norm"</span>), <span class="at">each =</span> <span class="fu">length</span>(vec.L)),</span>
<span id="cb20-990"><a href="#cb20-990" aria-hidden="true" tabindex="-1"></a>                             <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="dv">3</span><span class="sc">*</span> <span class="fu">length</span>(vec.L)),</span>
<span id="cb20-991"><a href="#cb20-991" aria-hidden="true" tabindex="-1"></a>                             <span class="at">dimension =</span> <span class="fu">rep</span>(vec.L, <span class="dv">3</span>)))</span>
<span id="cb20-992"><a href="#cb20-992" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-993"><a href="#cb20-993" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-994"><a href="#cb20-994" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Norm, <span class="at">fill =</span> type)) <span class="sc">+</span></span>
<span id="cb20-995"><a href="#cb20-995" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span> </span>
<span id="cb20-996"><a href="#cb20-996" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(type <span class="sc">~</span> basis, <span class="at">scale =</span> <span class="st">'free'</span>) <span class="sc">+</span> <span class="fu">xlab</span>(<span class="st">"L"</span>)</span>
<span id="cb20-997"><a href="#cb20-997" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-998"><a href="#cb20-998" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-999"><a href="#cb20-999" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1000"><a href="#cb20-1000" aria-hidden="true" tabindex="-1"></a>We then evaluate the performance of the selection criteria. To do that, we simulate 100 repeated datasets. Confidence bands and the norm of their widths are computed for several $L$. We apply the selection criteria and plot the distribution of the estimated dimension $\hat L$ in @fig-modelsel, for the three basis families. The estimated dimension is almost always larger than the true $L^*=11$. Being larger is not a problem and  the selected band is unbiased and has the correct level as soon as $L^\varepsilon$ is large, which was the objective. However, the criteria has the tendency to select a (too) smooth band. It is not satisfactory not to be able to select the true dimension. This is why we propose a new approach in @sec-modsel. In @sec-comparisonBands, we also illustrate that this band is too conservative \textcolor{red}{modifier}. </span>
<span id="cb20-1001"><a href="#cb20-1001" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1002"><a href="#cb20-1002" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1003"><a href="#cb20-1003" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-modelsel</span></span>
<span id="cb20-1004"><a href="#cb20-1004" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. From 100 datasets, we calculate the distribution of the estimated dimension L. The true dimension is $L^*  =  11$. " </span></span>
<span id="cb20-1005"><a href="#cb20-1005" aria-hidden="true" tabindex="-1"></a><span class="co">#|   </span></span>
<span id="cb20-1006"><a href="#cb20-1006" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb20-1007"><a href="#cb20-1007" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb20-1008"><a href="#cb20-1008" aria-hidden="true" tabindex="-1"></a>  repet <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb20-1009"><a href="#cb20-1009" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1010"><a href="#cb20-1010" aria-hidden="true" tabindex="-1"></a>  dfBandWidth <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">double</span>(),</span>
<span id="cb20-1011"><a href="#cb20-1011" aria-hidden="true" tabindex="-1"></a>                           <span class="at">basis =</span> <span class="fu">character</span>(),</span>
<span id="cb20-1012"><a href="#cb20-1012" aria-hidden="true" tabindex="-1"></a>                           <span class="at">dimension =</span> <span class="fu">integer</span>()</span>
<span id="cb20-1013"><a href="#cb20-1013" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb20-1014"><a href="#cb20-1014" aria-hidden="true" tabindex="-1"></a>  dfLhat <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Lhat =</span> <span class="fu">double</span>(), <span class="at">L =</span> <span class="fu">integer</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb20-1015"><a href="#cb20-1015" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-1016"><a href="#cb20-1016" aria-hidden="true" tabindex="-1"></a>    vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb20-1017"><a href="#cb20-1017" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb20-1018"><a href="#cb20-1018" aria-hidden="true" tabindex="-1"></a>    mod.sel <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow =</span> repet, <span class="at">ncol =</span> <span class="dv">4</span>)</span>
<span id="cb20-1019"><a href="#cb20-1019" aria-hidden="true" tabindex="-1"></a>    Lmax <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb20-1020"><a href="#cb20-1020" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (rep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>repet){</span>
<span id="cb20-1021"><a href="#cb20-1021" aria-hidden="true" tabindex="-1"></a>      <span class="fu">set.seed</span>(rep)</span>
<span id="cb20-1022"><a href="#cb20-1022" aria-hidden="true" tabindex="-1"></a>      data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>, <span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb20-1023"><a href="#cb20-1023" aria-hidden="true" tabindex="-1"></a>      length.band <span class="ot">=</span> <span class="cn">NULL</span></span>
<span id="cb20-1024"><a href="#cb20-1024" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-1025"><a href="#cb20-1025" aria-hidden="true" tabindex="-1"></a>        conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L.star.2</span>(data, <span class="at">basis =</span> basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>), <span class="at">beta =</span> <span class="fu">sqrt</span>(<span class="fl">0.05</span>))</span>
<span id="cb20-1026"><a href="#cb20-1026" aria-hidden="true" tabindex="-1"></a>        length.band <span class="ot">=</span> <span class="fu">c</span>(length.band, <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up<span class="sc">-</span>conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low)))</span>
<span id="cb20-1027"><a href="#cb20-1027" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb20-1028"><a href="#cb20-1028" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>] <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">min</span>(length.band), vec.L[<span class="fu">which.min</span>(length.band)])</span>
<span id="cb20-1029"><a href="#cb20-1029" aria-hidden="true" tabindex="-1"></a>      conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> Lmax, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-1030"><a href="#cb20-1030" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">3</span>] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.max<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L.max<span class="sc">$</span>f.hat.up))</span>
<span id="cb20-1031"><a href="#cb20-1031" aria-hidden="true" tabindex="-1"></a>      conf.band.L.star <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> <span class="dv">10</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-1032"><a href="#cb20-1032" aria-hidden="true" tabindex="-1"></a>      mod.sel[rep,<span class="dv">4</span>] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L.star<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L.star<span class="sc">$</span>f.hat.up))</span>
<span id="cb20-1033"><a href="#cb20-1033" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-1034"><a href="#cb20-1034" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-1035"><a href="#cb20-1035" aria-hidden="true" tabindex="-1"></a>    dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> <span class="fu">c</span>(mod.sel[ ,<span class="dv">1</span>], mod.sel[ ,<span class="dv">3</span>], mod.sel[ ,<span class="dv">4</span>]),</span>
<span id="cb20-1036"><a href="#cb20-1036" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis, repet<span class="sc">*</span><span class="dv">3</span>),</span>
<span id="cb20-1037"><a href="#cb20-1037" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="fu">c</span>(<span class="st">"Lhat"</span>, <span class="st">"Lmax"</span>, <span class="st">"Lstar"</span>), <span class="at">each =</span> repet)))  </span>
<span id="cb20-1038"><a href="#cb20-1038" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-1039"><a href="#cb20-1039" aria-hidden="true" tabindex="-1"></a>    dfLhat <span class="ot">=</span> <span class="fu">rbind</span>(dfLhat, <span class="fu">data.frame</span>(</span>
<span id="cb20-1040"><a href="#cb20-1040" aria-hidden="true" tabindex="-1"></a>      <span class="at">L =</span> vec.L,</span>
<span id="cb20-1041"><a href="#cb20-1041" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel[,<span class="dv">2</span>], <span class="at">levels =</span> vec.L))),</span>
<span id="cb20-1042"><a href="#cb20-1042" aria-hidden="true" tabindex="-1"></a>      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb20-1043"><a href="#cb20-1043" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-1044"><a href="#cb20-1044" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-1045"><a href="#cb20-1045" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1046"><a href="#cb20-1046" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab3_n50_3basisBandWidth.RData"</span>)</span>
<span id="cb20-1047"><a href="#cb20-1047" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfLhat, <span class="at">file =</span> <span class="st">"Res_Tab3_n50_3basisLhat.RData"</span>)</span>
<span id="cb20-1048"><a href="#cb20-1048" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisBandWidth.RData'</span>)</span>
<span id="cb20-1049"><a href="#cb20-1049" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisLhat.RData'</span>)}</span>
<span id="cb20-1050"><a href="#cb20-1050" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1051"><a href="#cb20-1051" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> dfLhat, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat)) <span class="sc">+</span></span>
<span id="cb20-1052"><a href="#cb20-1052" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb20-1053"><a href="#cb20-1053" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-1054"><a href="#cb20-1054" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1055"><a href="#cb20-1055" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1056"><a href="#cb20-1056" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1057"><a href="#cb20-1057" aria-hidden="true" tabindex="-1"></a><span class="fu">## Comparison with the confidence bands of @sec-bandSun {#sec-comparisonBands}</span></span>
<span id="cb20-1058"><a href="#cb20-1058" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1059"><a href="#cb20-1059" aria-hidden="true" tabindex="-1"></a>The  reformulation of the band around $\underline{\hat f}_2^{ L_{\max}, L^*}$  is close to the band presented in @sec-bandSun for $L=L_{\max}$, that is a band centered around $\underline{\hat f}^{ L_{\max}, L^*}$. A natural question is to understand what is the gain by doing so instead of using the band from @sec-bandSun with $L=L_{\max}$, namely the band $[\underline{\hat f}^{ L_{\max}, L^*}(t)-\hat d^{L_{\max}}(t); \underline{\hat f}^{ L_{\max}, L^*}(t)+\hat d^{L_{\max}}(t)]$. To do that, we have to understand the behavior of the different terms. </span>
<span id="cb20-1060"><a href="#cb20-1060" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1061"><a href="#cb20-1061" aria-hidden="true" tabindex="-1"></a>It is difficult to compare theoretically the width of the two bands. </span>
<span id="cb20-1062"><a href="#cb20-1062" aria-hidden="true" tabindex="-1"></a>We compare them with simulations. For 100 repeated datasets, we compute three different confidence bands: the band defined in @prp-CBf with $\hat L$ defined in @eq-def-Lhat, the band constructed in @sec-bandSun with  $L_{\max}$ and the ideal (and not accessible) band constructed in @sec-bandSun with the true $L^*$. In @fig-width, we present the boxplots of the norms of the width of the band with $\hat L$ (left), with $L_{\max}$ (middle) and $L^*$ (right).  </span>
<span id="cb20-1063"><a href="#cb20-1063" aria-hidden="true" tabindex="-1"></a>The width of the confidence band with the true $L^*$ is smaller, which is expected but unfortunately not achievable. What was not expected, but sad, is that the width of the confidence band constructed in @sec-bandSun with some $L_{\max}$ is smaller than our band with a correction of the bias and the model selection criteria. This may be understood because we estimate two different quantities, on smaller dataset, for more conservative level ($1-\alpha$ and $1-\beta$ respectively) to achieve at the end the confidence level of $1-\alpha\beta$. The use of the two independent subsamples is mandatory to control the probability in the proof of @thm-sunLoader. Therefore it is not possible to correct this problem.  In the next section, we come back to the confidence bands proposed in @sec-bandSun and propose a model selection criterion to take into account the bias. </span>
<span id="cb20-1064"><a href="#cb20-1064" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1065"><a href="#cb20-1065" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1066"><a href="#cb20-1066" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-width</span></span>
<span id="cb20-1067"><a href="#cb20-1067" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. We display within boxplots the confidence band's width over 100 repetitions for the model selected by our criterion, some fixed Lmax and the true (unknown) $L^{*}$ for Fourier (left), Legendre (middle) and Splines (right) basis."</span></span>
<span id="cb20-1068"><a href="#cb20-1068" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb20-1069"><a href="#cb20-1069" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1070"><a href="#cb20-1070" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfBandWidth, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Band.width)) <span class="sc">+</span> </span>
<span id="cb20-1071"><a href="#cb20-1071" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb20-1072"><a href="#cb20-1072" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-1073"><a href="#cb20-1073" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1074"><a href="#cb20-1074" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1075"><a href="#cb20-1075" aria-hidden="true" tabindex="-1"></a><span class="fu"># Selection criteria of the best confidence band accounting for the bias {#sec-modsel}</span></span>
<span id="cb20-1076"><a href="#cb20-1076" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1077"><a href="#cb20-1077" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1078"><a href="#cb20-1078" aria-hidden="true" tabindex="-1"></a>In this section, we want to propose a new heuristic criteria going back to the  definition of the band itself seen as the estimation of a quantile of a certain empirical process. The criteria is inspired by model selection tools to select the best dimension $L$.</span>
<span id="cb20-1079"><a href="#cb20-1079" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1080"><a href="#cb20-1080" aria-hidden="true" tabindex="-1"></a>We work on the quantile $q^L$ introduced in @eq-qL,  its oracle version $q^{L^*}$ for the level </span>
<span id="cb20-1081"><a href="#cb20-1081" aria-hidden="true" tabindex="-1"></a>$L^*$ and the estimation $\hat q^L$. All of them are scalar, in a collection of scalars, with $L=1, \ldots, L_{\max}$. A natural criteria to choose the best $L$  is such that the estimator $\hat q^L$ minimizes the quadratic error $\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right)$. However, this quadratic error is unknown as $q^{L^*}$ is unknown. We can not directly use it.</span>
<span id="cb20-1082"><a href="#cb20-1082" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1083"><a href="#cb20-1083" aria-hidden="true" tabindex="-1"></a>Instead, we study $\|\hat{q}^{L_{\max}}-\hat q^L\|^2$. We assume that $L_{\max}$ is large enough such that $\underline f^{L_{\max},L^*}=f^{L^*}$.</span>
<span id="cb20-1084"><a href="#cb20-1084" aria-hidden="true" tabindex="-1"></a>While  the theoretical error decreases when $L&lt;L^*$ and increases when $L&gt;L^*$,  this approximation is still decreasing when $L&gt;L^*$, as illustrated in @fig-crit1. </span>
<span id="cb20-1085"><a href="#cb20-1085" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1086"><a href="#cb20-1086" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1087"><a href="#cb20-1087" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-crit1</span></span>
<span id="cb20-1088"><a href="#cb20-1088" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For a given simulated dataset, we show the behavior of the error as a function of the dimension L, for Fourier (left), Legendre (middle) and Splines (right) basis."</span></span>
<span id="cb20-1089"><a href="#cb20-1089" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb20-1090"><a href="#cb20-1090" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1091"><a href="#cb20-1091" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L.star<span class="fl">.3</span> <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb20-1092"><a href="#cb20-1092" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb20-1093"><a href="#cb20-1093" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb20-1094"><a href="#cb20-1094" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb20-1095"><a href="#cb20-1095" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb20-1096"><a href="#cb20-1096" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1097"><a href="#cb20-1097" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb20-1098"><a href="#cb20-1098" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb20-1099"><a href="#cb20-1099" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-1100"><a href="#cb20-1100" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb20-1101"><a href="#cb20-1101" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb20-1102"><a href="#cb20-1102" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb20-1103"><a href="#cb20-1103" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb20-1104"><a href="#cb20-1104" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1105"><a href="#cb20-1105" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb20-1106"><a href="#cb20-1106" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb20-1107"><a href="#cb20-1107" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-1108"><a href="#cb20-1108" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb20-1109"><a href="#cb20-1109" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb20-1110"><a href="#cb20-1110" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb20-1111"><a href="#cb20-1111" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb20-1112"><a href="#cb20-1112" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb20-1113"><a href="#cb20-1113" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb20-1114"><a href="#cb20-1114" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb20-1115"><a href="#cb20-1115" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb20-1116"><a href="#cb20-1116" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1117"><a href="#cb20-1117" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb20-1118"><a href="#cb20-1118" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb20-1119"><a href="#cb20-1119" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1120"><a href="#cb20-1120" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">c.L =</span> c.L, <span class="at">c.L.Lmax =</span> c.L.Lmax<span class="fl">.2</span>))</span>
<span id="cb20-1121"><a href="#cb20-1121" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-1122"><a href="#cb20-1122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1123"><a href="#cb20-1123" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb20-1124"><a href="#cb20-1124" aria-hidden="true" tabindex="-1"></a>dfCriterion <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">criterion =</span> <span class="fu">double</span>(),</span>
<span id="cb20-1125"><a href="#cb20-1125" aria-hidden="true" tabindex="-1"></a>                         <span class="at">dimension =</span> <span class="fu">integer</span>(),</span>
<span id="cb20-1126"><a href="#cb20-1126" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb20-1127"><a href="#cb20-1127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1128"><a href="#cb20-1128" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-1129"><a href="#cb20-1129" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb20-1130"><a href="#cb20-1130" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>) }</span>
<span id="cb20-1131"><a href="#cb20-1131" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1132"><a href="#cb20-1132" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">L.eps =</span> <span class="dv">28</span>)</span>
<span id="cb20-1133"><a href="#cb20-1133" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-1134"><a href="#cb20-1134" aria-hidden="true" tabindex="-1"></a>  c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L  </span>
<span id="cb20-1135"><a href="#cb20-1135" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1136"><a href="#cb20-1136" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-1137"><a href="#cb20-1137" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb20-1138"><a href="#cb20-1138" aria-hidden="true" tabindex="-1"></a>    length.band[L] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L<span class="sc">$</span>f.hat.up))</span>
<span id="cb20-1139"><a href="#cb20-1139" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb20-1140"><a href="#cb20-1140" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-1141"><a href="#cb20-1141" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb20-1142"><a href="#cb20-1142" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L])<span class="co"># + lambda * vec.L/((dim(data$y)[1]))</span></span>
<span id="cb20-1143"><a href="#cb20-1143" aria-hidden="true" tabindex="-1"></a>  dfCriterion <span class="ot">=</span> <span class="fu">rbind</span>(dfCriterion, <span class="fu">data.frame</span>(<span class="at">error =</span> crit,</span>
<span id="cb20-1144"><a href="#cb20-1144" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">dimension =</span> vec.L,</span>
<span id="cb20-1145"><a href="#cb20-1145" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb20-1146"><a href="#cb20-1146" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-1147"><a href="#cb20-1147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1148"><a href="#cb20-1148" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfCriterion, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> error)) <span class="sc">+</span> </span>
<span id="cb20-1149"><a href="#cb20-1149" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>()<span class="sc">+</span></span>
<span id="cb20-1150"><a href="#cb20-1150" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-1151"><a href="#cb20-1151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1152"><a href="#cb20-1152" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1153"><a href="#cb20-1153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1154"><a href="#cb20-1154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1155"><a href="#cb20-1155" aria-hidden="true" tabindex="-1"></a>The, we recognize a behavior similar to a bias, high with model of small dimension, and small when dimension is large. Selecting a model using this criterion will always overfit the data. Thus, we propose to penalize by the dimension, as usually in model selection criterion.</span>
<span id="cb20-1156"><a href="#cb20-1156" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1157"><a href="#cb20-1157" aria-hidden="true" tabindex="-1"></a>\textcolor{red}{old paragraph - start}</span>
<span id="cb20-1158"><a href="#cb20-1158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1159"><a href="#cb20-1159" aria-hidden="true" tabindex="-1"></a>Instead, we use the classic decomposition into bias and variance:</span>
<span id="cb20-1160"><a href="#cb20-1160" aria-hidden="true" tabindex="-1"></a>$$\mathbb{E}\left( \|q^{L^*}-\hat q^L\|^2\right) = \|q^{L^*}-q^L\|^2+\mathbb{E}\left( \|q^L-\hat q^L\|^2\right)=:b^L+v^L,$$</span>
<span id="cb20-1161"><a href="#cb20-1161" aria-hidden="true" tabindex="-1"></a>where the first term $b^L = \|q^{L^*}-q^L\|^2$ is the bias term and $v^L = \mathbb{E}\left( \|q^L-\hat q^L\|^2\right)$ is the variance term. Note that these terms are not functional and different from the functional bias defined previously. The two terms are unknown. Let us denote $\hat b^L$ and $\hat v^L$ their estimators. We assume that $L_{\max}$ is large enough such that $\underline f^{L_{\max},L^*}=f^{L^*}$. Under this assumption, instead of computing the bias  $\|q^{L^*}-q^L\|^2$, we focus on  $\|q^{L_{\max}}-q^L\|^2$. This is not an equality because  the first term decreases when $L&lt;L^*$ and increases when $L&gt;L^*$, while the second term is still decreasing when $L&gt;L^*$. However, we just need the decreasing behavior of the bias which will be compensated by the increasing of the variance. We then introduce the estimator of the bias as $\hat b^L = \|\hat q^{L_{\max}}-\hat q^L\|^2$. For the variance term, we need to bound it. Let us remark that the variance of $\hat q^L$ is  of order $L/N$.  \textcolor{red}{ Est ce qu'on a une ref pour justifier ca ?   J'ai rien trouvé. Mais pour estimer $q^L$, on utilise l'estimateur  $\hat \tau^L$.  Il faudrait pouvoir calculer la variance de cet estimateur pour en déduire l'ordre de celle de $\hat q^L$? }</span>
<span id="cb20-1162"><a href="#cb20-1162" aria-hidden="true" tabindex="-1"></a>Thus we set $$\hat v^L := \lambda \frac{L}{N},$$ where  $\lambda&gt;0$ is a tuning parameter. </span>
<span id="cb20-1163"><a href="#cb20-1163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1164"><a href="#cb20-1164" aria-hidden="true" tabindex="-1"></a>\textcolor{red}{old paragraph - end}</span>
<span id="cb20-1165"><a href="#cb20-1165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1166"><a href="#cb20-1166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1167"><a href="#cb20-1167" aria-hidden="true" tabindex="-1"></a>A natural criteria to select the best $L$ is then  </span>
<span id="cb20-1168"><a href="#cb20-1168" aria-hidden="true" tabindex="-1"></a>$$crit(L) =  \|\hat q^{L_{\max}}-\hat q^L\|^2  +\lambda \frac{L}{N}.$$</span>
<span id="cb20-1169"><a href="#cb20-1169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1170"><a href="#cb20-1170" aria-hidden="true" tabindex="-1"></a>Then we define </span>
<span id="cb20-1171"><a href="#cb20-1171" aria-hidden="true" tabindex="-1"></a>$$\hat L = \arg\min_L crit(L),$$</span>
<span id="cb20-1172"><a href="#cb20-1172" aria-hidden="true" tabindex="-1"></a>and take the band centered around $\underline{\hat{f}}^{\hat L, L^*}$. </span>
<span id="cb20-1173"><a href="#cb20-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1174"><a href="#cb20-1174" aria-hidden="true" tabindex="-1"></a>In @fig-critlast, we illustrate the behavior of this model selection criterion on simulated data, with $\lambda=1$ for the three basis. We can see   that $\hat L$ is overestimated. As we work with nested spaces, it ensures that $\hat L$ has the tendency to be larger than $L^*$ and thus the confidence band is automatically unbiased. </span>
<span id="cb20-1175"><a href="#cb20-1175" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1176"><a href="#cb20-1176" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1177"><a href="#cb20-1177" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-critlast</span></span>
<span id="cb20-1178"><a href="#cb20-1178" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. For a given simulated dataset, we show the behavior of the criteria as a function of the dimension L, for Fourier (left), Legendre (middle) and Splines (right) basis."</span></span>
<span id="cb20-1179"><a href="#cb20-1179" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb20-1180"><a href="#cb20-1180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1181"><a href="#cb20-1181" aria-hidden="true" tabindex="-1"></a>compute.conf.band.L.star<span class="fl">.3</span> <span class="ot">=</span> <span class="cf">function</span>(data, basis, L, <span class="at">Lmax =</span> <span class="dv">30</span>, <span class="at">alpha =</span> <span class="fl">0.05</span>, <span class="at">beta =</span> <span class="fl">0.05</span>){</span>
<span id="cb20-1182"><a href="#cb20-1182" aria-hidden="true" tabindex="-1"></a>  <span class="do">### data: the observations, only the timepoints and the individual functions</span></span>
<span id="cb20-1183"><a href="#cb20-1183" aria-hidden="true" tabindex="-1"></a>  <span class="do">### basis: functional basis, to be chosen in 'Fourier', 'Splines'</span></span>
<span id="cb20-1184"><a href="#cb20-1184" aria-hidden="true" tabindex="-1"></a>  <span class="do">### L: number of functional basis for the signal</span></span>
<span id="cb20-1185"><a href="#cb20-1185" aria-hidden="true" tabindex="-1"></a>  <span class="do">### alpha: the level for the confidence band</span></span>
<span id="cb20-1186"><a href="#cb20-1186" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1187"><a href="#cb20-1187" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.1</span></span>
<span id="cb20-1188"><a href="#cb20-1188" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">1.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb20-1189"><a href="#cb20-1189" aria-hidden="true" tabindex="-1"></a>  data.proj <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-1190"><a href="#cb20-1190" aria-hidden="true" tabindex="-1"></a>  data.scl <span class="ot">=</span> data.proj</span>
<span id="cb20-1191"><a href="#cb20-1191" aria-hidden="true" tabindex="-1"></a>  data.scl<span class="sc">$</span>y <span class="ot">=</span> (data.proj<span class="sc">$</span>y <span class="sc">-</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat)<span class="sc">/</span><span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp))</span>
<span id="cb20-1192"><a href="#cb20-1192" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.scl, alpha)</span>
<span id="cb20-1193"><a href="#cb20-1193" aria-hidden="true" tabindex="-1"></a>  d.L <span class="ot">=</span> c.L <span class="sc">%*%</span> <span class="fu">sqrt</span>(<span class="fu">diag</span>(est.<span class="fl">1.</span>f<span class="sc">$</span>cov.emp)<span class="sc">/</span><span class="fu">ncol</span>(data.scl<span class="sc">$</span>y))</span>
<span id="cb20-1194"><a href="#cb20-1194" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1195"><a href="#cb20-1195" aria-hidden="true" tabindex="-1"></a>  <span class="do">### d.L.2</span></span>
<span id="cb20-1196"><a href="#cb20-1196" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, L)</span>
<span id="cb20-1197"><a href="#cb20-1197" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj <span class="ot">=</span> est.<span class="fl">2.</span>f<span class="sc">$</span>data.proj</span>
<span id="cb20-1198"><a href="#cb20-1198" aria-hidden="true" tabindex="-1"></a>  est.<span class="fl">2.</span>f.Lmax <span class="ot">=</span> <span class="fu">estimator</span>(data, basis, Lmax)</span>
<span id="cb20-1199"><a href="#cb20-1199" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>proj.Lmax <span class="ot">=</span> est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>data.proj</span>
<span id="cb20-1200"><a href="#cb20-1200" aria-hidden="true" tabindex="-1"></a>  residuals.L.Lmax <span class="ot">=</span> data.<span class="fl">2.</span>proj.Lmax<span class="sc">$</span>y <span class="sc">-</span> data.<span class="fl">2.</span>proj<span class="sc">$</span>y <span class="sc">-</span> (est.<span class="fl">2.</span>f.Lmax<span class="sc">$</span>f.hat <span class="sc">-</span> est.<span class="fl">2.</span>f<span class="sc">$</span>f.hat) </span>
<span id="cb20-1201"><a href="#cb20-1201" aria-hidden="true" tabindex="-1"></a>  cov.emp.rest <span class="ot">=</span> <span class="fu">diag</span>(<span class="fu">crossprod</span>(<span class="fu">t</span>(residuals.L.Lmax))) <span class="sc">/</span> <span class="fu">ncol</span>(residuals.L.Lmax)</span>
<span id="cb20-1202"><a href="#cb20-1202" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl <span class="ot">=</span> data.<span class="fl">2.</span>proj</span>
<span id="cb20-1203"><a href="#cb20-1203" aria-hidden="true" tabindex="-1"></a>  data.<span class="fl">2.</span>scl<span class="sc">$</span>y <span class="ot">=</span> residuals.L.Lmax<span class="sc">/</span><span class="fu">sqrt</span>(cov.emp.rest)</span>
<span id="cb20-1204"><a href="#cb20-1204" aria-hidden="true" tabindex="-1"></a>  c.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.c.L</span>(data.<span class="fl">2.</span>scl, beta)</span>
<span id="cb20-1205"><a href="#cb20-1205" aria-hidden="true" tabindex="-1"></a>  d.L.Lmax<span class="fl">.2</span> <span class="ot">=</span> c.L.Lmax<span class="fl">.2</span> <span class="sc">%*%</span> <span class="fu">sqrt</span>(cov.emp.rest<span class="sc">/</span><span class="fu">ncol</span>(data.<span class="fl">2.</span>scl<span class="sc">$</span>y))</span>
<span id="cb20-1206"><a href="#cb20-1206" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1207"><a href="#cb20-1207" aria-hidden="true" tabindex="-1"></a>  f.hat.up <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">+</span> d.L <span class="sc">+</span> d.L.Lmax<span class="fl">.2</span> </span>
<span id="cb20-1208"><a href="#cb20-1208" aria-hidden="true" tabindex="-1"></a>  f.hat.low <span class="ot">=</span> est.<span class="fl">1.</span>f<span class="sc">$</span>f.hat <span class="sc">-</span> d.L <span class="sc">-</span> d.L.Lmax<span class="fl">.2</span></span>
<span id="cb20-1209"><a href="#cb20-1209" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1210"><a href="#cb20-1210" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">f.hat.up =</span> f.hat.up, <span class="at">f.hat.low =</span> f.hat.low, <span class="at">c.L =</span> c.L, <span class="at">c.L.Lmax =</span> c.L.Lmax<span class="fl">.2</span>))</span>
<span id="cb20-1211"><a href="#cb20-1211" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-1212"><a href="#cb20-1212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1213"><a href="#cb20-1213" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb20-1214"><a href="#cb20-1214" aria-hidden="true" tabindex="-1"></a>dfCriterion <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">criterion =</span> <span class="fu">double</span>(),</span>
<span id="cb20-1215"><a href="#cb20-1215" aria-hidden="true" tabindex="-1"></a>                         <span class="at">dimension =</span> <span class="fu">integer</span>(),</span>
<span id="cb20-1216"><a href="#cb20-1216" aria-hidden="true" tabindex="-1"></a>                         <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb20-1217"><a href="#cb20-1217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1218"><a href="#cb20-1218" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-1219"><a href="#cb20-1219" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb20-1220"><a href="#cb20-1220" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){ vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>) }</span>
<span id="cb20-1221"><a href="#cb20-1221" aria-hidden="true" tabindex="-1"></a>  length.band <span class="ot">=</span> c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1222"><a href="#cb20-1222" aria-hidden="true" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis, <span class="at">L.eps =</span> <span class="dv">28</span>)</span>
<span id="cb20-1223"><a href="#cb20-1223" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-1224"><a href="#cb20-1224" aria-hidden="true" tabindex="-1"></a>  c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L  </span>
<span id="cb20-1225"><a href="#cb20-1225" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1226"><a href="#cb20-1226" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-1227"><a href="#cb20-1227" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb20-1228"><a href="#cb20-1228" aria-hidden="true" tabindex="-1"></a>    length.band[L] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L<span class="sc">$</span>f.hat.low <span class="sc">-</span> conf.band.L<span class="sc">$</span>f.hat.up))</span>
<span id="cb20-1229"><a href="#cb20-1229" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb20-1230"><a href="#cb20-1230" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-1231"><a href="#cb20-1231" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb20-1232"><a href="#cb20-1232" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb20-1233"><a href="#cb20-1233" aria-hidden="true" tabindex="-1"></a>  dfCriterion <span class="ot">=</span> <span class="fu">rbind</span>(dfCriterion, <span class="fu">data.frame</span>(<span class="at">criterion =</span> crit,</span>
<span id="cb20-1234"><a href="#cb20-1234" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">dimension =</span> vec.L,</span>
<span id="cb20-1235"><a href="#cb20-1235" aria-hidden="true" tabindex="-1"></a>                                              <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb20-1236"><a href="#cb20-1236" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-1237"><a href="#cb20-1237" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1238"><a href="#cb20-1238" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfCriterion, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> criterion)) <span class="sc">+</span> </span>
<span id="cb20-1239"><a href="#cb20-1239" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>()<span class="sc">+</span></span>
<span id="cb20-1240"><a href="#cb20-1240" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-1241"><a href="#cb20-1241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1242"><a href="#cb20-1242" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1243"><a href="#cb20-1243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1244"><a href="#cb20-1244" aria-hidden="true" tabindex="-1"></a>In @fig-critlastmodsel,  we test which model is selected over 100 repetitions for the three basis. The estimated dimension is  equal or larger than the true $L^*=11$. As in @fig-modelsel, being larger is not a problem.   However, the selected dimension is smaller in distribution, and closer to the true value than in @fig-modelsel. Thus this new approach performs better. Moreover, as we then use the confidence band of @sec-bandSun, the confidence level is ensured to be the expected one. </span>
<span id="cb20-1245"><a href="#cb20-1245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1246"><a href="#cb20-1246" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1247"><a href="#cb20-1247" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-critlastmodsel</span></span>
<span id="cb20-1248"><a href="#cb20-1248" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. We show the distribution of the selected model, over 100 repetitions, with the new criteria used to select a model for different basis."</span></span>
<span id="cb20-1249"><a href="#cb20-1249" aria-hidden="true" tabindex="-1"></a>run <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb20-1250"><a href="#cb20-1250" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (run <span class="sc">==</span> <span class="cn">TRUE</span>){</span>
<span id="cb20-1251"><a href="#cb20-1251" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">"Res_Tab3_n50_3basisBandWidth.RData"</span>)</span>
<span id="cb20-1252"><a href="#cb20-1252" aria-hidden="true" tabindex="-1"></a>  L.max <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb20-1253"><a href="#cb20-1253" aria-hidden="true" tabindex="-1"></a>  vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">1</span>)</span>
<span id="cb20-1254"><a href="#cb20-1254" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1255"><a href="#cb20-1255" aria-hidden="true" tabindex="-1"></a>  dfLengthSelect <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">length =</span> <span class="fu">double</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb20-1256"><a href="#cb20-1256" aria-hidden="true" tabindex="-1"></a>  dfLhatSelect <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Lhat =</span> <span class="fu">double</span>(), <span class="at">L =</span> <span class="fu">integer</span>(), <span class="at">basis =</span> <span class="fu">character</span>())</span>
<span id="cb20-1257"><a href="#cb20-1257" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>,<span class="st">"Fourier"</span>, <span class="st">"Splines"</span>)){</span>
<span id="cb20-1258"><a href="#cb20-1258" aria-hidden="true" tabindex="-1"></a>    mod.sel<span class="ot">=</span> length.CBL <span class="ot">=</span> length.modsel <span class="ot">=</span> length.CBmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1259"><a href="#cb20-1259" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">29</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb20-1260"><a href="#cb20-1260" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (repet <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>){</span>
<span id="cb20-1261"><a href="#cb20-1261" aria-hidden="true" tabindex="-1"></a>      c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1262"><a href="#cb20-1262" aria-hidden="true" tabindex="-1"></a>      <span class="fu">set.seed</span>(repet)</span>
<span id="cb20-1263"><a href="#cb20-1263" aria-hidden="true" tabindex="-1"></a>      data <span class="ot">=</span> <span class="fu">dgp</span>(<span class="at">n=</span><span class="dv">50</span>,<span class="at">N=</span><span class="dv">40</span>, <span class="at">basis =</span> basis)</span>
<span id="cb20-1264"><a href="#cb20-1264" aria-hidden="true" tabindex="-1"></a>      conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-1265"><a href="#cb20-1265" aria-hidden="true" tabindex="-1"></a>      c.Lmax <span class="ot">=</span> conf.band.L.max<span class="sc">$</span>c.L  </span>
<span id="cb20-1266"><a href="#cb20-1266" aria-hidden="true" tabindex="-1"></a>      length.CBmax[repet] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L.max<span class="sc">$</span>f.hat.up <span class="sc">-</span> conf.band.L.max<span class="sc">$</span>f.hat.low)</span>
<span id="cb20-1267"><a href="#cb20-1267" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-1268"><a href="#cb20-1268" aria-hidden="true" tabindex="-1"></a>        conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (<span class="fl">0.05</span>))</span>
<span id="cb20-1269"><a href="#cb20-1269" aria-hidden="true" tabindex="-1"></a>        c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb20-1270"><a href="#cb20-1270" aria-hidden="true" tabindex="-1"></a>        length.CBL[L] <span class="ot">=</span> <span class="fu">max</span>(<span class="fu">abs</span>(conf.band.L<span class="sc">$</span>f.hat.up <span class="sc">-</span> conf.band.L<span class="sc">$</span>f.hat.low))</span>
<span id="cb20-1271"><a href="#cb20-1271" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb20-1272"><a href="#cb20-1272" aria-hidden="true" tabindex="-1"></a>      lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb20-1273"><a href="#cb20-1273" aria-hidden="true" tabindex="-1"></a>      crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb20-1274"><a href="#cb20-1274" aria-hidden="true" tabindex="-1"></a>      mod.sel[repet] <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb20-1275"><a href="#cb20-1275" aria-hidden="true" tabindex="-1"></a>      length.modsel[repet] <span class="ot">=</span> length.CBL[vec.L[<span class="fu">which.min</span>(crit)]]</span>
<span id="cb20-1276"><a href="#cb20-1276" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-1277"><a href="#cb20-1277" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-1278"><a href="#cb20-1278" aria-hidden="true" tabindex="-1"></a>    dfLhatSelect <span class="ot">=</span> <span class="fu">rbind</span>(dfLhatSelect, <span class="fu">data.frame</span>(</span>
<span id="cb20-1279"><a href="#cb20-1279" aria-hidden="true" tabindex="-1"></a>      <span class="at">L =</span> vec.L,</span>
<span id="cb20-1280"><a href="#cb20-1280" aria-hidden="true" tabindex="-1"></a>      <span class="at">Lhat =</span> <span class="fu">matrix</span>(<span class="fu">table</span>(<span class="fu">factor</span>(mod.sel, <span class="at">levels =</span> vec.L))),</span>
<span id="cb20-1281"><a href="#cb20-1281" aria-hidden="true" tabindex="-1"></a>      <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(vec.L))))</span>
<span id="cb20-1282"><a href="#cb20-1282" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-1283"><a href="#cb20-1283" aria-hidden="true" tabindex="-1"></a>    dfBandWidth <span class="ot">=</span> <span class="fu">rbind</span>(dfBandWidth, <span class="fu">data.frame</span>(<span class="at">Band.width =</span> length.modsel,</span>
<span id="cb20-1284"><a href="#cb20-1284" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">basis =</span> <span class="fu">rep</span>(basis, repet),</span>
<span id="cb20-1285"><a href="#cb20-1285" aria-hidden="true" tabindex="-1"></a>                                                <span class="at">dimension =</span> <span class="fu">rep</span>(<span class="st">"Lhat2"</span>, <span class="at">each =</span> repet)))  </span>
<span id="cb20-1286"><a href="#cb20-1286" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-1287"><a href="#cb20-1287" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfLhatSelect, <span class="at">file =</span> <span class="st">"Res_barplot_n50_3basisLhat.RData"</span>)</span>
<span id="cb20-1288"><a href="#cb20-1288" aria-hidden="true" tabindex="-1"></a>  <span class="fu">save</span>(dfBandWidth, <span class="at">file =</span> <span class="st">"Res_Tab3_n50_3basisBandWidth_2.RData"</span>)</span>
<span id="cb20-1289"><a href="#cb20-1289" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {<span class="fu">load</span>(<span class="st">'Res_barplot_n50_3basisLhat.RData'</span>)</span>
<span id="cb20-1290"><a href="#cb20-1290" aria-hidden="true" tabindex="-1"></a>  <span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisBandWidth_2.RData'</span>)}</span>
<span id="cb20-1291"><a href="#cb20-1291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1292"><a href="#cb20-1292" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> dfLhatSelect, <span class="fu">aes</span>(<span class="at">x =</span> L, <span class="at">y =</span> Lhat)) <span class="sc">+</span></span>
<span id="cb20-1293"><a href="#cb20-1293" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span><span class="st">"identity"</span>)<span class="sc">+</span></span>
<span id="cb20-1294"><a href="#cb20-1294" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-1295"><a href="#cb20-1295" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1296"><a href="#cb20-1296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1297"><a href="#cb20-1297" aria-hidden="true" tabindex="-1"></a>We then show in @fig-width-2 that the width of the selected model is better than the width of the confidence band with a large level $L_{\max}$, which one should have used to avoid model selection. </span>
<span id="cb20-1298"><a href="#cb20-1298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1299"><a href="#cb20-1299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1300"><a href="#cb20-1300" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1301"><a href="#cb20-1301" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-width-2</span></span>
<span id="cb20-1302"><a href="#cb20-1302" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Illustrative example. We display within boxplots the confidence band's width over 100 repetitions for the model selected by our criterion, some fixed Lmax and the true (unknown) $L^{*}$ for Fourier (left), Legendre (middle) and Splines (right) basis."</span></span>
<span id="cb20-1303"><a href="#cb20-1303" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb20-1304"><a href="#cb20-1304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1305"><a href="#cb20-1305" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>(<span class="st">'Res_Tab3_n50_3basisBandWidth_2.RData'</span>)</span>
<span id="cb20-1306"><a href="#cb20-1306" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1307"><a href="#cb20-1307" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dfBandWidth, <span class="fu">aes</span>(<span class="at">x =</span> dimension, <span class="at">y =</span> Band.width)) <span class="sc">+</span>    <span class="fu">geom_boxplot</span>() <span class="sc">+</span>     <span class="fu">facet_grid</span>(<span class="sc">~</span>basis)</span>
<span id="cb20-1308"><a href="#cb20-1308" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1309"><a href="#cb20-1309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1310"><a href="#cb20-1310" aria-hidden="true" tabindex="-1"></a><span class="fu"># Real data analysis</span></span>
<span id="cb20-1311"><a href="#cb20-1311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1312"><a href="#cb20-1312" aria-hidden="true" tabindex="-1"></a>In this section, we illustrate the proposed method on the Berkeley Growth Study data. </span>
<span id="cb20-1313"><a href="#cb20-1313" aria-hidden="true" tabindex="-1"></a>It consists of the heights in centimeters of 39 boys at 31 ages from 1 to 18. </span>
<span id="cb20-1314"><a href="#cb20-1314" aria-hidden="true" tabindex="-1"></a>We approximate those curves by our 3 basis, namely Legendre, Splines and Fourier.</span>
<span id="cb20-1315"><a href="#cb20-1315" aria-hidden="true" tabindex="-1"></a>We select the level of each basis using the method introduced in  @sec-modsel. </span>
<span id="cb20-1316"><a href="#cb20-1316" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1317"><a href="#cb20-1317" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, out.height = "25%", fig.width=7}</span></span>
<span id="cb20-1318"><a href="#cb20-1318" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-realdata</span></span>
<span id="cb20-1319"><a href="#cb20-1319" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Real data analysis example. We display the confidence bands for Fourier (left), Legendre (middle) and Splines (right) basis on the Berkeley Growth Study data. Black curves correspond to the confidence bands with $L_{max}$, while colored one are the confidence bands constructed by our data-driven method. "</span></span>
<span id="cb20-1320"><a href="#cb20-1320" aria-hidden="true" tabindex="-1"></a><span class="co">#| </span></span>
<span id="cb20-1321"><a href="#cb20-1321" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(fda)</span>
<span id="cb20-1322"><a href="#cb20-1322" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(growth)</span>
<span id="cb20-1323"><a href="#cb20-1323" aria-hidden="true" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">list</span>()</span>
<span id="cb20-1324"><a href="#cb20-1324" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>time <span class="ot">=</span> (growth<span class="sc">$</span>age <span class="sc">-</span> <span class="fu">min</span>(growth<span class="sc">$</span>age))<span class="sc">/</span>(<span class="fu">max</span>(growth<span class="sc">$</span>age) <span class="sc">-</span> <span class="fu">min</span>(growth<span class="sc">$</span>age))</span>
<span id="cb20-1325"><a href="#cb20-1325" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>y <span class="ot">=</span> growth<span class="sc">$</span>hgtm</span>
<span id="cb20-1326"><a href="#cb20-1326" aria-hidden="true" tabindex="-1"></a>L.max <span class="ot">=</span> <span class="dv">25</span></span>
<span id="cb20-1327"><a href="#cb20-1327" aria-hidden="true" tabindex="-1"></a>vec.L <span class="ot">=</span> <span class="dv">3</span><span class="sc">:</span><span class="dv">24</span></span>
<span id="cb20-1328"><a href="#cb20-1328" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fl">0.2</span></span>
<span id="cb20-1329"><a href="#cb20-1329" aria-hidden="true" tabindex="-1"></a>dfBandlow <span class="ot">=</span> dfBandup <span class="ot">=</span> df.max <span class="ot">=</span> res_growth <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1330"><a href="#cb20-1330" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (basis <span class="cf">in</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Splines"</span>, <span class="st">"Fourier"</span>)){</span>
<span id="cb20-1331"><a href="#cb20-1331" aria-hidden="true" tabindex="-1"></a>  mod.sel<span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1332"><a href="#cb20-1332" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (basis <span class="sc">==</span> <span class="st">'Fourier'</span>){vec.L <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">3</span>,<span class="dv">24</span>, <span class="at">by=</span><span class="dv">2</span>)}</span>
<span id="cb20-1333"><a href="#cb20-1333" aria-hidden="true" tabindex="-1"></a>  c.L <span class="ot">=</span> c.L.Lmax <span class="ot">=</span> <span class="fu">c</span>()</span>
<span id="cb20-1334"><a href="#cb20-1334" aria-hidden="true" tabindex="-1"></a>  conf.band.L.max <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, <span class="at">L =</span> L.max, <span class="at">alpha =</span> alpha)</span>
<span id="cb20-1335"><a href="#cb20-1335" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1336"><a href="#cb20-1336" aria-hidden="true" tabindex="-1"></a>  df.max <span class="ot">=</span> <span class="fu">rbind</span>(df.max, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age, </span>
<span id="cb20-1337"><a href="#cb20-1337" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">band.up =</span> <span class="fu">t</span>(conf.band.L.max<span class="sc">$</span>f.hat.up),</span>
<span id="cb20-1338"><a href="#cb20-1338" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">band.low =</span> <span class="fu">t</span>(conf.band.L.max<span class="sc">$</span>f.hat.low),</span>
<span id="cb20-1339"><a href="#cb20-1339" aria-hidden="true" tabindex="-1"></a>                                    <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb20-1340"><a href="#cb20-1340" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (L <span class="cf">in</span> vec.L){</span>
<span id="cb20-1341"><a href="#cb20-1341" aria-hidden="true" tabindex="-1"></a>    conf.band.L <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, L, <span class="at">alpha =</span> (alpha))</span>
<span id="cb20-1342"><a href="#cb20-1342" aria-hidden="true" tabindex="-1"></a>    c.L[L] <span class="ot">=</span> <span class="fu">max</span>(conf.band.L<span class="sc">$</span>c.L)</span>
<span id="cb20-1343"><a href="#cb20-1343" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb20-1344"><a href="#cb20-1344" aria-hidden="true" tabindex="-1"></a>  lambda <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb20-1345"><a href="#cb20-1345" aria-hidden="true" tabindex="-1"></a>  crit <span class="ot">=</span> <span class="fu">abs</span>(<span class="fu">rep</span>(c.Lmax, <span class="fu">length</span>(vec.L)) <span class="sc">-</span> c.L[vec.L]) <span class="sc">+</span> lambda <span class="sc">*</span> vec.L<span class="sc">/</span>((<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb20-1346"><a href="#cb20-1346" aria-hidden="true" tabindex="-1"></a>  mod.sel <span class="ot">=</span> vec.L[<span class="fu">which.min</span>(crit)]</span>
<span id="cb20-1347"><a href="#cb20-1347" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste0</span>(<span class="st">'model selected:'</span>, mod.sel))</span>
<span id="cb20-1348"><a href="#cb20-1348" aria-hidden="true" tabindex="-1"></a>  conf.band.L.star<span class="fl">.2</span> <span class="ot">=</span> <span class="fu">compute.conf.band.L</span>(data, basis, mod.sel, <span class="at">alpha =</span> alpha)</span>
<span id="cb20-1349"><a href="#cb20-1349" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1350"><a href="#cb20-1350" aria-hidden="true" tabindex="-1"></a>  dfBandup <span class="ot">=</span> <span class="fu">rbind</span>(dfBandup, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age,</span>
<span id="cb20-1351"><a href="#cb20-1351" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">bandup =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.up),</span>
<span id="cb20-1352"><a href="#cb20-1352" aria-hidden="true" tabindex="-1"></a>                                        <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb20-1353"><a href="#cb20-1353" aria-hidden="true" tabindex="-1"></a>  dfBandlow <span class="ot">=</span> <span class="fu">rbind</span>(dfBandlow, <span class="fu">data.frame</span>(<span class="at">Time =</span> growth<span class="sc">$</span>age,</span>
<span id="cb20-1354"><a href="#cb20-1354" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">bandlow =</span> <span class="fu">t</span>(conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>f.hat.low),</span>
<span id="cb20-1355"><a href="#cb20-1355" aria-hidden="true" tabindex="-1"></a>                                          <span class="at">basis =</span> <span class="fu">rep</span>(basis, <span class="fu">length</span>(data<span class="sc">$</span>time))))</span>
<span id="cb20-1356"><a href="#cb20-1356" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(<span class="fu">paste0</span>(<span class="st">'length L sel:'</span>, conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>c.L))</span>
<span id="cb20-1357"><a href="#cb20-1357" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb20-1358"><a href="#cb20-1358" aria-hidden="true" tabindex="-1"></a>  res_growth <span class="ot">=</span> <span class="fu">cbind</span>(res_growth, <span class="fu">c</span>(conf.band.L.max<span class="sc">$</span>c.L, conf.band.L.star<span class="fl">.2</span><span class="sc">$</span>c.L, mod.sel))</span>
<span id="cb20-1359"><a href="#cb20-1359" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-1360"><a href="#cb20-1360" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(res_growth) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Legendre"</span>, <span class="st">"Splines"</span>, <span class="st">"Fourier"</span>)</span>
<span id="cb20-1361"><a href="#cb20-1361" aria-hidden="true" tabindex="-1"></a><span class="fu">row.names</span>(res_growth) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">"Length Lmax"</span>, <span class="st">"Length selected"</span>, <span class="st">"Model selected"</span>)</span>
<span id="cb20-1362"><a href="#cb20-1362" aria-hidden="true" tabindex="-1"></a>df.data <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">Time =</span> <span class="fu">rep</span>(growth<span class="sc">$</span>age,<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]), <span class="at">f =</span> <span class="fu">c</span>(data<span class="sc">$</span>y), <span class="at">ind =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">:</span>(<span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">2</span>]), <span class="at">each =</span> <span class="fu">dim</span>(data<span class="sc">$</span>y)[<span class="dv">1</span>]))</span>
<span id="cb20-1363"><a href="#cb20-1363" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>()<span class="sc">+</span>  <span class="fu">geom_line</span>(<span class="at">data=</span>df.data, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span>f, <span class="at">group=</span>ind), <span class="at">color =</span> <span class="st">"lightgrey"</span>,<span class="at">linewidth=</span> <span class="fl">0.5</span>)<span class="sc">+</span></span>
<span id="cb20-1364"><a href="#cb20-1364" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandup, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandup,<span class="at">col =</span> basis, <span class="at">group =</span> basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb20-1365"><a href="#cb20-1365" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> dfBandlow, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> bandlow,<span class="at">col =</span> basis, <span class="at">group =</span> basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb20-1366"><a href="#cb20-1366" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> df.max, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span> band.up, <span class="at">group=</span>basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span> </span>
<span id="cb20-1367"><a href="#cb20-1367" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="at">data =</span> df.max, <span class="fu">aes</span>(<span class="at">x=</span>Time, <span class="at">y =</span> band.low, <span class="at">group=</span>basis), <span class="at">linewidth =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb20-1368"><a href="#cb20-1368" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(<span class="sc">~</span> basis)</span>
<span id="cb20-1369"><a href="#cb20-1369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1370"><a href="#cb20-1370" aria-hidden="true" tabindex="-1"></a>p1</span>
<span id="cb20-1371"><a href="#cb20-1371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1372"><a href="#cb20-1372" aria-hidden="true" tabindex="-1"></a>res_growth</span>
<span id="cb20-1373"><a href="#cb20-1373" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb20-1374"><a href="#cb20-1374" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1375"><a href="#cb20-1375" aria-hidden="true" tabindex="-1"></a>As the data is not periodic, the Fourier basis is meaningless, and so is the associated confidence band, whatever the level considered. Both splines and Legendre basis give similar confidence bands. </span>
<span id="cb20-1376"><a href="#cb20-1376" aria-hidden="true" tabindex="-1"></a>When analyzing the length of the bands compared with the one with $L_{\max}$ coefficients, we see that there are less smooth but also smaller, and from our empirical study we guess that it makes a trade-off between bias and variance. </span>
<span id="cb20-1377"><a href="#cb20-1377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1378"><a href="#cb20-1378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1379"><a href="#cb20-1379" aria-hidden="true" tabindex="-1"></a><span class="fu"># Conclusion {#sec-conc}</span></span>
<span id="cb20-1380"><a href="#cb20-1380" aria-hidden="true" tabindex="-1"></a>This paper discusses the construction of confidence bands when considering a linear model over a functional family. Depending on the nature of the family (an orthogonal or orthonormal basis, or just a vector space), theoretical guarantees of the linear estimator are reminded and illustrated. </span>
<span id="cb20-1381"><a href="#cb20-1381" aria-hidden="true" tabindex="-1"></a>Then, several confidence bands are proposed. </span>
<span id="cb20-1382"><a href="#cb20-1382" aria-hidden="true" tabindex="-1"></a>First, when considering a functional family with a fixed level, we discuss the confidence band derived from @sun1994. It is bias if the level is not high enough to approximate well the true function.</span>
<span id="cb20-1383"><a href="#cb20-1383" aria-hidden="true" tabindex="-1"></a>Then, a new confidence band is proposed that correct this bias. To do so, the bias is estimated and the additional randomness is controlled. A model selection criterion is proposed to select the best level.</span>
<span id="cb20-1384"><a href="#cb20-1384" aria-hidden="true" tabindex="-1"></a>Unfortunately, the two kinds of randomness are leading to a larger confidence band, and this result is then not more interesting than the naive one, which consists in taking the largest level possible $L_{\max}$. </span>
<span id="cb20-1385"><a href="#cb20-1385" aria-hidden="true" tabindex="-1"></a>Finally, a heuristic model selection criterion is proposed to select the level on the first confidence band, that did not correct the bias. It takes into account the bias as well as the variance, to select a moderate level. Throughout the paper, extensive experimental study on Fourier, Legendre and Spline basis have illustrated the theoretical and methodological proposition, and a real data study is proposed to conclude the paper. </span>
<span id="cb20-1386"><a href="#cb20-1386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1387"><a href="#cb20-1387" aria-hidden="true" tabindex="-1"></a>The last model selection criterion is heuristic, while each term is intuitive. An interesting next step, but out of the scope of this paper, consists of a theoretical study of this criterion. No result, to our knowledge, exist for confidence band with the supremum norm. The euclidean norm is well-studied in general, but is not of interest here, where we want to ensure that the tube is valid as a whole. The supremum norm, on its side, is difficult to study theoretically. A keypoint here also is the randomness of the criterion, that has also to be taken into account, through an oracle inequality for example. </span>
<span id="cb20-1388"><a href="#cb20-1388" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1389"><a href="#cb20-1389" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb20-1390"><a href="#cb20-1390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1391"><a href="#cb20-1391" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb20-1392"><a href="#cb20-1392" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-1393"><a href="#cb20-1393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1394"><a href="#cb20-1394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1395"><a href="#cb20-1395" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix: proofs</span></span>
<span id="cb20-1396"><a href="#cb20-1396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1397"><a href="#cb20-1397" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of Proposition @prp-error </span></span>
<span id="cb20-1398"><a href="#cb20-1398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1399"><a href="#cb20-1399" aria-hidden="true" tabindex="-1"></a> Let us prove the first point.</span>
<span id="cb20-1400"><a href="#cb20-1400" aria-hidden="true" tabindex="-1"></a> We have </span>
<span id="cb20-1401"><a href="#cb20-1401" aria-hidden="true" tabindex="-1"></a> $$ \mathbb{E}(\hat{\underline{\mu}}^{L,L^\star}) = (\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbb{E}(\mathbf{y}) =(\mathbf{B}_L^T \mathbf{B}_L)^{-1} \mathbf{B}_L^T \mathbf{B}_{L^*}\mu^{L^*}=:\underline{\mu}^{L,L^\star}.$$</span>
<span id="cb20-1402"><a href="#cb20-1402" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb20-1403"><a href="#cb20-1403" aria-hidden="true" tabindex="-1"></a> The theory of the linear model gives that the variance of $\hat{\underline{\mu}}^L$ is equal to</span>
<span id="cb20-1404"><a href="#cb20-1404" aria-hidden="true" tabindex="-1"></a> $\sigma^2 (\mathbf{B}^T\mathbf{B})^{-1} \mathbf{B}^T\Sigma \mathbf{B}(\mathbf{B}^T\mathbf{B})^{-1}$</span>
<span id="cb20-1405"><a href="#cb20-1405" aria-hidden="true" tabindex="-1"></a> with $\Sigma=Diag(\Sigma_1, \ldots, \Sigma_N)$ the $nN \times nN$ covariance matrix of $\mathbf{y}$. </span>
<span id="cb20-1406"><a href="#cb20-1406" aria-hidden="true" tabindex="-1"></a> So finally, we have </span>
<span id="cb20-1407"><a href="#cb20-1407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1408"><a href="#cb20-1408" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-1409"><a href="#cb20-1409" aria-hidden="true" tabindex="-1"></a> \hat{\underline{\mu}}^{L,L^\star}</span>
<span id="cb20-1410"><a href="#cb20-1410" aria-hidden="true" tabindex="-1"></a> \sim \mathcal{N}\left(\underline{\mu}^{L,L^\star}, \sigma^2\Sigma_{B}^{L, L^ \varepsilon}</span>
<span id="cb20-1411"><a href="#cb20-1411" aria-hidden="true" tabindex="-1"></a> \right).</span>
<span id="cb20-1412"><a href="#cb20-1412" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-1413"><a href="#cb20-1413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1414"><a href="#cb20-1414" aria-hidden="true" tabindex="-1"></a> Now we can easily deduce the distribution of $\hat{\underline{f}}^{L,L^*}(t)$,</span>
<span id="cb20-1415"><a href="#cb20-1415" aria-hidden="true" tabindex="-1"></a> for each $t\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$:</span>
<span id="cb20-1416"><a href="#cb20-1416" aria-hidden="true" tabindex="-1"></a> $$\hat{\underline{f}}^{L,L^*}(t)- \mathbf f^{L,L^*}(t) \sim \mathcal{N}\left(0, \sigma^2 B(t)\Sigma_{B}^{L, L^\varepsilon} B(t)^T\right).$$</span>
<span id="cb20-1417"><a href="#cb20-1417" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb20-1418"><a href="#cb20-1418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1419"><a href="#cb20-1419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1420"><a href="#cb20-1420" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of Theorem @thm-CB_Liebl_asymptotic</span></span>
<span id="cb20-1421"><a href="#cb20-1421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1422"><a href="#cb20-1422" aria-hidden="true" tabindex="-1"></a>We have </span>
<span id="cb20-1423"><a href="#cb20-1423" aria-hidden="true" tabindex="-1"></a>$$P(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = P(\forall t \in [0,1], |\hat{\underline{f}}^{L, L^*}(t)-\underline{f}^{L, L^*}(t)+ \underline{f}^{L, L^*}(t)- f^{L,L^*}(t)| \leq \hat d^L(t))$$</span>
<span id="cb20-1424"><a href="#cb20-1424" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb20-1425"><a href="#cb20-1425" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb20-1426"><a href="#cb20-1426" aria-hidden="true" tabindex="-1"></a> Set assumptions @def-ass-regression_finite and @def-ass-noise-spline and a probability $\alpha\in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. Then, we have, </span>
<span id="cb20-1427"><a href="#cb20-1427" aria-hidden="true" tabindex="-1"></a>$$\lim_{n \rightarrow +\infty} P(\forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\hat{\underline{f}}^{L, L^*}(t)-f^{L,L^*}(t)| \leq \hat d^L(t)) = 1-\alpha$$</span>
<span id="cb20-1428"><a href="#cb20-1428" aria-hidden="true" tabindex="-1"></a>with $\hat d^L(t) = \hat c^L \sqrt{\hat C_L(t,t)/N}$ and $\hat c^L$ defined as the solution of @eq-cL.</span>
<span id="cb20-1429"><a href="#cb20-1429" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1430"><a href="#cb20-1430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1431"><a href="#cb20-1431" aria-hidden="true" tabindex="-1"></a><span class="fu">## Proof of @prp-CBf</span></span>
<span id="cb20-1432"><a href="#cb20-1432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1433"><a href="#cb20-1433" aria-hidden="true" tabindex="-1"></a>To simplify the notations, let us denote $a(t) = \underline{f}^{L,L^*}(t) - \underline{\hat{f}}_1^{L,L^*}(t)$ and $b(t) = \underline{f}^{L_{\max},L^*}(t)- \underline{f}^{L,L^*}(t)-(\underline{\hat f}_2^{L_{\max}, L^*}(t)-\underline{\hat f}_2^{L,L^*}(t))$. </span>
<span id="cb20-1434"><a href="#cb20-1434" aria-hidden="true" tabindex="-1"></a>We have</span>
<span id="cb20-1435"><a href="#cb20-1435" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-1436"><a href="#cb20-1436" aria-hidden="true" tabindex="-1"></a>    P\left( \exists t |a(t)+b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right) &amp;\leq </span>
<span id="cb20-1437"><a href="#cb20-1437" aria-hidden="true" tabindex="-1"></a>    P\left( \exists t |a(t)|+|b(t)|\geq \hat d_1^L(t) + \hat d_2^{L,L_{\max}}(t)\right)<span class="sc">\\</span></span>
<span id="cb20-1438"><a href="#cb20-1438" aria-hidden="true" tabindex="-1"></a>    &amp;= P\left( \exists t |a(t)| \geq \hat d_1^L(t)  \right)P\left( \exists t  |b(t)|\geq \hat d_2^{L,L_{\max}}(t)\right) = \alpha\beta.</span>
<span id="cb20-1439"><a href="#cb20-1439" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-1440"><a href="#cb20-1440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1441"><a href="#cb20-1441" aria-hidden="true" tabindex="-1"></a> The last equality holds thanks to the independence of the two sub-samples. </span>
<span id="cb20-1442"><a href="#cb20-1442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1443"><a href="#cb20-1443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1444"><a href="#cb20-1444" aria-hidden="true" tabindex="-1"></a><span class="fu"># Heuristics of bounding separately the infinity norms of the \textcolor{green}{bias} term and the \textcolor{green}{approximation} term {#sec:band1}</span></span>
<span id="cb20-1445"><a href="#cb20-1445" aria-hidden="true" tabindex="-1"></a>Let us give the main ideas. We denote </span>
<span id="cb20-1446"><a href="#cb20-1446" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-1447"><a href="#cb20-1447" aria-hidden="true" tabindex="-1"></a> A_{L, L^*} &amp;= \sup_t|Approx(t)| = \sup_t|\underline{f}^{L, L^*}(t) - \underline{f}^{L^*,L^*}(t)| = \sup_t|\underline{f}^{L, L^*}(t) - f^{L^*}(t)|,<span class="sc">\\</span></span>
<span id="cb20-1448"><a href="#cb20-1448" aria-hidden="true" tabindex="-1"></a> b_{L, L^*} &amp;=\sup_t| Bias(t)|= \sup_t|\hat{\underline{f}}^{L, L^*}(t) - \underline{f}^{L, L^*}(t)|,</span>
<span id="cb20-1449"><a href="#cb20-1449" aria-hidden="true" tabindex="-1"></a>\end{align*} </span>
<span id="cb20-1450"><a href="#cb20-1450" aria-hidden="true" tabindex="-1"></a>the two infinity norms of the \textcolor{green}{approximation} and the \textcolor{green}{bias} terms. Recall that when $L\geq L^*$, $Approx(t)=0$ and thus $A_{L, L^*}=0$. Then by the triangular inequality, we get </span>
<span id="cb20-1451"><a href="#cb20-1451" aria-hidden="true" tabindex="-1"></a>$$\sup_t |\hat{\underline{f}}^{L, L^*}(t) -f^{L^*}(t)| \leq A_{L, L^*} + b_{L, L^*}.$$</span>
<span id="cb20-1452"><a href="#cb20-1452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1453"><a href="#cb20-1453" aria-hidden="true" tabindex="-1"></a>If we find a bound $M^L$ such that</span>
<span id="cb20-1454"><a href="#cb20-1454" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb20-1455"><a href="#cb20-1455" aria-hidden="true" tabindex="-1"></a>P( A_{L, L^*} + b_{L, L^*} \leq M^L)\geq 1-\alpha ,</span>
<span id="cb20-1456"><a href="#cb20-1456" aria-hidden="true" tabindex="-1"></a>$$ {#eq-ML_BiaisVariance}</span>
<span id="cb20-1457"><a href="#cb20-1457" aria-hidden="true" tabindex="-1"></a>it will imply a confidence band of order $1-\alpha$ for $f^{L^*}(t)$:</span>
<span id="cb20-1458"><a href="#cb20-1458" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-1459"><a href="#cb20-1459" aria-hidden="true" tabindex="-1"></a>P(\sup_t |\hat{\underline{f}}^{L, L^*}(t) -f^{L^*}(t)| \leq M^L)\geq 1-\alpha .</span>
<span id="cb20-1460"><a href="#cb20-1460" aria-hidden="true" tabindex="-1"></a>$${#eq-ML}}</span>
<span id="cb20-1461"><a href="#cb20-1461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1462"><a href="#cb20-1462" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1463"><a href="#cb20-1463" aria-hidden="true" tabindex="-1"></a>The problem reduces to find $M^L$ which bounds both the \textcolor{green}{bias} term and the \textcolor{green}{approximation} term. We bound each term in  @sec-BiasLstar and @sec-ApproxLstar, respectively. The term $A_{L, L^*}$ is deterministic. However, as it is analytically unknown, we will estimate an upper bound based on observations. </span>
<span id="cb20-1464"><a href="#cb20-1464" aria-hidden="true" tabindex="-1"></a>To guarantee the independence between the two bounds, the sample of observations is split in two parts and the two bounds are calculated on one half of the sample. We denote $\mathbf{y}^1 = (y_1, \ldots, y_{n/2})$ and $\mathbf{y}^2 = (y_{n/2+1}, \ldots, y_{n})$ the two sub-samples. </span>
<span id="cb20-1465"><a href="#cb20-1465" aria-hidden="true" tabindex="-1"></a>Then we introduce the confidence band of $f^{L^*}$ based on $\underline{f}^{L,L^*}$ in @sec-BandLstar. </span>
<span id="cb20-1466"><a href="#cb20-1466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1467"><a href="#cb20-1467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1468"><a href="#cb20-1468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1469"><a href="#cb20-1469" aria-hidden="true" tabindex="-1"></a><span class="fu">## Bound of the \textcolor{green}{bias} term. {#sec-BiasLstar}</span></span>
<span id="cb20-1470"><a href="#cb20-1470" aria-hidden="true" tabindex="-1"></a>The bound of the \textcolor{green}{bias} term is calculated with the first sub-sample $\mathbf{y}^1$ of size $n/2$. The estimator $\hat{\underline{f}}_1^{L, L^*}$ is calculated on this sub-sample. </span>
<span id="cb20-1471"><a href="#cb20-1471" aria-hidden="true" tabindex="-1"></a>The statistical \textcolor{green}{bias} $b_{L, L^*}$ is the supremum of a Gaussian process. Using the confidence band proposed in Section \ref{sec:bandSun}, for a given confidence level $1-\alpha_1$, there exists an estimable function $\hat d_1^L()$ defined as $\hat d_1^L(t)= \hat c^L \sqrt{\frac{\hat{C}_L(t)}{n/2}}$ such that $$P(\forall t, \hat{\underline{f}}^{L,L^*}_1 (t) - \hat d_1^L(t) \leq \underline{f}^{L,L^*}(t)\leq \hat{\underline{f}}^{L,L^*}_1 (t) + \hat d_1^L(t))=1-\alpha_1.$$</span>
<span id="cb20-1472"><a href="#cb20-1472" aria-hidden="true" tabindex="-1"></a>Let us denote $\hat d^L_1 = \sup_t |\hat d_1^L(t)|$. Then with probability $1-\alpha_1$, we have</span>
<span id="cb20-1473"><a href="#cb20-1473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1474"><a href="#cb20-1474" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-1475"><a href="#cb20-1475" aria-hidden="true" tabindex="-1"></a>b_{L,L^*}\leq \hat d^L_1.</span>
<span id="cb20-1476"><a href="#cb20-1476" aria-hidden="true" tabindex="-1"></a>$${eq:borne_bL}</span>
<span id="cb20-1477"><a href="#cb20-1477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1478"><a href="#cb20-1478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1479"><a href="#cb20-1479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1480"><a href="#cb20-1480" aria-hidden="true" tabindex="-1"></a><span class="fu">## Bound of the \textcolor{green}{approximation} term. {#sec-ApproxLstar}</span></span>
<span id="cb20-1481"><a href="#cb20-1481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1482"><a href="#cb20-1482" aria-hidden="true" tabindex="-1"></a>\textcolor{red}{Voir comment on va présenter les deux cas selon $L$ et $L^*$. Soit ici soit apres ? Ou dit on que meme si on estime $A_{L, L^*}$, ca ne change pas grand chose quand $L$ est grand ?? }</span>
<span id="cb20-1483"><a href="#cb20-1483" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1484"><a href="#cb20-1484" aria-hidden="true" tabindex="-1"></a>Let us now bound the \textcolor{green}{approximation} term which has no explicit form. </span>
<span id="cb20-1485"><a href="#cb20-1485" aria-hidden="true" tabindex="-1"></a>We thus need to estimate a bound of $A_{L, L^*}$ and will use the second sub-sample $\mathbf{y}^2$ to do that. </span>
<span id="cb20-1486"><a href="#cb20-1486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1487"><a href="#cb20-1487" aria-hidden="true" tabindex="-1"></a>Let us consider $L_{\max}$ large enough such that $\underline{f}^{L^*,L^*} =\underline{f}^{L_{\max},L^*}$. A natural estimator of $\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)$ is $\hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t)$. We can then decompose the \textcolor{green}{approximation} term by introducing its estimator: </span>
<span id="cb20-1488"><a href="#cb20-1488" aria-hidden="true" tabindex="-1"></a>\begin{align*}</span>
<span id="cb20-1489"><a href="#cb20-1489" aria-hidden="true" tabindex="-1"></a>|\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)|&amp;= </span>
<span id="cb20-1490"><a href="#cb20-1490" aria-hidden="true" tabindex="-1"></a>|\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)-(\hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t))| <span class="sc">\\</span></span>
<span id="cb20-1491"><a href="#cb20-1491" aria-hidden="true" tabindex="-1"></a>&amp;+| \hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t)|.</span>
<span id="cb20-1492"><a href="#cb20-1492" aria-hidden="true" tabindex="-1"></a>\end{align*}</span>
<span id="cb20-1493"><a href="#cb20-1493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1494"><a href="#cb20-1494" aria-hidden="true" tabindex="-1"></a>The first term is a centered Gaussian process, the second term is a quantity that we can estimate and thus bound. </span>
<span id="cb20-1495"><a href="#cb20-1495" aria-hidden="true" tabindex="-1"></a>Let us give a bound for the first term, using Section \ref{sec:bandSun}. </span>
<span id="cb20-1496"><a href="#cb20-1496" aria-hidden="true" tabindex="-1"></a>For a given level $1-\alpha_2$, there exists a function $\hat d^{L,L_{\max}}()$ such that </span>
<span id="cb20-1497"><a href="#cb20-1497" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1498"><a href="#cb20-1498" aria-hidden="true" tabindex="-1"></a>$$ P\left( \forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, |\underline{f}^{L, L^*}(t) - \underline{f}^{L_{\max},L^*}(t)-(\hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t))| \leq \hat d^{L,L_{\max}}(t)\right) = 1-\alpha_2.</span>
<span id="cb20-1499"><a href="#cb20-1499" aria-hidden="true" tabindex="-1"></a>$${eq-borne_dLLmax}</span>
<span id="cb20-1500"><a href="#cb20-1500" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1501"><a href="#cb20-1501" aria-hidden="true" tabindex="-1"></a> Let us denote $\hat d^{L,L_{\max}} = \sup_t |\hat d^{L,L_{\max}}(t)|$ and $\| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*} \|_\infty = \sup_t | \hat{\underline{f}}^{L, L^*} (t)- \hat{\underline{f}}^{L_{\max},L^*} (t)|$. Then we can deduce that with probability $1-\beta_2$</span>
<span id="cb20-1502"><a href="#cb20-1502" aria-hidden="true" tabindex="-1"></a>$$ A_{L,L^*} \leq  \hat d^{L,L_{\max}} + \| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*} \|_\infty.</span>
<span id="cb20-1503"><a href="#cb20-1503" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-1504"><a href="#cb20-1504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1505"><a href="#cb20-1505" aria-hidden="true" tabindex="-1"></a>Note that when $L\geq L^*$, $ A_{L,L^*} = 0$. We thus expect the bound $\hat d^{L,L_{\max}} + \| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*} \|_\infty$ to be small when $L\geq L^*$. But as $L^*$ is unknown, we can not remove it from the bound. \textcolor{red}{Est ce qu'on peut voir que cette borne devient quasiment nulle quand $L$ est grand ? Y compris quand on n'est pas dans le vrai modele ?}</span>
<span id="cb20-1506"><a href="#cb20-1506" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1507"><a href="#cb20-1507" aria-hidden="true" tabindex="-1"></a>\textcolor{cyan}{ajouter ici illustration 5 : étude du terme d'approximation - à regarder}</span>
<span id="cb20-1508"><a href="#cb20-1508" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1509"><a href="#cb20-1509" aria-hidden="true" tabindex="-1"></a><span class="fu">## Confidence band of $\underline{f}^{L^*}$ for a given $L$ {#sec-BandLstar}</span></span>
<span id="cb20-1510"><a href="#cb20-1510" aria-hidden="true" tabindex="-1"></a>Using the two bounds of the \textcolor{green}{bias} and the \textcolor{green}{approximation} terms allows to define a bound $M^L$ of $\hat{\underline{f}}^{L, L^*}-f^{L^*}$. We can prove the following result: </span>
<span id="cb20-1511"><a href="#cb20-1511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1512"><a href="#cb20-1512" aria-hidden="true" tabindex="-1"></a>::: {#thm-CBfLstarMax}</span>
<span id="cb20-1513"><a href="#cb20-1513" aria-hidden="true" tabindex="-1"></a>With high probability, we have</span>
<span id="cb20-1514"><a href="#cb20-1514" aria-hidden="true" tabindex="-1"></a>$$ \forall t \in <span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>, \quad |\hat{\underline{f}}^{L,L^*}(t) - \underline{f}^{L^*,L^*}| \leq \hat M^L</span>
<span id="cb20-1515"><a href="#cb20-1515" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb20-1516"><a href="#cb20-1516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1517"><a href="#cb20-1517" aria-hidden="true" tabindex="-1"></a>with $$\hat M^L := \hat d^L +\hat d^{L,L_{\max}} + \| \hat{\underline{f}}^{L, L^*} - \hat{\underline{f}}^{L_{\max},L^*}\|_\infty$$</span>
<span id="cb20-1518"><a href="#cb20-1518" aria-hidden="true" tabindex="-1"></a>where $\hat d^L$ is defined by \eqref{eq:borne_bL} with level $\alpha/2$ using the first sub-sample $\mathbf{y}^1$ and $\hat d^{L,L_{\max}}$ is defined by \eqref{eq:borne_dLLmax} with level $\alpha/2$ using the second sub-sample $\mathbf{y}^2$. </span>
<span id="cb20-1519"><a href="#cb20-1519" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb20-1520"><a href="#cb20-1520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1521"><a href="#cb20-1521" aria-hidden="true" tabindex="-1"></a>\textcolor{red}{On serait vraiment capable de prouver ce théoreme ? sur le niveau de la proba ?}</span>
<span id="cb20-1522"><a href="#cb20-1522" aria-hidden="true" tabindex="-1"></a>\textcolor{red}{Est ce qu'on peut prouver vraiment la proba ? Montrer que quand $L\geq L^*$, il n'y a plus que le terme $b_L$ et donc la proba est $1-\alpha/2$ alors qu'avant c'est $(1-\alpha/2)^2\approx 1-\alpha$ ? }</span>
<span id="cb20-1523"><a href="#cb20-1523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1524"><a href="#cb20-1524" aria-hidden="true" tabindex="-1"></a>This theorem provides a confidence band for $\underline{f}^{L^*,L^*}$ which is based on the estimator $\hat{\underline{f}}^{L,L^*}$:</span>
<span id="cb20-1525"><a href="#cb20-1525" aria-hidden="true" tabindex="-1"></a>$$ \left<span class="co">[</span><span class="ot">\hat{\underline{f}}^{L,L^*}(t) - \hat M^L; \hat{\underline{f}}^{L,L^*}(t) + \hat M^L\right</span><span class="co">]</span> $$</span>
<span id="cb20-1526"><a href="#cb20-1526" aria-hidden="true" tabindex="-1"></a>for all $t\in<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$. </span>
<span id="cb20-1527"><a href="#cb20-1527" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1528"><a href="#cb20-1528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1529"><a href="#cb20-1529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-1530"><a href="#cb20-1530" aria-hidden="true" tabindex="-1"></a> </span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>